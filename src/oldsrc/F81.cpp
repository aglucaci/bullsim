#include "F81.h"double F81::defFreqA(.25);double F81::defFreqC(.25);double F81::defFreqG(.25);F81::F81()	: Model(4){	nparams=4;	nfreeparams=5;	nfreqParamGroups=1;		param=new Parameter *[nparams];	param[F81::freqA]=new FullParameter(F81::defFreqA,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(DEF),F81::defFreqA,"freqA");	param[F81::freqC]=new FullParameter(F81::defFreqC,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(DEF),F81::defFreqC,"freqC");	param[F81::freqG]=new FullParameter(F81::defFreqG,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(DEF),F81::defFreqG,"freqG");	param[F81::freqT]=new FullParameter(1.0-F81::defFreqA-F81::defFreqC-F81::defFreqG,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(DEF),1.0-F81::defFreqA-F81::defFreqC-F81::defFreqG,"freqT");	stateFreqs=new FreqParamGroup(4,(param+F81::freqA));	CalculateBeta();}F81::F81(double a,double c, double g)	: Model(4){	nparams=4;	nfreeparams=5;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[F81::freqA]=new FullParameter(a,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqA,"freqA");	param[F81::freqC]=new FullParameter(c,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqC,"freqC");	param[F81::freqG]=new FullParameter(g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqG,"freqG");	param[F81::freqT]=new FullParameter(1.0-a-c-g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-F81::defFreqA-F81::defFreqC-F81::defFreqG,"freqT");	stateFreqs=new FreqParamGroup(4,(param+F81::freqA));	CalculateBeta();}F81::F81(double a,double c, double g,double pinv)	: Model(4,pinv){	nparams=4;	nfreeparams=5;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[F81::freqA]=new FullParameter(a,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqA,"freqA");	param[F81::freqC]=new FullParameter(c,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqC,"freqC");	param[F81::freqG]=new FullParameter(g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqG,"freqG");	param[F81::freqT]=new FullParameter(1.0-a-c-g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-F81::defFreqA-F81::defFreqC-F81::defFreqG,"freqT");	stateFreqs=new FreqParamGroup(4,(param+F81::freqA));	CalculateBeta();}F81::F81(double a,double c, double g,int ncat,double gams)	: Model(4,ncat,gams){	nparams=4;	nfreeparams=5;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[F81::freqA]=new FullParameter(a,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqA,"freqA");	param[F81::freqC]=new FullParameter(c,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqC,"freqC");	param[F81::freqG]=new FullParameter(g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqG,"freqG");	param[F81::freqT]=new FullParameter(1.0-a-c-g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-F81::defFreqA-F81::defFreqC-F81::defFreqG,"freqT");	stateFreqs=new FreqParamGroup(4,(param+F81::freqA));	CalculateBeta();}F81::F81(double a,double c, double g,double pinv,int ncat,double gams)	: Model(4,pinv,ncat,gams){	nparams=4;	nfreeparams=5;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[F81::freqA]=new FullParameter(a,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqA,"freqA");	param[F81::freqC]=new FullParameter(c,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqC,"freqC");	param[F81::freqG]=new FullParameter(g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),F81::defFreqG,"freqG");	param[F81::freqT]=new FullParameter(1.0-a-c-g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-F81::defFreqA-F81::defFreqC-F81::defFreqG,"freqT");	stateFreqs=new FreqParamGroup(4,(param+F81::freqA));	CalculateBeta();}F81::~F81(){	for(int i=0;i<nparams;i++)		delete param[i];	delete [] param;}void F81::UpdatePMatrix(double **pmats,double blen){	double emut=exp(-blen*beta);	double oneminemut=1.0-emut;	double *temp;	temp=*pmats;	*temp++=param[F81::freqA]->val+(1-param[F81::freqA]->val)*emut;	//AA	*temp++=param[F81::freqC]->val*oneminemut;										//AC	*temp++=param[F81::freqG]->val*oneminemut;	//AG	*temp++=param[F81::freqT]->val*oneminemut;										//AT		*temp++=param[F81::freqA]->val*oneminemut;										//CA	*temp++=param[F81::freqC]->val+(1-param[F81::freqC]->val)*emut;		//CC	*temp++=param[F81::freqG]->val*oneminemut;										//CG	*temp++=param[F81::freqT]->val*oneminemut;									//CT		*temp++=param[F81::freqA]->val*oneminemut;										//GA	*temp++=param[F81::freqC]->val*oneminemut;										//GC	*temp++=param[F81::freqG]->val+(1-param[F81::freqG]->val)*emut;					//GG	*temp++=param[F81::freqT]->val*oneminemut;										//GT		*temp++=param[F81::freqA]->val*oneminemut;										//TA	*temp++=param[F81::freqC]->val*oneminemut;										//TC	*temp++=param[F81::freqG]->val*oneminemut;										//TG	*temp=param[F81::freqT]->val+(1-param[F81::freqT]->val)*emut;					//TT}/*void F81::UpdatePmatGamma(double blen){		double *temp;	temp=**pmats;	for(int i=0;i<ngamcat;i++)	{double emut=exp(-blen*beta**(rates+i));	double oneminemut=1.0-emut;	*temp++=param[F81::freqA]->val+(1-param[F81::freqA]->val)*emut;	//AA	*temp++=param[F81::freqC]->val*oneminemut;										//AC	*temp++=param[F81::freqG]->val*oneminemut;	//AG	*temp++=param[F81::freqT]->val*oneminemut;										//AT		*temp++=param[F81::freqA]->val*oneminemut;										//CA	*temp++=param[F81::freqC]->val+(1-param[F81::freqC]->val)*emut;		//CC	*temp++=param[F81::freqG]->val*oneminemut;										//CG	*temp++=param[F81::freqT]->val*oneminemut;									//CT		*temp++=param[F81::freqA]->val*oneminemut;										//GA	*temp++=param[F81::freqC]->val*oneminemut;										//GC	*temp++=param[F81::freqG]->val+(1-param[F81::freqG]->val)*emut;					//GG	*temp++=param[F81::freqT]->val*oneminemut;										//GT		*temp++=param[F81::freqA]->val*oneminemut;										//TA	*temp++=param[F81::freqC]->val*oneminemut;										//TC	*temp++=param[F81::freqG]->val*oneminemut;										//TG	*temp++=param[F81::freqT]->val+(1-param[F81::freqT]->val)*emut;					//TT	}}*/	void F81::CalculateBeta()//Should be called whenever kappa or the base freqs are changed//Beta is a factor that is multiplied to the branchlength to make the eqns in //Molecular Systematics work.  This the constraint that Sum qii * freq(i) = -1 this ensures that the branches are in length//that are expected numbers of changes  //For GTR the rate params are scaled down to maintain their same ratio, but make beta=1.0{	double x;	x=(param[F81::freqA]->val*param[F81::freqG]->val) + (param[F81::freqC]->val*param[F81::freqT]->val);	x+=(param[F81::freqA]->val+param[F81::freqG]->val) * (param[F81::freqC]->val+param[F81::freqT]->val);	beta=1.0/(2.0 * x);}void F81::InitializeParameters(){	RateManager::InitializeParameters();	for(int i=0;i<nparams;i++)		{if(param[i]->StartWithCurrent()) ;		else	if(param[i]->StartWithRandom())				throw IncompleteModel("Random Function to initialize parameters isn't available yet");				//param[i]->val=SomeRandomNumberFunction();		else	if(param[i]->StartWithApproximation())					throw IncompleteModel("Initial approximation of parameters isn't available yet");		else	if(param[i]->StartWithDefault())					param[i]->SetToDefault();		else	throw BadSettings("No starting value of a parameter has been defined");		}}