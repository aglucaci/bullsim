#include "likesettings.h"ModSettings::ModSettings(Model *m){	useCurrentBrLen=true;	stationaryModel=true;	startingBrLen=DEFAULTSTARTINGBRLEN;		mod=m;	blenModSetting=blenSetting=par(DEF)|par(MIN);	hasBrLenMod=false;	numBrLenMod=0;}void ModSettings::SetUseCurrentBrLen(bool i){	useCurrentBrLen=i;}Model *ModSettings::GetModel(){	return mod;}bool ModSettings::StationaryModel(){	return stationaryModel;}	#ifdef DEBUGGINGPartSettings::PartSettings(int s,int e)//in debugging version I add JC, because I haven't written the LSet command handler yet{	AligningSeqs=false;	nmodels=1;	assert(s<=e);	segmentsInPartition.push_back(make_pair(s,e));	ModelMixingStartingVals=NULL;	ModelMixingSetting=par(CUR);	//Model * mod = new GTR(0.276390,0.288800,0.165845,2,3,4,5,6,0.237696,4,0.335219);	//Model * mod = new GTR(0.276390,0.288800,0.165845,2,3,4,5,6,0.237696);	//Model * mod = new GTR(0.212329 , 0.273019 , 0.275763 , 1.69887 , 2.3204 , 1.3685 , 1.43009,  2.71438 , 4 , 2.2793);	Model * mod = new GTR(0.25 , 0.25 , 0.25 , 1 , 2 , 1 , 1,  2, .1 , 4 , .5);	//Model * mod = new GTR(0.20819345 , 0.27625946 , 0.28402847 , 1.6867985 , 2.3122962 , 1.43943 , 1.3327206,  2.7877558 , 0.036223237 , 4 , 2.7049082);		//Model * mod = new HKY(26.2,.122,.430363,.057495);	modSettings.push_back(new ModSettings(mod));}#elsePartSettings::PartSettings(int s,int e){	AligningSeqs=false;	nmodels=0;	assert(s<=e);	segmentsInPartition.push_back(make_pair(s,e));	ModelMixingStartingVals=NULL;	ModelMixingSetting=par(CUR);	}#endifvoid PartSettings::SetUseCurrentBrLen(bool i){	for(int j=0;j<nmodels;j++)		modSettings[j]->SetUseCurrentBrLen(i);}int PartSettings::GetNModels(){	return nmodels;}Model *PartSettings::GetModel(int i){	return modSettings[i]->GetModel();}int PartSettings::GetRawDataSize(){	int s=0;	pair<int,int> seg;	for(int i=0;i<segmentsInPartition.size();i++)		{seg=segmentsInPartition[i];		s+=seg.second-seg.first; 		}	return s;}int PartSettings::GetNSegments(){	return segmentsInPartition.size();}pair<int,int> PartSettings::GetSegment(int i){	return segmentsInPartition[i];}bool PartSettings::DoingAlignment()	{	return AligningSeqs;}bool PartSettings::AllStationaryModels(){	for(int i=0;i<nmodels;i++)			if(!(modSettings[i]->StationaryModel()))			return false;	return true;}	double PartSettings::GetStartingFreqnOfThisModel(int j) {	if(nmodels<2)	return 1.0;	assert(j<nmodels);	if(ModelMixingStartingVals)		return ModelMixingStartingVals->GetParameter(j)->val;	return (1.0/nmodels);}LikeSettings::LikeSettings(int f,int l){	optimizingBrLens=true;	maximize=true;	maxPasses= DEFAULTMAXPASSES;	delta = DEFAULTDELTA;	useRSBranchLengths=false;	sumOverAncStates=true;	nDataPartitions=1;	summingOverAllAncStates=true;#ifdef DEBUGGING	userInputBrLen=true;#else	userInputBrLen=false;#endif		partSettings.push_back(new PartSettings(f,l));	}void LikeSettings::SetUseCurrentBrLen(bool i){	for(int j=0;j<nDataPartitions;j++)		partSettings[j]->SetUseCurrentBrLen(i);}int LikeSettings::GetNDataPartitions(){	return nDataPartitions;}int LikeSettings::GetNModelsInPart(int i){	return (partSettings[i]->GetNModels());}Model *LikeSettings::GetModel(int i,int j){	return (partSettings[i]->GetModel(j));}int LikeSettings::GetRawDataSize(int partnum){	return partSettings[partnum]->GetRawDataSize();}void LikeSettings::CopyAPartitionsRawData(short *destination,map<nxsstring,EncodedChars *>&rawData,int partnum,int taxnum){	short *rd;	rd=rawData[IncludedTaxa[taxnum]]->GetDataPtr();	pair<int,int> seg;	for(int i=0;i<partSettings[partnum]->GetNSegments();i++)		{seg=partSettings[partnum]->GetSegment(i);		short *temp;		temp=rd+seg.first;		for(int j=seg.first;j<seg.second;j++)			*destination++=*temp++;		}}	bool LikeSettings::SummingOverAllAncStates(){	return summingOverAllAncStates;}bool LikeSettings::DoingAlignment()	{	bool a=false;	for(int i=0;i<nDataPartitions;i++)		a|=partSettings[i]->DoingAlignment();	return a;}bool LikeSettings::DoingAlignment(int i)	{	return partSettings[i]->DoingAlignment();}bool LikeSettings::AllStationaryModels(){	for(int i=0;i<nDataPartitions;i++)			if(!(partSettings[i]->AllStationaryModels()))			return false;	return true;}	int LikeSettings::GetNSetsOfBranchLengths(){	map<PartModIndex,int> brlens;	for(int i=0;i<nDataPartitions;i++)		for(int j=0; j<partSettings[i]->GetNModels();j++)			if(brlens.find(partSettings[i]->GetBrLenOwner(j))==brlens.end())				brlens[partSettings[i]->GetBrLenOwner(j)]=1;	return brlens.size();}int LikeSettings::GetNSetsOfBranchLengthModifiers(){	map<PartModIndex,int> brlens;	for(int i=0;i<nDataPartitions;i++)		for(int j=0; j<partSettings[i]->GetNModels();j++)			if(partSettings[i]->HasBrLenMod(j))				if(brlens.find(partSettings[i]->GetBrLenModOwner(j))==brlens.end())					brlens[partSettings[i]->GetBrLenModOwner(j)]=1;	return brlens.size();}PartModIndex LikeSettings::GetOwnerOfNthSetOfBrLengths(int ownint){	//extremely ugly and slow, but should be called very often	map<PartModIndex,int> brlens;	for(int i=0;i<nDataPartitions;i++)		for(int j=0;j<partSettings[i]->GetNModels();j++)			if(brlens.find(partSettings[i]->GetBrLenOwner(j))==brlens.end())				{brlens[partSettings[i]->GetBrLenOwner(j)]=1;				if(brlens.size()==1+ownint)					return partSettings[i]->GetBrLenOwner(j);				}	throw 	LikeSettingException("Requesting too many sets of branch lengths ");}PartModIndex LikeSettings::GetOwnerOfNthSetOfBrLengthModifiers(int ownint){	//extremely ugly and slow, but should be called very often	map<PartModIndex,int> brlens;	for(int i=0;i<nDataPartitions;i++)		for(int j=0;j<partSettings[i]->GetNModels();j++)			if(partSettings[i]->HasBrLenMod(j))				if(brlens.find(partSettings[i]->GetBrLenModOwner(j))==brlens.end())					{brlens[partSettings[i]->GetBrLenModOwner(j)]=1;					if(brlens.size()==1+ownint)						return partSettings[i]->GetBrLenModOwner(j);					}	throw 	LikeSettingException("Requesting too many sets of branch lengths ");}PartModIndex LikeSettings::GetOwnerOfBrLens(int p,int  m){	return partSettings[p]->GetBrLenOwner(m);}PartModIndex LikeSettings::GetOwnerOfBrLenModifiers(int p,int  m){	assert(partSettings[p]->HasBrLenMod(m));	return partSettings[p]->GetBrLenModOwner(m);}	