#include "node.h"#include <map>#include <algorithm>#include "mynexus.h"#include "basicbulldefs.h"#include <ostream.h>#ifndef _TREE_#define _TREE_#include "models.h"#include "likeattributes.h"#include "parsattributes.h"class IllegalBranchLength : public MTHException { public :	IllegalBranchLength() : MTHException() {}	IllegalBranchLength(const char *c) :MTHException(c) { }	};	class TreeEncodingException : public MTHException { public :	TreeEncodingException() : MTHException() {}	TreeEncodingException(const char *c) :MTHException(c) { }	};class Tree  {	Node *root;	Node **recursiveNodeList;	Node **recursInternalNodeList;	int ntax, nchar;	vector<Node *> termTax;	nxsstring name;	int memoryAllocation;#ifdef CODONHACK	int numTempArrsNeeded;#endif	bool attributesDirty,branchLengthsFromFile;		TreeLikeAttr *lastScoredLikeAtt;	SetOfTreeLikeAttr *setOfLikeAtt;	TreeParsAttr *lastScoredParsAtt;	SetOfTreeParsAttr *setOfParsAtt;			public:	static int timesscored;	int tempOneBrentScored;	double likelihood;	Tree();	Tree(Node *);	Tree(nxsstring tstring,bool readBrLens=true);	~Tree();		int GetNTax()	{return ntax;}	void AssignDataToTerm(TaxaBlock *,map<nxsstring, EncodedChars *>);	void DestroyTreeNotData(void);		void SetName(nxsstring);	nxsstring GetName();	bool AttributesAreDirty()	{return attributesDirty;}	Node **GetRecursiveNodeList();	void SetLikeAttributes(SetOfTreeLikeAttr *l)	{delete setOfLikeAtt; setOfLikeAtt=l;}	void SetParsAttributes(SetOfTreeParsAttr *p)	{delete setOfParsAtt; setOfParsAtt=p;}	SetOfTreeLikeAttr *GetLikeAttributes()	{return setOfLikeAtt;}	SetOfTreeParsAttr *GetParsAttributes()	{return setOfParsAtt;}	double LScoreAlreadyInitialized();	double LScoreAlreadyInitialized(int partnum,bool OnlyScoreDirty);	bool IsGood()	{if(root)	return root->IsGood();					return false;					}	void CalcLikeBelow(Node *nod,Node **localRecNodList);	void LikelihoodSweepOverAPartitionModel(Node **);	double LScoreDirtyParts();	void NotifyModelOfChangedParameter(PartModIndex pmi,Parameter *p);			void NotifyModelOfChangedParameter(PartModIndex pmi,FreqParamGroup *f);	void NotifyModelsThatFreqParamChangesAreDone(PartModIndex pmi,FreqParamGroup *f);	void PrepareLikeAttrAndAllNodes(int partnum,int modn);	void PrepareLikeAttrForCalcuation(int partnum,int modn,Node *tempno);	double BranchLengthSmoothingPass(PartModIndex owner,vector<PartModIndex>* affected,double maxPasses,double delta,int &NumBranchesAlreadyOptimized);	void OneBranchLinearBrent(Node *,PositiveParameter *blen,double maxPasses,double delta);	void OneBranchLinearBrent(double *condLikesBelow,Node *,double maxPasses,double delta);	void BracketBranchLen(Node *nod,PositiveParameter *blen,double *a,double *ascore,double *b,double *bscore,double *c,double *cscore);	void GetBracketNearMin(Node *nod,PositiveParameter *blen,double *a,double *ascore,double *b,double *bscore,double *c,double *cscore);	void GetBracketNearMax(Node *nod,PositiveParameter *blen,double *a,double *ascore,double *b,double *bscore,double *c,double *cscore);	void GetSecondPoint(Node *nod,PositiveParameter *blen,double *firPt,double *secPt,double *firSc,double *secSc,bool OnlyDecrease);	double ScoreAffectedBranch(Node *,PositiveParameter *blen);	void Print(ostream &usrstream,bool withBrLen,bool tabbing=false);	void PrintModel(ostream &usrstream);	void PrepareParsAttrForCalcuation(int partnum);	int FirstPass(int charact);	void SecondPass(int charact);	double GetPStateFreq(int charact,int state,int mode);//0 is maximize the character state, 1 is minimize it	void NameInternalNodes(void);	void ShowTree(int windowWidth,int displayMode=branchDisplay(allNames),int optArg=0);	int GetDepthTimesNSib(void)	{return root->GetDepthTimesNSib();}	int GetNumBranches();#ifdef CODONHACK	double RecursiveBranchLengthSmoothingPass(LikeWorkArray **workArrays,int *nStatesInThisSite,Model **modArrays,LikeWorkArray *below,int totSizeOfArrays,double maxPasses,double delta,int &NumBranchesAlreadyOptimized,int numSitesInProtein);	void SetArrayToAboveBottOfNode(double *cl,Node *tempno,int *nStatesInThisSite);	//void RecursiveBranchLengthSmoothingPassOnSubTree(Node *thisNode,LikeWorkArray **workArrays,int *nStatesInThisSite,LikeWorkArray *below,int totSizeOfArrays,double maxPasses,double delta);#endif	void ReRoot(Node *futldes);	void RecodeTerminalsAndLikeAttr(int p,int m);	double SweepOverTreeStoringCondLikeAboveBottom(LikeWorkArray **workArrays,int numArrays);	void UpdateBranchesInRecursiveOrder(double *optBranchLengths, int nBranchesToUpdate)	{root->UpdateBranchesInRecursiveOrder(optBranchLengths,nBranchesToUpdate);}};LikeWorkArray* RequestFreeLikeWorkArray(LikeWorkArray **workArrays,int maxNum);LikeWorkArray* RequestSpecificLikeWorkArray(LikeWorkArray **workArrays,int maxNum,Node *reqNo,int reqDesc);#endif