#include "nxsstring.h"nxsstring& nxsstring::operator+=( const double d ){   char tmp[81];   sprintf( tmp, "%.6f", d );   int tmplen = strlen(tmp);   for(;;) {      if( tmplen < 3 || tmp[tmplen-1] != '0' || tmp[tmplen-2] == '.' )         break;      tmp[tmplen-1] = '\0';      tmplen--;   }   append(tmp);   return *this;}/** * @method ShortenTo [void:public] * @param n [int] maximum number of characters * * Shortens string to n-3 characters, making the last * three characters "...".  If string is already less * than n character in length, has no effect.  The  * parameter n should be at least 4. */void nxsstring::ShortenTo( int n ){	if( length() <= n )		return;			assert( n > 3 );			char* s = new char[n+1];	strncpy( s, this->c_str(), n-3 );	s[n-3] = '.';	s[n-2] = '.';	s[n-1] = '.';	s[n] = '\0';	*this = s;}nxsstring GetTreeToken(nxsstring fullstr,nxsstring::iterator &c){	//Expecting either a name or tree code character (;,:) 	//Names: can be in single quotes (which are stripped off).  	//Preceeding and terminal whitespace is removed (except if it is in a single quoted name)		nxsstring tk=GetNextGraphicalNonCommentedChar(fullstr,c);	if(*c=='\'')				{tk="";			while(*c!='\'' && c!=fullstr.end())				tk+=*c++;			if(c!=fullstr.end())	c++;			return tk;			}	if(c==fullstr.end())	return tk;	c++;	if(tk[0]=='(' || tk[0]==')' || tk[0]==':' || tk[0]==';' || tk[0]==','|| *c=='[')		return tk;	while(*c!='(' && *c!=')' && *c!=':' && *c!=';' && *c!=','&& *c!='\'' && isgraph(*c))		{if(*c=='[')			GetNextNonCommentedChar(fullstr,c);		else			{tk+=*c;			c++;			}		}	return tk;	}char GetNextGraphicalNonCommentedChar(nxsstring fullstr,nxsstring::iterator &c){	while(c!=fullstr.end() &&!isgraph(*c) )	c++;	if(c==fullstr.end())	return 0;	if(*c!='[')	return *c;	while(c!=fullstr.end() && *c!=']')	c++;	if(c==fullstr.end())	return 0;	c++;	return GetNextGraphicalNonCommentedChar(fullstr,c);	}char GetNextNonCommentedChar(nxsstring fullstr,nxsstring::iterator &c){	if(*c!='[')	return *c;	while(c!=fullstr.end() && *c!=']')	c++;	if(c==fullstr.end())	return 0;	c++;	return GetNextNonCommentedChar(fullstr,c);	}nxsstring& BlanksToUnderscores( nxsstring& s ){   int len = s.length();   for( int k = 0; k < len; k++ ) {      if( s[k] == ' ' )         s[k] = '_';   }   return s;}nxsstring& UnderscoresToBlanks( nxsstring& s ){   int len = s.length();   for( int k = 0; k < len; k++ ) {      if( s[k] == '_' )         s[k] = ' ';   }   return s;}void ToUpper(nxsstring& s){	for( int i = 0; i < s.size(); i++ )      s[i] = (char)toupper( s[i] );}/*void RemovePreceedingWhitespace(nxsstring& s){	if(s.size()<1)	return;	if(isgraph(s[0]))	return;	nxsstring tmp;	int i;	for(i = 0; (i < s.size() && !(isgraph(s[i]))); i++ );	for(;i< s.size();i++)		tmp+=s[i];	s=tmp;}void RemoveFollowingWhiteSpace(nxsstring& s){	if(s.size()<1)	return;	if(isgraph(s[s.size()-1]))	return;	nxsstring tmp;	int i;	for(i = 0; (i < s.size() && !(isgraph(s[i]))); i++ );	for(;i< s.size();i++)		tmp+=s[i];	s=tmp;}*/