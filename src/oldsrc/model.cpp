#include "model.h"double RateManager::defPinv(.1);double RateManager::defGammaShape(.5);	RateManager::RateManager()//default no rate het{	rateHet=false;	rates=NULL;	ngamcat=1;	pinv=NULL;	gammashape=NULL;}RateManager::RateManager(int nc,double gs) //gamma rates with shape{assert(nc<=maxcat);	if(nc>1)		{ngamcat=nc;		rates=new double[ngamcat];		rateHet=true;		gammashape=new PositiveParameter(gs,par(MIN)|par(CUR),defGammaShape);		CalculateRates();		}	else {ngamcat=1;		 rateHet=false;		 rates=NULL;		 gammashape=NULL;		 }	pinv=NULL;}RateManager::RateManager(double pi)//pinv{	rateHet=true;	ngamcat=1;	rates=false;	pinv=new FullParameter(pi,0.0,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),defPinv,"Pinvar");	gammashape=NULL;}RateManager::RateManager(double pi ,int nc ,double gs) //pinv + gamma shape specified{	assert(nc<=maxcat);	rateHet=true;	if(nc>1)		{ngamcat=nc;		rates=new double[ngamcat];		gammashape=new PositiveParameter(gs,par(MIN)|par(CUR),defGammaShape);		CalculateRates();		}	else {ngamcat=1;		 rates=NULL;		 }	pinv=new FullParameter(pi,0.0,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),defPinv,"Pinvar");;}RateManager::~RateManager(){	delete gammashape;	delete pinv;	delete [] rates;}void RateManager::CalculateRates(void ){	//I can't remember where I pinched this code from	assert(gammashape && rates && ngamcat>1);	int i;	double a, b, invK, x, y;	double N = (double)ngamcat;	double twoShape = 2.0 * gammashape->val;//#if defined( USE_RATE_MEAN )	invK = 1.0 / N;	b = 0.0;	x = 1.0;  /* (in case user sets nRateCategs=1) */	for (i = 0; i < ngamcat - 1; i++)		{		a = b;		b = PointChi2( invK * (i+1), twoShape ) / twoShape;		x = gammq( gammashape->val + 1.0, b * gammashape->val );		if( a > 0.0 )			y = gammq( gammashape->val + 1.0, a * gammashape->val );		else			y = 1.0;		rates[i] = (y - x) * N;		}	rates[ngamcat - 1] = x * N;/*#else	//MTH changed nRateCategs to numcat ??	invK = 0.5 / ((double) numcat); double sum = 0.0; for (i = 0; i < numcat; i++) sum += (mean[i] = point_chi2(invK * (i*2+1), twoShape) / twoShape);	double scaler = N / sum; for (i = 0; i < numcat; i++) mean[i] *= scaler;#endif	for (i = 0; i < numcat; i++) { ratecatprob[i] = 1.0 / N; cumprob[i] = ( i == 0 ? ratecatprob[i] : cumprob[i-1] + ratecatprob[i] );}*/}void RateManager::InitializeParameters(){	if(gammashape)		{if(gammashape->StartWithCurrent()) ;		else	if(gammashape->StartWithRandom())					throw IncompleteModel("Random Function to initialize parameters isn't available yet");				///*param[i]->val=SomeRandomNumberFunction();		else	if(gammashape->StartWithApproximation())					throw IncompleteModel("Initial approximation of parameters isn't available yet");		else	if(gammashape->StartWithDefault())					gammashape->SetToDefault();		else	throw BadSettings("No starting value of a parameter has been defined");		}	if(pinv)		{if(pinv->StartWithCurrent()) ;		else	if(pinv->StartWithRandom())				throw IncompleteModel("Random Function to initialize parameters isn't available yet");				//param[i]->val=SomeRandomNumberFunction();		else	if(pinv->StartWithApproximation())					throw IncompleteModel("Initial approximation of parameters isn't available yet");		else	if(pinv->StartWithDefault())					pinv->SetToDefault();		else	throw BadSettings("No starting value of a parameter has been defined");		}}Model::Model(int n)		: RateManager()	{nstates=n;	pMatrix=psdmatrices(n,1);	chperst=1;	pmatcalc=false;	param=NULL;	stateFreqs=NULL;	}Model::Model(int n,double ***pMat)		: RateManager()	{nstates=n;	pMatrix=pMat;	chperst=1;	pmatcalc=false;	param=NULL;	stateFreqs=NULL;	}Model::Model(int n,double pi)		: RateManager(pi)	{nstates=n;	pMatrix=psdmatrices(n,1);	chperst=1;	pmatcalc=false;	param=NULL;	stateFreqs=NULL;	}Model::Model(int n,int numcat,double gamsh)		: RateManager(numcat,gamsh)	{nstates=n;	pMatrix=psdmatrices(n,ngamcat);	chperst=1;	pmatcalc=false;	param=NULL;	stateFreqs=NULL;	}Model::Model(int n,double pi, int numcat,double gamsh)		: RateManager(pi,numcat,gamsh)	{nstates=n;	pMatrix=psdmatrices(n,ngamcat);	chperst=1;	pmatcalc=false;	param=NULL;	stateFreqs=NULL;	}Model::~Model(){	free_psdmatrices(pMatrix,ngamcat);	delete [] param;	delete stateFreqs;	}void ModelWEig::SharedConstruction(int n){	REigenValues=new double[n];	ImEigenValues=new double[n];	REigenVector=psdmatrix(n);	InvEigenVector=psdmatrix(n);	CEigenVector=pscmatrix(n);	CInvEigenVector=pscmatrix(n);	qMatrix=psdmatrix(n);	EigExp=new double[n];	eigencalc=false;#ifdef PRESUMMINGCONSTS	preSummed=new double[n*n];#endif}ModelWEig::ModelWEig(int n)			: Model(n)	{SharedConstruction(n);	EigInvEigMat=new double[n*n*n];	}ModelWEig::ModelWEig(int n, double pi)			: Model(n,pi)	{SharedConstruction(n);	EigInvEigMat=new double[n*n*n];	}ModelWEig::ModelWEig(int n,int numcat, double gamsh)			: Model(n,numcat,gamsh)	{SharedConstruction(n);	EigInvEigMat=new double[n*n*n];	}ModelWEig::ModelWEig(int n,double pi,int numcat, double gamsh)			: Model(n,pi,numcat,gamsh)	{SharedConstruction(n);	EigInvEigMat=new double[n*n*n];	}ModelWEig::ModelWEig(int n,double *preAllocEIEM)			: Model(n)	{SharedConstruction(n);	EigInvEigMat=preAllocEIEM;	}ModelWEig::ModelWEig(int n,double **vecPreAlloc/*size 4*/,double ***matPreAlloc/*size 4*/,complex ***complexPreAlloc/*size 2*/,double ***pMat)			: Model(n,pMat)	{REigenValues=vecPreAlloc[0];	EigInvEigMat=vecPreAlloc[1];	ImEigenValues=vecPreAlloc[2];	REigenVector=matPreAlloc[0];	InvEigenVector=matPreAlloc[1];	CEigenVector=complexPreAlloc[0];	CInvEigenVector=complexPreAlloc[1];	qMatrix=matPreAlloc[2];	EigExp=vecPreAlloc[3];	eigencalc=false;#ifdef PRESUMMINGCONSTS	preSummed=new double[n*n];#endif	}ModelWEig::~ModelWEig(){	delete [] REigenValues;	delete [] EigInvEigMat;	delete [] ImEigenValues;	delete [] EigExp;	free_psdmatrix(REigenVector);	free_psdmatrix(InvEigenVector);	free_pscmatrix(CEigenVector);	free_pscmatrix(CInvEigenVector);	free_psdmatrix(qMatrix);#ifdef PRESUMMINGCONSTS	delete [] preSummed;#endif}void ModelWEig::UpdatePMatrix(double **pmats,double blen)	{	assert(REigenValues && ImEigenValues && REigenVector && InvEigenVector && CEigenVector && CInvEigenVector);	if(!eigencalc)		{CalculateQ();		IsComplex=GetEigens(nstates,qMatrix,REigenValues,ImEigenValues,REigenVector,InvEigenVector,CEigenVector,CInvEigenVector);#ifdef	CONDENSEMATRICES	#ifdef PRESUMMINGCONSTS			int n=nstates-1;			while(REigenValues[n]==0.0 && n>=0)				n--;			numberOfLastnonZero=n+1;			if(numberOfLastnonZero<nstates-1)//DAnger do this better				CalculateEigInvEigMultAndPreSum(*REigenVector,InvEigenVector,nstates,EigInvEigMat,preSummed,numberOfLastnonZero);			else	#endif							CalculateAndCondenseEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);#else	#ifdef PRESUMMINGCONSTS			int n=nstates-1;			while(REigenValues[n]==0.0 && n>=0)				n--;			numberOfLastnonZero=n+1;			if(numberOfLastnonZero<nstates-1)//DAnger do this better				{CalculateReorderedEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);				DoPreSummation(EigInvEigMat,*preSummed,numberOfLastnonZero,nstates);				}			else	#endif							CalculateGlobalEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);#endif		eigencalc=true;		}	if(!IsComplex)#ifdef PRESUMMINGCONSTS			if(numberOfLastnonZero<nstates-1)				ChangeMatrix(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp,numberOfLastnonZero,preSummed);			else #endif								ChangeMatrix(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp);			//ChangeMatrix(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp);							else	{if(ComplexChangeMatrix(nstates,pmats,blen,REigenValues,ImEigenValues,CEigenVector,CInvEigenVector))				throw LinAlgProb("Error in ComplexChangeMatrix");			}}void ModelWEig::UpdatePMatrix(double **pmats,double blen,int onlycolumn)	//this is a faster version of UpdatePMatrix that you can use if only one column of the PMatrix is needed{	assert(REigenValues && ImEigenValues && REigenVector && InvEigenVector && CEigenVector && CInvEigenVector);	if(!eigencalc)		{CalculateQ();		IsComplex=GetEigens(nstates,qMatrix,REigenValues,ImEigenValues,REigenVector,InvEigenVector,CEigenVector,CInvEigenVector);#ifdef	CONDENSEMATRICES	#ifdef PRESUMMINGCONSTS			int n=nstates-1;			while(REigenValues[n]==0.0 && n>=0)				n--;			numberOfLastnonZero=n+1;			if(numberOfLastnonZero<nstates-1)//DAnger do this better				CalculateEigInvEigMultAndPreSum(*REigenVector,InvEigenVector,nstates,EigInvEigMat,preSummed,numberOfLastnonZero);			else	#endif							CalculateAndCondenseEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);#else	#ifdef PRESUMMINGCONSTS			int n=nstates-1;			while(REigenValues[n]==0.0 && n>=0)				n--;			numberOfLastnonZero=n+1;			if(numberOfLastnonZero<nstates-1)//DAnger do this better				{CalculateReorderedEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);				DoPreSummation(EigInvEigMat,*preSummed,numberOfLastnonZero,nstates);				}			else	#endif							CalculateGlobalEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);#endif		eigencalc=true;		}	if(!IsComplex)#ifdef CONDENSEMATRICES	#ifdef PRESUMMINGCONSTS				if(numberOfLastnonZero<nstates-1)					if(onlycolumn)						ChangeVector(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp,numberOfLastnonZero,preSummed,onlycolumn);					else	//can't get a speed up if the matrix is condensed and the only column is 0 because this the column obtained by subtraction						ChangeMatrix(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp,numberOfLastnonZero,preSummed);				else 	#endif									if(onlycolumn)						ChangeVector(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp,onlycolumn);					else	//can't get a speed up if the matrix is condensed and the only column is 0 because this the column obtained by subtraction						ChangeMatrix(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp);#else	#ifdef PRESUMMINGCONSTS				if(numberOfLastnonZero<nstates-1)					ChangeVector(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp,numberOfLastnonZero,preSummed,onlycolumn);				else 	#endif									ChangeVector(blen,*pmats,nstates,REigenValues,EigInvEigMat,EigExp,onlycolumn);#endif							else	{if(ComplexChangeMatrix(nstates,pmats,blen,REigenValues,ImEigenValues,CEigenVector,CInvEigenVector))				throw LinAlgProb("Error in ComplexChangeMatrix");			}}void ModelWEig::UpdatePmatWithOutSharedMatrix(double **pmats,double blen){	assert(REigenValues && ImEigenValues && REigenVector && InvEigenVector && CEigenVector && CInvEigenVector && EigExp);	if(!eigencalc)		{CalculateQ();		IsComplex=GetEigens(nstates,qMatrix,REigenValues,ImEigenValues,REigenVector,InvEigenVector,CEigenVector,CInvEigenVector);		eigencalc=true;		}	if(!IsComplex)		ChangeMatrixWithOutSharedMatrix(blen,*pmats,nstates,REigenValues,REigenVector,InvEigenVector,EigExp);	else	{if(ComplexChangeMatrix(nstates,pmats,blen,REigenValues,ImEigenValues,CEigenVector,CInvEigenVector))				throw LinAlgProb("Error in ComplexChangeMatrix");			}}void ModelWEig::UpdatePmatWithOutSharedMatrix(double **pmats,double blen,int onlycol){	assert(REigenValues && ImEigenValues && REigenVector && InvEigenVector && CEigenVector && CInvEigenVector && EigExp);	if(!eigencalc)		{CalculateQ();		IsComplex=GetEigens(nstates,qMatrix,REigenValues,ImEigenValues,REigenVector,InvEigenVector,CEigenVector,CInvEigenVector);		eigencalc=true;		}	if(!IsComplex)		ChangeVectorWithOutSharedMatrix(blen,*pmats,nstates,REigenValues,REigenVector,InvEigenVector,EigExp,onlycol);	else	{if(ComplexChangeMatrix(nstates,pmats,blen,REigenValues,ImEigenValues,CEigenVector,CInvEigenVector))				throw LinAlgProb("Error in ComplexChangeMatrix");			}}/*void ModelWEig::UpdatePmatGamma(double blen)	{	assert(REigenValues && ImEigenValues && REigenVector && InvEigenVector && CEigenVector && CInvEigenVector);if(!eigencalc)	{CalculateQ();	IsComplex=GetEigens(nstates,qMatrix,REigenValues,ImEigenValues,REigenVector,InvEigenVector,CEigenVector,CInvEigenVector);	if(!IsComplex)		CalculateGlobalEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);	eigencalc=true;	}for(int i=0;i<ngamcat;i++)	if(!IsComplex)			{			if(ChangeMatrix(blen**(rates+i),pmats[i][0],nstates,REigenValues,EigInvEigMat,EigExp))				throw LinAlgProb("Error in ChangeMatrix");			}	else				{if(ComplexChangeMatrix(nstates,*(pmats+i),blen**(rates+i),REigenValues,ImEigenValues,CEigenVector,CInvEigenVector))				throw LinAlgProb("Error in ComplexChangeMatrix");			}}*/