#include "basicfuncs.h"using namespace std;#ifndef BASIC_FUNCS#include "basicfuncs.h"#endifint itmax = 100;double epsilon = 3.0e-7;double gammln( double xx ){	double x,tmp,ser;	static double cof[6]={76.18009173,-86.50532033,24.01409822,		-1.231739516,0.120858003e-2,-0.536382e-5};	int j;	x=xx-1.0;	tmp=x+5.5;	tmp -= (x+0.5)*log(tmp);	ser=1.0;	for (j=0;j<=5;j++) {		x += 1.0;		ser += cof[j]/x;	}	return -tmp+log(2.50662827465*ser);}//// from the Numerical Recipes (Press et al.) function of the same name//void gcf( double& gammcf, double a, double x, double& gln ){	int n;	double gold=0.0,g,fac=1.0,b1=1.0;	double b0=0.0,anf,ana,an,a1,a0=1.0;	gln=gammln(a);	a1=x;	for (n=1;n<=itmax;n++) {		an=(double) n;		ana=an-a;		a0=(a1+a0*ana)*fac;		b0=(b1+b0*ana)*fac;		anf=an*fac;		a1=x*a0+anf*a1;		b1=x*b0+anf*b1;		if (a1) {			fac=1.0/a1;			g=b1*fac;			if (fabs((g-gold)/g) < epsilon) {				gammcf = exp( -x + a * log(x) - gln ) * g;				return;			}			gold=g;		}	}	throw MTHException("Error in routine GCF: a too large, itmax too small");}//// from the Numerical Recipes (Press et al.) function of the same name//void gser( double& gamser, double a, double x, double& gln ){	int n;	double sum,del,ap;	gln=gammln(a);	if (x <= 0.0) {		if (x < 0.0) {			cerr << endl << "Error in routine GSER: x less than 0" << endl;			cerr << "Program aborted." << endl;			exit(1);      }		gamser=0.0;		return;	} else {		ap=a;		del=sum=1.0/a;		for (n=1;n<=itmax;n++) {			ap += 1.0;			del *= x/ap;			sum += del;			if (fabs(del) < fabs(sum)*epsilon) {				gamser = sum * exp( -x + a * log(x) - gln );				return;			}		}		cerr << endl << "Error in routine GSER:  a too large, itmax too small" << endl;		cerr << "Program aborted." << endl;		exit(1);	}}//// from the Numerical Recipes (Press et al.) function of the same name//double gammq( double a, double x ){	double gamser, gammcf, gln;	if (x < 0.0 || a <= 0.0) {		cerr << endl << "Error in routine GAMMQ:  Invalid arguments" << endl;		cerr << "Program aborted." << endl;		exit(1);	}	if (x < (a+1.0)) {		gser(gamser, a, x, gln);		return 1.0 - gamser;	} else {		gcf(gammcf, a, x, gln);		return gammcf;	}}////  Returns z so that Prob{x<z} = pr where x ~ N(0,1) and//  (1e-12) < pr < 1-(1e-12).  Returns (-9999) if in error.////  Odeh, R. E. and J. O. Evans.  1974.  The percentage points of the normal//	  distribution.  Applied Statistics, 22:96-97 (AS70)////  Newer methods:////  Wichura, M. J.  1988.  Algorithm AS 241: The percentage points of the//	  normal distribution.  37:477-484.//  Beasley, JD & S. G. Springer.  1977.  Algorithm AS 111: The percentage//	  points of the normal distribution.  26:118-121.////  From Ziheng Yang via John Huelsenbeck via Dave Swofford//double point_normal( double pr ){	double 		a0 = -0.322232431088, a1 = -1.0, a2 = -0.342242088547, a3 = -0.0204231210245,			a4 = -0.453642210148e-4, b0 = 0.0993484626060, b1 = 0.588581570495,			b2 = 0.531103462366, b3 = 0.103537752850, b4 = 0.0038560700634,			y, z, p = pr, p1;	p1 = (p<0.5 ? p : 1-p);	if (p1<1e-20)		return (-9999);	y = sqrt (log(1/(p1*p1)));	z = y + ((((y*a4+a3)*y+a2)*y+a1)*y+a0) / ((((y*b4+b3)*y+b2)*y+b1)*y+b0);	return (p<0.5 ? -z : z);}////  Returns z so that Prob{x<z} = pr where x is Chi2 distributed with df=v.//  Returns -1 if in error.   0.000002 < pr < 0.999998.////  RATNEST FORTRAN by//  Best, D. J. and D. E. Roberts.  1975.  The percentage points of the//	  Chi2 distribution.  Applied Statistics 24:385-388.  (AS91)////  Converted into C by Ziheng Yang, Oct. 1993.////  From Ziheng Yang via John Huelsenbeck via Dave Swofford via Paul Lewis//double point_chi2 ( double pr, double v ){	double e = 0.5e-6, aa = 0.6931471805, p = pr, g,		xx, c, ch, a, q, p1, p2, t,		x, b, s1, s2, s3, s4, s5, s6;	if (p < 0.000002 || p > 0.999998 || v <= 0.0)		return (-1.0);	g = gammln( v / 2.0 );	xx=v/2.0;	c=xx-1.0;	if (v >= -1.24*log(p))		goto L1;	ch = pow((p*xx*exp(g+xx*aa)), 1.0/xx);	if (ch-e<0)		return (ch);	goto L4;	L1:		if (v > 0.32)			goto L3;		ch = 0.4;		a = log(1.0-p);	L2:		q = ch;		p1 = 1.0+ch*(4.67+ch);		p2 = ch*(6.73+ch*(6.66+ch));		t = -0.5+(4.67+2.0*ch)/p1 - (6.73+ch*(13.32+3.0*ch))/p2;		ch -= (1.0-exp(a+g+0.5*ch+c*aa)*p2/p1)/t;		if (fabs(q/ch-1.0)-0.01 <= 0.0)			goto L4;		else			goto L2;	L3:		x = point_normal (p);		p1 = 0.222222/v;		ch = v*pow((x*sqrt(p1)+1.0-p1), 3.0);		if (ch > 2.2*v+6.0)			ch = -2.0*(log(1.0-p)-c*log(0.5*ch)+g);	L4:		q = ch;		p1 = 0.5*ch;		t = 1.0 - gammq( xx, p1 );		if (t < 0.0) 		/* TO DO: pass in lnGamma since we've already calculated it */			{			cerr << endl << "Error in routine point_chi2: incomplete_gamma" << endl;			cerr << "Program aborted." << endl;			exit(1);			}		p2 = p-t;		t = p2*exp(xx*aa+g+p1-c*log(ch));		b = t/ch;		a = 0.5*t-b*c;		s1 = (210.0+a*(140.0+a*(105.0+a*(84.0+a*(70.0+60.0*a))))) / 420.0;		s2 = (420.0+a*(735.0+a*(966.0+a*(1141.0+1278.0*a))))/2520.0;		s3 = (210.0+a*(462.0+a*(707.0+932.0*a)))/2520.0;		s4 = (252.0+a*(672.0+1182.0*a)+c*(294.0+a*(889.0+1740.0*a)))/5040.0;		s5 = (84.0+264.0*a+c*(175.0+606.0*a))/2520.0;		s6 = (120.0+c*(346.0+127.0*c))/5040.0;		ch += t*(1+0.5*t*s1-b*c*(s1-b*(s2-b*(s3-b*(s4-b*(s5-b*s6))))));		if (fabs(q/ch-1.0) > e)			goto L4;		return (ch);}//// Calculate the mean or median rates for each subdivision of a discrete// approximation to the gamma distribution.//// rateVect[i] will hold the mean (or median) rate for category i//// categFreq[i] will hold the probability of rateVect[i]// (since each category cuts off the same amount of the distribution,// each element of this array holds the same value, 1/nRateCategs)//// cumRateProb[i] simply holds Sum( categFreq[j] ), j = 0..i//void PrintPMat(double *pmat){	cout << "\n           A           C             G               T"<<endl;	cout << "\nA   "<<flush;	cout << *pmat<<flush;	cout <<"   "<< *(pmat+1)<<flush;	cout <<"   "<< *(pmat+2)<<flush;	cout <<"   "<<*(pmat+3)<<endl;	cout << "\nC   "<< *(pmat+4)<<"   "<< *(pmat+5)<<"   "<< *(pmat+6)<<"   "<< *(pmat+7)<<endl;	cout << "\nG   "<< *(pmat+8)<<"   "<< *(pmat+9)<<"   "<< *(pmat+10)<<"   "<< *(pmat+11)<<endl;	cout << "\nT   "<< *(pmat+12)<<"   "<< *(pmat+13)<<"   "<< *(pmat+14)<<"   "<< *(pmat+15)<<endl;	}int ProductOfSquareMatrices(double *prod,int dimen, double *fir, double *sec){	int i,pi,pj,fcop=0,scop=0;		double *first,*second;	if(prod==fir)		{		first=new double[(dimen*dimen)];		for(i=0;i<(dimen*dimen);i++)			*(first+i)=*(fir+i);		fcop=1;		}	else	first=fir;	if(prod==sec)		{		second=new double[(dimen*dimen)];		for(i=0;i<(dimen*dimen);i++)			*(second+i)=*(sec+i);		scop=1;		}	else	second=sec;	if(dimen<1)		return 0;	for(i=0;i<(dimen*dimen);i++)		*(prod+i)=0.0;	for(pi=0;pi<dimen;pi++)		for(pj=0;pj<dimen;pj++)			for(i=0;i<dimen;i++)				*(prod+dimen*pi+pj)=*(prod+dimen*pi+pj)+(*(first+pi*dimen+i)*(*(second+pj+dimen*i)));	if(fcop)		delete []first;	if(scop)		delete []second;	return 1;}long NumberOfLongsLeftInMemory(){	long int num=0, *allocarr[500], step;	int i,ex;	for(i=0;i<500;i++)		allocarr[i]=NULL;	step=1000000000;	i=0;	while(step>=1)		{ex=0;		try		{allocarr[i]=new long int[step];}		catch (class bad_alloc)			{//cout<<"An bad alloc exception was thrown"<<endl;			ex=1;			step=step/10;			}		if(ex==0)			{			i++;			num=num+step;			if(i>=499)				{				step=0;				num=num+NumberOfLongsLeftInMemory();				}			}		}	while(i>=0)		{		if(allocarr[i])			delete [] allocarr[i];		i--;		}	return num;}long NumberOfCharsLeftInMemory(){	long int num=0, step;	char *allocarr[500];	int i,ex;	for(i=0;i<500;i++)		allocarr[i]=NULL;	step=1000000000;	i=0;	while(step>=1)		{ex=0;		try		{allocarr[i]=new char[step];}		catch (class bad_alloc)			{//cout<<"An bad alloc exception was thrown"<<endl;			ex=1;			step=step/10;			}		if(ex==0)			{			i++;			num=num+step;			if(i>=499)				{				step=0;				num=num+NumberOfCharsLeftInMemory();				}			}		}	while(i>=0)		{		if(allocarr[i])			delete [] allocarr[i];		i--;		}	return num;}long NumberOfBoolsLeftInMemory(){	long int num=0, step;	bool *allocarr[500];	int i,ex;	for(i=0;i<500;i++)		allocarr[i]=NULL;	step=1000000000;	i=0;	while(step>=1)		{ex=0;		try		{allocarr[i]=new bool[step];}		catch (class bad_alloc)			{//cout<<"An bad alloc exception was thrown"<<endl;			ex=1;			step=step/10;			}		if(ex==0)			{			i++;			num=num+step;			if(i>=499)				{				step=0;				num=num+NumberOfBoolsLeftInMemory();				}			}		}	while(i>=0)		{		if(allocarr[i])			delete [] allocarr[i];		i--;		}	return num;}/*-------| rnum |------------------------------------------------|   This pseudorandom number generator is described in:|   Park, S. K. and K. W. Miller.  1988.  Random number generators: good|      ones are hard to find.  Communications of the ACM, 31(10):1192-1201.*/double RandomNumber(long int *seed){	long int	lo, hi, test;		hi = (*seed) / Q_Q;	lo = (*seed) % Q_Q;		test = A_A * lo - R_R * hi;	if (test > 0.0) 		*seed = test;	else	      		*seed = test + M_M;		return (double)(*seed) / (double)M_M;}short DecodeAChar(short n){	if(n>16 || n==0 ) return n;	short x;	switch(n)	{  case 1 : x='A'; break;               case 2 : x='C'; break;               case 3 : x='M'; break;               case 4 : x='G'; break;               case 5 : x='R'; break;               case 6 : x='S'; break;               case 7 : x='V'; break;               case 8 : x='T'; break;               case 9 : x='W'; break;               case 10 : x='Y'; break;               case 11 : x='H'; break;               case 12 : x='K'; break;               case 13 : x='D'; break;               case 14 : x='B'; break;               case 15 : x='N'; break;               default  : x='N'; break;			}        return(x);}int DecodeAmbiguityCode(char *dest,short int c){	int i=1;switch(c)	{  case 'A' : strcpy(dest,"A"); break;               case 'C' : strcpy(dest,"C"); break;               case 'M' : strcpy(dest,"A,C"); break;               case 'G' : strcpy(dest,"G"); break;               case 'R' : strcpy(dest,"A,G"); break;               case 'S' : strcpy(dest,"C,G"); break;               case 'V' : strcpy(dest,"A,C,T"); break;               case 'T' : strcpy(dest,"T"); break;               case 'W' : strcpy(dest,"A,T"); break;               case 'Y' : strcpy(dest,"C,T"); break;               case 'H' : strcpy(dest,"A,C,T"); break;               case 'K' : strcpy(dest,"G,T"); break;               case 'D' : strcpy(dest,"A,G,T"); break;               case 'B' : strcpy(dest,"C,G,T"); break;               case 'N' : strcpy(dest,"A,C,G,T"); break;               case 1 : strcpy(dest,"A"); break;               case 2 : strcpy(dest,"C"); break;               case 3 : strcpy(dest,"A,C"); break;               case 4 : strcpy(dest,"G"); break;               case 5 : strcpy(dest,"A,G"); break;               case 6 : strcpy(dest,"C,G"); break;               case 7 : strcpy(dest,"A,C,T"); break;               case 8 : strcpy(dest,"T"); break;               case 9 : strcpy(dest,"A,T"); break;               case 10 : strcpy(dest,"C,T"); break;               case 11 : strcpy(dest,"A,C,T"); break;               case 12 : strcpy(dest,"G,T"); break;               case 13 : strcpy(dest,"A,G,T"); break;               case 14 : strcpy(dest,"C,G,T"); break;               case 15 : strcpy(dest,"A,C,G,T"); break;               default  : i=0; strcpy(dest,"A,C,G,T"); break;			}	return i;}nxsstring GetNStrToPunc(nxsstring::iterator &c){//Copies the string from source into dest until one of the tree string punctuation marks is //encountered ():;, or white space.  the source string is also advanced to the end of the string	char *dest;	nxsstring sdest;	int i;	i=0;	dest=new char[i+1];	while(*c!='(' && *c!=')' && *c!=':' && *c!=',' && *c!=';' && *c!='\0')		{		if(*c=='_')	*(dest+i)=' ';		else		*(dest+i)=*c;		c++;		i++;		}	*(dest+i)='\0';	sdest=dest;	delete []dest;	return sdest;}void GetStrToPunc(char *source,char *dest){/*Copies the string from source into dest until one of the tree string punctuation marks is encountered ():;, or white space.  the source string is also advanced to the end of the string*/	int i;	i=0;	while(*(source+i)!='(' && *(source+i)!=')' && *(source+i)!=':' && *(source+i)!=',' && *(source+i)!=';' && *(source+i)!='\0')		{		if(islower(*(source+i)))			*(dest+i)=toupper(*(source+i));		else	*(dest+i)=*(source+i);		i++;		}	*(dest+i)='\0';	strcpy(source,source+i);}void GetNStrToPunc(nxsstring::iterator &c,char *dest){//Copies the string from source into dest until one of the tree string punctuation marks is //encountered ():;, or white space.  the source string is also advanced to the end of the string	int i;	i=0;	while(*c!='(' && *c!=')' && *c!=':' && *c!=',' && *c!=';' && *c!='\0')		{*(dest+i)=*c;		c++;		i++;		}	*(dest+i)='\0';}double GetNumberFromStr(char *source){/* This function returns a double that is the number contained in the string source.  The stringneed not be null terminated after the number, but note that the string is advanced*/	int k,j,i=0;	double x=0.0,y=0.0,z;	if(*(source+i)=='-')		{ z=-1.0; i++; }	else z=1.0;	while(isdigit(*(source+i)))		{		x=10.0*x + (double) (*(source+i)-'0');		i++;		}	if(*(source+i)=='.')		{		j=1;		i++;		while(isdigit(*(source+i)))			{			x=x+(((double) *(source+i))/pow(10.0,j));			j++;			i++;			}		}	if(*(source+i)=='e' || *(source+i)=='E')		{		i++;		if(*(source+i)=='-')				{				i++;				k=1;				}		else	k=0;		y=0.0;		while(isdigit(*(source+i)))			{			y=10.0*y+(double) ((*(source+i)-'0'));			i++;			}		if(k==1)			y=y*(-1.0);		x=x*pow(10.0,y);		}	strcpy(source,source+i);	return(x*z);}double GetNumberFromNStr(nxsstring::iterator &c){ // This function returns a double that is the number contained in the string source.  The string//need not be null terminated after the number, but note that the string is advanced	int k,j,i=0;	double x=0.0,y=0.0,z;	if(*c=='-') { z=-1.0; c++; }	else z=1.0;	while(isdigit(*c))		{x=10.0*x + (double) (*c-'0');		c++;		}	if(*c=='.')		{j=1;		c++;		while(isdigit(*c))			{x=x+(((double) (*c-'0'))/pow(10.0,j));			j++;			c++;			}		}	if(*c=='e' || *c=='E')		{		c++;		if(*c=='-')				{c++;				k=1;				}		else	k=0;		y=0.0;		while(isdigit(*c))			{y=10.0*y+(double) ((*c-'0'));			c++;			}		if(k==1)			y=y*(-1.0);		x=x*pow(10.0,y);		}	return(x*z);}double GetNumberFromStr(ifstream &input,char c){/* This function returns a double that is the number contained in input.  The stringneed not be null terminated after the number, but note that the string is advanced*/	int j,i=0;	char d;	d=c;	double x=0.0,y=0.0,z;	if(c=='-')		{z=-1.0; d=nexusget(input);}	else z=1.0;	while(isdigit(d))		{		x=10.0*x + (double) (d-'0');		d=nexusget(input);		}	if(d=='.')		{		j=1;		d=nexusget(input);		while(isdigit(d))			{			x=x+(((double) (d-'0'))/pow(10.0,j));			j++;			d=nexusget(input);			}		}	if(d=='e' || d=='E')		{		d=nexusget(input);		if(d=='-')				{				d=nexusget(input);				i=1;				}		else	i=0;		while(isdigit(d))			{			y=10.0*y+(double) (d-'0');			d=nexusget(input);			}		if(i==1)			y=y*(-1.0);		x=x*pow(10.0,y);		}	input.putback(d);	//cout << "GetNumberFromStr "<<x<<"\n";	return(x*z);}char nexusget(ifstream &inp){	char c;	c='a';while(c!=EOF)	{	c=inp.get();	if(c=='[')		while(c!=']')			c=inp.get();	else return(c);	}	return(EOF);}void GetStrToPunc(class ifstream &input,char *c,char *dest){/*Copies the string from source into dest until one of the tree string punctuation marks is encountered ():;, or white space.  the source string is also advanced to the end of the string*/	int i=0;	while((*c)!='(' && (*c)!=')' && (*c)!=':' && (*c)!=',' && (*c)!=';' && !(isspace((*c))))		{		if(islower(*c))			*(dest+i)=toupper(*c);		else	*(dest+i)=(*c);		i++;		(*c)=nexusget(input);		}	*(dest+i)='\0';	input.putback(*c);}int ClassifyChange(short int brstart, short int brend,short int *plink)//Rogers and Swofford's Fixed and Potentially Same{	if(StateCount(brend)==1 && StateCount(brstart)==1 && brstart==brend)		{		*(plink+4)=1; // SAME NUCLEOTIDE AT THE BEGINNING AND END		return 1;		}	if((*(plink+3)&8)==0 && (*(plink+2)&4)==0 && (*(plink+1)&2)==0 && (*plink&1)==0 )		{		*(plink+4)=3; //DIFFERENT NUCLEOTIDES AT BEGINNING AND END		return 3;		}	*(plink+4)=2; // POTENTIALLY SAME NUCLEOTIDES AT THE BEGINNING AND END	return 2;	}int ClassifyChangeTerm(short int brstart,short int brend,short int *plink)//Rogers and Swofford's Fixed and Potentially Same{	if(brstart==brend)		{		*(plink+4)=1; // SAME NUCLEOTIDE AT THE BEGINNING AND END		return 1;		}	if((*(plink+3)&8)==0 && (*(plink+2)&4)==0 && (*(plink+1)&2)==0 && (*plink&1)==0 )		{		*(plink+4)=3; //DIFFERENT NUCLEOTIDES AT BEGINNING AND END		return 3;		}	*(plink+4)=2; // POTENTIALLY SAME NUCLEOTIDES AT THE BEGINNING AND END	return 2;	}int StateCount( int c){	int i=0;	if(c<1 || c>15) i=0;		//cout<< "<<error"<<endl;	if(c&1)	i++;	if(c&2)	i++;	if(c&4)	i++;	if(c&8)	i++;	return i;}int ConvertCodeToIndex(short int c){ short int i=(c==1 ? 0 : (c==2 ? 1 : (c==4 ? 2 : 3)));return i;}int ConvertPermLinkToChange(short *plink){	int i=0,j=0;	while(*(plink+i)==0)		i++;	if(*(plink+i)==1)		return 4*i;	if(*(plink+i)==2)		return (4*i+1);	if(*(plink+i)==4)		return (4*i+2);	return (4*i+3);}void itos(char *dest,int x){	int k=0;if(x<0)	{	*dest='-';	k=1;	x=x*(-1);	}if(x==0)	strcpy(dest,"0");else	{int tempo,tempt,numplaces,i;	numplaces=1+ (int) floor(log(((double) x )+ 0.0001)/log(10.0));	tempt=x;	for(i=0;i<numplaces;i++)		{		tempo=(int) floor(((double) tempt)/pow(10.0,((double) numplaces-1-i)));		*(dest+i+k)='0'+tempo;		tempt=tempt-(tempo*((int) pow(10.0,((double) numplaces-1-i))));		}	*(dest+i+k)='\0';	}}void ltos(char *dest,long x){	int k=0;if(x<0)	{	*dest='-';	k=1;	x=x*(-1);	}if(x==0)	strcpy(dest,"0");else	{int tempo,tempt,numplaces,i;	numplaces=1+ (int) floor(log(((double) x )+ 0.0001)/log(10.0));	tempt=x;	for(i=0;i<numplaces;i++)		{		tempo=(int) floor(((double) tempt)/pow(10.0,((double) numplaces-1-i)));		*(dest+i+k)='0'+tempo;		tempt=tempt-(tempo*((int) pow(10.0,((double) numplaces-1-i))));		}	*(dest+i+k)='\0';	}}void dtos(char *dest,double x)//crappy converter of double to a string for the double//6 digits of precision only if .006000 stored as 0.00600, but .0060001 is stored as 6.0001e-3{	int first=1,numplaces,place=0,i;	double y;	if(x<0)	{			*dest='-'; 			place++;			x=-1.0*x;			}	if(x>=1.0)		{		numplaces=1+ (int) floor(log((double) x)/log(10.0));		y=x*pow(10,((double) 6-numplaces));		y=floor(y);		x=x-y;		if(x>=.5)			y=y+1.0;		x=y*pow(10,((double) numplaces-6));		if(numplaces>4)			{//scientific notation big number			y=floor((x/(pow(10,(double) (numplaces-1))))+0.000001);			*(dest+place)='0'+((int) y);			place++;			*(dest+place)='.';			place++;			for(i=0;i<5;i++)				{x=x-(y*pow(10,(double) (numplaces-1-i)));				if(x<0.0)	x=0.0;				y=floor((x/(pow(10,(double) (numplaces-2-i))))+0.000001);				*(dest+place)='0'+((int) y);				place++;				}			*(dest+place)='e';			itos((dest+place+1),(numplaces-1));			}		else			{//no scientific			for(i=0;i<6;i++)				{				if(i==numplaces)					{					*(dest+place)='.';					place++;					}				y=floor((x/(pow(10,(double) (numplaces-i-1))))+0.000001);				*(dest+place)='0'+((int) y);				x=x-(y*pow(10,(double) (numplaces-1-i)));				if(x<0.0)	x=0.0;				place++;				}			*(dest+place)='\0';			}		}	else			{//Numbers less than one		if(x==0.0)			strcpy(dest,"0.0");		else			{numplaces=(int) floor(log((double) x)/log(10.0));			if(numplaces<-3)				{//Sci notation for small number				y=floor((x/(pow(10,(double) (numplaces))))+0.000001);				*(dest+place)='0'+((int) y);				place++;				*(dest+place)='.';				place++;				for(i=0;i<5;i++)					{x=x-(y*pow(10,(double) (numplaces-i)));					if(x<0.0)	x=0.0;					y=floor((x/(pow(10,(double) (numplaces-1-i))))+0.000001);					*(dest+place)='0'+((int) y);					place++;					}				*(dest+place)='e';				place++;				*(dest+place)='-';				itos((dest+place+1),(-1*numplaces));				}			else				{//No Scientific Notation				*(dest+place)='0';				place++;				*(dest+place)='.';				place++;				for(i=0;i>(numplaces+1);i--)					{*(dest+place)='0';					place++;					}				for(i=0;i<6;i++)					{y=floor((x/(pow(10,(double) (numplaces-i))))+0.000001);					*(dest+place)='0'+((int) y);					x=x-(y*pow(10,(double) (numplaces-i)));					if(x<0.0)	x=0.0;					place++;					}				*(dest+place)='\0';				}			}		}		}int UtoCstrcpy(char *ctemp,unsigned char *temp){	int i=0;	while(*(temp+i))		{		if(*(temp+i)>127)			return 0;		*(ctemp+i)=*(temp+i);		i++;		}	*(ctemp+i)='\0';	return 1;}int CtoUstrcpy(unsigned char *ctemp, char *temp){	int i=0;	while(*(temp+i))		{		if(*(temp+i)<0)			return 0;		*(ctemp+i)=*(temp+i);		i++;		}	*(ctemp+i)='\0';	return 1;}int CtoUPascalstrcpy(unsigned char *ctemp, char *temp){	int i=1,len;	len=*temp;	if(len<255)		*ctemp=len;	for(i=1;i<(len+1);i++)		{		if(*(temp+i)<0)			return 0;		*(ctemp+i)=*(temp+i);		i++;		}	return 1;}bool StrForDoubleInRange(char *str,double minim,double maxim){	//only works for minim>0 doesn't check for sci notation	double x;	if(isdigit(*str) || *str=='-' || *str=='.')		{		if(*str=='-' && minim>=0.0) return false;		if(*str=='.' && minim>=1.0) return false;		if(CouldTurnIntoADouble(str))			if(HasADigit(str))				{x=GetPartNumberFromStr(str);				if(minim>1.0)					if(x<=1.0)	return false;				if(x<=maxim)	return true;				}			else	return true;		}		return false;}bool StrForDoubleInRangeNoSci(char *str,double minim,double maxim){	//only works for minim>0 doesn't check for sci notation	double x;	if(isdigit(*str) || *str=='-' || *str=='.')		{		if(*str=='-' && minim>=0.0) return false;		if(*str=='.' && minim>=1.0) return false;		if(CouldTurnIntoADoubleNoSci(str))			if(HasADigit(str))				{x=GetPartNumberFromStr(str);				if(minim>1.0)					if(x<=1.0)	return false;				if(x<=maxim)	return true;				}			else	return true;		}		return false;}double GetPartNumberFromStr(char *source){/* This function returns a double that is the number contained in the string source.  The stringneed not be null terminated after the number, but note that the string is advanced*/	int j,i=0;	double x=0.0,y=0.0,z;	if(*(source+i)=='-')		{ z=-1.0; i++; }	else z=1.0;	while(isdigit(*(source+i)))		{		x=10.0*x + (double) (*(source+i)-'0');		i++;		}	if(*(source+i)=='.')		{		j=1;		i++;		while(isdigit(*(source+i)))			{			x=x+(((double) (*(source+i)-'0'))/pow(10.0,j));			j++;			i++;			}		}	return(x*z);}bool CouldTurnIntoADouble(char *str){	int i=0,deccount=0,ecount=0,haddigit=0;	if(*str=='-')		i++;	while(*(str+i))		{		if(*(str+i)=='.')			if(ecount!=0)	return false;			else			deccount++;		else	{				if((*(str+i)=='e' || *(str+i)=='E') && haddigit )					ecount++;				else	if(*(str+i)=='-')							{							if(*(str+i-1)!='e' && *(str+i-1)!='E')	return false;							}						else	if(isdigit(*(str+i)))									haddigit=1;								else return false;												}		i++;		if(deccount>1 || ecount>1)	return false;		}	return true;}bool CouldTurnIntoADoubleNoSci(char *str){	int i=0,deccount=0,haddigit=0;	if(*str=='-')		i++;	while(*(str+i))		{		if(*(str+i)=='.')			deccount++;		else	if(!(isdigit(*(str+i))))	return false;										i++;		if(deccount>1)	return false;		}	return true;}bool HasADigit(char *str){	int i=0;	while(*(str+i))		{if(isdigit(*(str+i)))			return true;		i++;		}	return false;}char *AllocateCharAndCopyNStr(nxsstring instr,int len){	char *temp;int i;	temp=new char[len+1];	nxsstring::iterator c=instr.begin();	for(i=0;i<len;i++)		{*(temp+i)=*c;		c++;		}	*(temp+i)='\0';	return temp;}void SortDoubleArray(double *x,int len){	list<double> temp;	int i;	for(i=0;i<len;i++)		temp.push_back(*(x+i));	temp.sort();	list<double>::iterator p = temp.begin();	for(i=0;i<len;i++)		{*(x+i)=*p;		p++;		}}nxsstring GetNextGraphStr(nxsstring::iterator &nextlet,nxsstring::iterator endp){	nxsstring temp;	while(!isgraph(*nextlet) && nextlet!=endp)		nextlet++;	while(isgraph(*nextlet) && nextlet!=endp)		{temp+=*nextlet;		nextlet++;		}	return temp;}int EncodeTripletToCodon(int *str){	//expects three shorts in my dna code	//returns codon 1 to 64 alphabetically, ambig is not tolerated     short aa=1;    if(*str!=1 &&  *str!=2 && *str!=4 && *str!=8)	return 0;    if(*str == 2) aa+=16;	if(*str == 4) aa+=32;	if(*str == 8) aa+=48;	if(*(str+1)!=1 &&  *(str+1)!=2 && *(str+1)!=4 && *(str+1)!=8)	return 0;    if(*(str+1) == 2) aa+=4;	if(*(str+1) == 4) aa+=8;	if(*(str+1) == 8) aa+=12;	if(*(str+2)!=1 &&  *(str+2)!=2 && *(str+2)!=4 && *(str+2)!=8)	return 0;    if(*(str+2) == 2) aa+=1;	if(*(str+2) == 4) aa+=2;	if(*(str+2) == 8) aa+=3;	return aa;}nxsstring MitoTranslateThreeNucleotides(short *ibases){	nxsstring temp;	short f,s,t;	f=*ibases;	s=*(ibases+1);	t=*(ibases+2);	if(f==16 && s==16 && t==16 ) 		{temp='-';		return temp;		}	if(f==16)	f=15;	if(s==16)	s=15;	if(t==16)	t=15;	if(f==15 && s==15 && t==15 ) 		{temp='X';		return temp;		}	if(s&8 && ( f&2 || (f&8 && t&5)))		temp+='L';	if((f&8 && s&2) || ( f&1 && s&4 && t&10))		temp+='S';	if((f&8 && s&1 && t&5) || (f&1 && s&4 && t&5))		temp+='*';	if(f&1)	//ANN		{if(s&1)//AAN			{if(t&5)	temp+='K';			if(t&10)	temp+='N';			}		if(s&2)//ACN			temp+='T';		if(s&8)//AUN			{if(t&5)	temp+='M';			if(t&10)	temp+='I';			}		}	if(f&2)	//CNN		{if(s&1)//CAN			{if(t&5)	temp+='Q';			if(t&10)	temp+='H';			}		if(s&2)//CCN			temp+='P';		if(s&4)//CGN			temp+='R';		}	if(f&4)	//GNN		{if(s&1)//GAN			{if(t&5)	temp+='E';			if(t&10)	temp+='D';			}		if(s&2)//GCN			temp+='A';		if(s&4)//GGN			temp+='G';		if(s&8)//GUN			temp+='V';		}	if(f&8)	//UNN		{if(s&1)//UAN			if(t&10)	temp+='Y';		if(s&4)//UGN			{if(t&5)	temp+='W';			if(t&10)	temp+='C';			}		if(s&8)//UUN			if(t&10)	temp+='F';		}	assert(temp.length()>0);	return temp;}nxsstring MitoTranslateThreeMinusSecondArgNucleotides(short *bases,int basesIncluded){	short dummy[3];	for(int i=0;i<3;i++)		if(i<basesIncluded)			dummy[i]=*(bases+i);		else	dummy[i]=15;	return MitoTranslateThreeNucleotides(dummy);}nxsstring NucTranslateThreeNucleotides(short *ibases){	nxsstring temp;	short f,s,t;	f=*ibases;	s=*(ibases+1);	t=*(ibases+2);	if(f==16 && s==16 && t==16 ) 		{temp='-';		return temp;		}	if(f==16)	f=15;	if(s==16)	s=15;	if(t==16)	t=15;	if(f==15 && s==15 && t==15 ) 		{temp='X';		return temp;		}	if(s&8 && ( f&2 || (f&8 && t&5)))		temp+='L';	if((f&8 && s&2) || ( f&1 && s&4 && t&10))		temp+='S';	if((f&2 && s&4) || ( f&1 && s&4 && t&5))		temp+='R';	if((f&8 && s&1 && t&5) || (f&1 && s&4 && t&1))		temp+='*';	if(f&1)	//ANN		{if(s&1)//AAN			{if(t&5)	temp+='K';			if(t&10)	temp+='N';			}		if(s&2)//ACN			temp+='T';		if(s&8)//AUN			{if(t&4)	temp+='M';			if(t&11)	temp+='I';			}		}	if(f&2)	//CNN		{if(s&1)//CAN			{if(t&5)	temp+='Q';			if(t&10)	temp+='H';			}		if(s&2)//CCN			temp+='P';		}	if(f&4)	//GNN		{if(s&1)//GAN			{if(t&5)	temp+='E';			if(t&10)	temp+='D';			}		if(s&2)//GCN			temp+='A';		if(s&4)//GGN			temp+='G';		if(s&8)//GUN			temp+='V';		}	if(f&8)	//UNN		{if(s&1)//UAN			if(t&10)	temp+='Y';		if(s&4)//UGN			{if(t&4)	temp+='W';			if(t&10)	temp+='C';			}		if(s&8)//UUN			if(t&10)	temp+='F';		}	assert(temp.length()>0);	return temp;}nxsstring NucTranslateThreeMinusSecondArgNucleotides(short *bases,int basesIncluded){	short dummy[3];	for(int i=0;i<3;i++)		if(i<basesIncluded)			dummy[i]=*(bases+i);		else	dummy[i]=15;	return MitoTranslateThreeNucleotides(dummy);}short TranslateNumCodonMito(short str){	//expects numbering in alpha betical order	static short NumMitoCode[]={9,12,9,12,17,17,17,17,21,16,21,16,11,8,11,8,14,7,14,7,13,13,13,13,15,15,15,15,	10,10,10,10,4,3,4,3,1,1,1,1,6,6,6,6,18,18,18,18,21,20,21,20,16,16,16,16,19,2,19,2,10,5,10,5};	if(str<1 || str>64)	return 0;	return NumMitoCode[(str-1)];}short ConverNumAAToLetAA(short str){	//expects numbering in alpha betical order	static short SingleLetterAA[]={'A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S',	'T','V','W','Y','*'};	if(str<1 || str>21)	return 0;	return SingleLetterAA[(str-1)];}bool FillArrayOfAllCodonsMt(short *codonarray, short currcodon){	static short MasterListOfCodonArrays[21][7]={	{4,37,38,39,40,0,0},//1 Ala	{2,58,60,0,0,0,0},//2 Cys	{2,34,36,0,0,0,0},//3 Asp	{2,33,35,0,0,0,0},//4 Glu	{2,62,64,0,0,0,0},//5 Phe	{4,41,42,43,44,0,0},//6 Gly	{2,18,20,0,0,0,0},//7 His	{2,14,16,0,0,0,0},//8 Ile	{2,1,3,0,0,0,0},//9 Lys	{6,29,30,31,32,61,63},//10 Leu	{2,13,15,0,0,0,0},//11 Met	{2,2,4,0,0,0,0},//12 Asn	{4,21,22,23,24,0,0},//13 Pro	{2,17,19,0,0,0,0},//14 Gln	{4,25,26,27,28,0,0},//15 Arg	{6,10,12,53,54,55,56},//16 Ser	{4,5,6,7,8,0,0},//17 Thr	{4,45,46,47,48,0,0},//18 Val	{2,57,59,0,0,0,0},//19 Trp	{2,50,52,0,0,0,0},//20 Tyr	{4,9,11,49,51,0,0}};//21 Stop	int i,aanum;	aanum=TranslateNumCodonMito(currcodon);	if(!aanum)	return false;	for(i=0;i<7;i++)		*(codonarray+i)=MasterListOfCodonArrays[aanum-1][i];	return true;}void RevTransNCodToNNuc(short codnum,short *dnaseq){	codnum--;	*dnaseq=*(dnaseq+1)=*(dnaseq+2)=1;	while(codnum>=16)		{*(dnaseq)=*(dnaseq)*2;		codnum=codnum%16;		}	while(codnum>=4)		{*(dnaseq+1)=*(dnaseq+1)*2;		codnum=codnum%4;		}	while(codnum>0)		{*(dnaseq+2)=*(dnaseq+2)*2;		codnum--;		}}void GaussJordanElimination(double **mat,double *vars,int dim){	/*This function takes a matrix of dim rows and dim+1 columns.  <---NOTE size!!!	the first dim elements in each row is the coefficient for the corresponding var	the element in the last column in each row is the result of the linear combinations of	var*coeff.  this function fills vars with the values that solve the linear equations		!!! THE Elements in Mat are changed !!!, so copy the matrix first if you need the values		this naive method comes from Philip Davis' the Mathematics of Matrices (1965)	*/	int row;	for(int col=0;col<dim;col++)		{		double maxc=0.0;		int pivot=0;//Find Pivot for this column		for(row=col;row<dim;row++)			if(fabs(mat[row][col])>maxc)				{pivot=row;				maxc=fabs(mat[row][col]);				}		double *swapptr;//reorder the rows so the pivot is at the top		swapptr=mat[col];		mat[col]=mat[pivot];		mat[pivot]=swapptr;		double pivval=mat[pivot][col];		if(pivval==0.0)			{if(fabs(mat[pivot][dim])>SMALLDOUBLE)	throw VariableNotDetermined();			throw	MTHException("Entered unwritten code GaussJordanElimination" );//SOMETHING NEEDED HERE			}		else			{bool done=true;			for(int i=0;i<dim+1;i++)//divide pivot row to make the pivot entry 1				mat[pivot][i]/=pivval;			for(int i=0;i<dim;i++)//subtract out this var from all other equations in the matrix;				if(i!=pivot)					{double multip=mat[i][col]/(mat[pivot][col]);					for(int j=0;j<dim+1;j++)//divide pivot row to make the pivot entry 1						{if(j==col)	mat[i][j]=0.0;						else	mat[i][j]-=multip*mat[pivot][j];						if(i>col && dim==j && fabs(mat[i][j])>SMALLDOUBLE)							done=false;						}					}			if(done)				{for(int i=0;i<dim;i++)					if(i<=col)	vars[i]=mat[i][dim];					else vars[i]=0.0;				return;				}			}		}	for(int i=0;i<dim;i++)		vars[i]=mat[i][dim];}bool PointsAreFarEnoughApart(double a,double b){	double tolOne;	if(fabs(a)>fabs(b))		{tolOne=fabs(b)*FTOL+ZEPS;		if(fabs(a-b)<tolOne)			return false;		return true;		}	tolOne=fabs(a)*FTOL+ZEPS;	if(fabs(a-b)<tolOne)		return false;	return true;}