#include "AdvancedBullDefs.h"#include "bull.h"#include <sioux.h>#include <profiler.h>#include "setreader.h"using namespace std; //introduces namespace std/** * @class      BULLCMDLINE * @file       BULLCMDLINE.h * @file       BULLCMDLINE.cpp * @author     Paul O. Lewis * @copyright  Copyright © 1999. All Rights Reserved. * @variable   command_maxlen [static int] maximum length of a command entered interactively by user * @variable   inf_open [bool] true iff inf is currently open * @variable   message [nxsstring] workspace for composing output strings * @variable   next_command [char*] workspace for processing next command entered interactively by user * @variable   logf [ofstream] the log file stream * @variable   logf_open [bool] true iff logf is currently open * @variable   quit_now [bool] set to false at beginning of Run and turns true only when QUIT command processed * @see        Nexus * @see        NexusBlock * @see        NexusReader * @see        NexusToken * @see        XNexus * * <pre> * +---- Remove these comments for an actual implementation --------------------------+ * |                                                                                  | * | BULLCMDLINE provides a template for creating a program that reads NEXUS data    | * | files and provides a basic command line.  After compiling BULLCMDLINE, you will | * | already have a program that understands the following commands, either typed in  | * | at the console or provided in a BULLCMDLINE block in a NEXUS data file          | * | (exception is the execute command, which can only be entered at the console).    | * | Keywords in the descriptions below are given in uppercase, however the           | * | commands themselves are case-insensitive.  Lower-case indicates a parameter      | * | supplied by the user (e.g., "filename" would be replaced by the actual           | * | name of the file). Square brackets indicate optional keywords or subcommands.    | * |                                                                                  | * | EXECUTE filename;                                                                | * |                                                                                  | * | LOG [options];                                                                   | * |                                                                                  | * |   Option         Action                                                          | * |   ------------------------------------------------------                         | * |   FILE=filename  specifies name of log file to start                             | * |   START          indicates logging is to be started                              | * |   STOP           indicates logging is to be stopped                              | * |   APPEND         append to log file if it already exists                         | * |   REPLACE        replace log file without asking                                 | * |                                                                                  | * | QUIT;                                                                            | * |                                                                                  | * | See the Read function for details and to add other commands.                     | * |                                                                                  | * | To change the name of the program (which is also the prompt name and the         | * | name of the program's private NEXUS block), replace all occurrences of           | * | BULLCMDLINE with the name of your program (also search for the string           | * | "BULLCMDLINE" and replace with an appropriate string at each occurrence).       | * |                                                                                  | * +----------------------------------------------------------------------------------+  * </pre> * * This class handles reading and storage for the Nexus block BULLCMDLINE. * It also serves as the main class for the program BULLCMDLINE, acting  * as a Nexus object (in order to be capable of parsing data files) * as well as a NexusBlock object (in order to be able to process * commands in a BULLCMDLINE block).  * * Acting as a NexusBlock. it overrides the member functions  * Read and Reset, which are abstract virtual functions in  * the base class NexusBlock. * * Acting as a Nexus object, it overrides the member functions * EnteringBlock, SkippingBlock, and NexusError. *//** * @constructor * * Initializes the id data member to "Bull" and calls the FactoryDefaults * member function to perform the remaining initializations. */Bull::Bull(){	id = "BULL";	FactoryDefaults();#ifdef	DEBUGGING	firstTimeThrough=true;#endif}/** * @destructor * * Closes logf if it is open. */Bull::~Bull(){	delete LSettings;	delete DSettings;	delete PSettings;	delete paramAlterInfo;	delete []previousLikelihoods;		if( logf_open )		logf.close();}void Bull::CreateDataMap(){		assert(charordata->GetDataType()==CharactersBlock::dna || charordata->GetDataType()==CharactersBlock::protein);	nxsstring curtax;	//assuming DNA e!	short int *curchar,*tempchar,*unionchar;	datatype=charordata->GetDataType();	if(datatype==CharactersBlock::dna || datatype==CharactersBlock::rna || datatype==CharactersBlock::nucleotide)		datatype=EncodingType(DNANoGap);	else if(datatype==CharactersBlock::protein)			datatype=EncodingType(AminoAcid);	else	{cout<<"Terminal error data set must be amino acid or nucleotide sequences"<<endl;//Change to deal with this error correctly			throw	MTHException("Entered unwritten code CreateDataMap" );			}	int nShortsPerChar=NumShortsPerCharacter(datatype);		EncodedChars *curEC;	tempchar=new short[nShortsPerChar];	unionchar=new short[nShortsPerChar];	for(int i=0;i<ntaxa;i++)		{curtax=taxa->GetTaxonLabel(i);		curchar=new short[nShortsPerChar*nchars];//times 2 because you need 2 shorts to hold 20 states		for(int j=0;j<nchars;j++)			{			short nstates=0, cone,ctwo;			for(int k=0;k<nShortsPerChar;k++)				*(unionchar+k)=0;			nstates=charordata->GetNumStates(i,j);			if(nstates>1)				{//Not A gap				for(int k=0;k<nstates;k++) 					{EncodeACharacter(tempchar,charordata->GetState(i,j,k),datatype);					for(int k=0;k<nShortsPerChar;k++)						*(unionchar+k)|=*(tempchar+k);					}				for(int k=0;k<nShortsPerChar;k++)					*(curchar+nShortsPerChar*j+k)=*(unionchar+k);				}			else					{if(nstates)	EncodeACharacter(tempchar,charordata->GetState(i,j,0),datatype);				else			EncodeACharacter(tempchar,'-',datatype);				for(int k=0;k<nShortsPerChar;k++)					*(curchar+nShortsPerChar*j+k)=*(tempchar+k);				}			}		curEC=new EncodedChars(nchars, curchar);		//rawData.insert(pair<const nxsstring, EncodedChars *>(curtax, curEC));		rawData[curtax]=curEC;		}	delete []unionchar;	delete []tempchar;		}void Bull::CreateParameterAlterationInfo(SetOfTreeLikeAttr *tsla,Tree *t){	assert(LSettings);	assert(DSettings);	delete paramAlterInfo;	paramAlterInfo=new ParameterAlterationInfo(LSettings,partitions,tsla,t,this);}SetOfLikeAttr *Bull::CreateSetOfLikeAttrForANode(void){	assert(!NeedToPartition());//returns Set for internal node	SetOfLikeAttr *temp;	temp=new SetOfLikeAttr(npartitions);	for(int i=0;i<npartitions;i++)		{int nmods=partitions[i]->GetNModels();		temp->SetNumModsInPart(i,nmods);#ifdef CODONHACK		assert(nmods==1);	#ifdef SHAREDMEMFORINTCHARS		assert(partitions[i]->GetNChar(0)==1);		double *condlike;		if(i==0)			condlike=new double[64];		temp->AddLikeAtt(i,0,(new InternalNodeLikeAttr(1,partitions[i]->GetModel(0),condlike)));	#else		temp->AddLikeAtt(i,0,(new InternalNodeLikeAttr(partitions[i]->GetNChar(0),partitions[i]->GetModel(0))));	#endif#else		for(int j=0;j<nmods;j++)			temp->AddLikeAtt(i,j,(new InternalNodeLikeAttr(partitions[i]->GetNChar(j),partitions[i]->GetModel(j))));#endif		}	return temp;}SetOfLikeAttr *Bull::CreateSetOfLikeAttrForANode(nxsstring termName){	assert(!NeedToPartition());//returns Set for terminal node	SetOfLikeAttr *temp;	temp=new SetOfLikeAttr(npartitions);	for(int i=0;i<npartitions;i++)		{int nmods=partitions[i]->GetNModels();		temp->SetNumModsInPart(i,nmods);		for(int j=0;j<nmods;j++)			temp->AddLikeAtt(i,j,(new TerminalNodeLikeAttr(partitions[i]->GetCharsInShorts(j,termName),partitions[i]->GetModel(j))));		}	return temp;}SetOfTreeLikeAttr *Bull::CreateSetOfLikeAttrForATree(void){	assert(!NeedToPartition());//returns Set for terminal node	int prevlikecounter=0;	SetOfTreeLikeAttr *temp;	temp=new SetOfTreeLikeAttr(npartitions);	for(int i=0;i<npartitions;i++)		{int nmods=partitions[i]->GetNModels();		temp->SetNumModsInPart(i,nmods);		if(nmods>1)			temp->SetModelMixingParam(i,partitions[i]->GetModelMixingParam());		for(int j=0;j<nmods;j++)			{TreeLikeAttr *tempPtr;			tempPtr=new TreeLikeAttr(partitions[i]->GetNChar(j)				,partitions[i]->GetModel(j)				,partitions[i]->GetIsConstant(j)				,partitions[i]->GetNReps(j),partitions[i]->GetConstChars(j));			temp->AddLikeAtt(i,j,tempPtr);			if(previousLikelihoods)				{tempPtr->SetLikelihood(previousLikelihoods[prevlikecounter]);				temp->thisL[i]+=previousLikelihoods[prevlikecounter];				prevlikecounter++;				}			}		temp->FinishedAddingModels(i,partitions[i]->GetPackingIndex());		}	return temp;}			SetOfParsAttr *Bull::CreateSetOfParsAttrForANode(void){	assert(!NeedToPartition());	assert(PSettings);//returns Set for internal node	SetOfParsAttr *temp;	temp=new SetOfParsAttr(npartitions);	for(int i=0;i<npartitions;i++)		temp->AddParsAtt(i,(new InternalNodeParsAttr(partitions[i]->GetNChar(0),PSettings->GetEncodingType(i))));	return temp;}SetOfParsAttr *Bull::CreateSetOfParsAttrForANode(nxsstring termName){	assert(!NeedToPartition());	assert(PSettings);//returns Set for terminal node	SetOfParsAttr *temp;	temp=new SetOfParsAttr(npartitions);	for(int i=0;i<npartitions;i++)		temp->AddParsAtt(i,(new TerminalNodeParsAttr(partitions[i]->GetCharsInShorts(0,termName),partitions[i]->GetNChar(0),PSettings->GetEncodingType(i))));	return temp;}SetOfTreeParsAttr *Bull::CreateSetOfParsAttrForATree(void){	assert(!NeedToPartition());//returns Set for terminal node	SetOfTreeParsAttr *temp;	temp=new SetOfTreeParsAttr(npartitions);	for(int i=0;i<npartitions;i++)		temp->AddParsAtt(i,(new TreeParsAttr(partitions[i]->GetNChar(0),partitions[i]->GetIsConstant(0),partitions[i]->GetNReps(0),PSettings->GetEncodingType(i))));	return temp;}			void Bull::EliminateAminoAcidsThatHaveFreqZero(Tree *t){#ifdef CODONHACK	#ifdef ELIMINATEALLZEROS		SSRFCodonSubMod *tempM;		for(int p=0;p<DSettings->GetNDataPartitions();p++)			for(int m=0;m<LSettings->GetNModelsInPart(p);m++)				{tempM=(SSRFCodonSubMod *) t->GetLikeAttributes()->GetModel(p,m);				int origstates=tempM->GetNStates();				tempM->ResizeModel();				if(origstates!=tempM->GetNStates())					t->RecodeTerminalsAndLikeAttr(p,m);				}			#endif#endif}void Bull::EStateFreqs(){	if(NeedToPartition())		Partition();	for(int i=0;i<npartitions;i++)		{int nchars=partitions[i]->GetNChar(i);		int dtype=partitions[i]->GetPackingType();		int nstates=NumStates(dtype);		double *stFreq,*compFreq;		stFreq=new double[nstates];		compFreq=new double[nstates];		short *charCod;		charCod=new short[NumShortsPerCharacter(dtype)];		bool varNeedCauseOfPoorCode;		for(int j=0;j<nchars;j++)			{for(int k=0;k<nstates;k++)				{EncodeACharacter(charCod,(short) GetNameOfIthState(k,dtype,&varNeedCauseOfPoorCode),dtype);				stFreq[k]=(double) partitions[i]->GetNumTaxWithState(charCod,0,j);				compFreq[k]=(double) partitions[i]->GetNumTaxWithState(charCod,0,j,false);				}			double tot=0.0,ctot=0.0;			for(int k=0;k<nstates;k++)				{tot+=stFreq[k];				ctot+=compFreq[k];				}			int tc;			bool isChar;			message="For character\t";			message+=1+j;			message+="\t(of this partition)\t";			LPrintMessage(false,false);			for(int k=0;k<nstates;k++)				{				message="";				//message="The Empirical frequency of state\t";				tc=GetNameOfIthState(k,partitions[i]->GetPackingType(),&isChar);				if(isChar)	message+=(char) tc;				else		message+=tc;				message+="\t";				//message+="is\t";				message+=(stFreq[k]/tot);				message+="\t";				//message+="(\t";				//message+=(compFreq[k]/ctot);				//message+="\tcompatible with it)";				LPrintMessage(false,false);				}			message="\n";			LPrintMessage(false,false);			}		delete [] stFreq;		delete [] compFreq;		delete [] charCod;		}}/** * @method FactoryDefaults [void:protected] * * Sets all data members to their factory default settings: * <table> * <tr><th align="left">Variable <th> <th align="left"> Initial Value * <tr><td> inf_open          <td>= <td> false * <tr><td> logf_open         <td>= <td> false * <tr><td> quit_now          <td>= <td> false * <tr><td> message           <td>= <td> "" * <tr><td> next_command[0]   <td>= <td> '\0' * <tr><td> trees             <td>= <td> NULL * <tr><td> taxa              <td>= <td> NULL * <tr><td> assumptions       <td>= <td> NULL * <tr><td> characters        <td>= <td> NULL * </table> */void Bull::FactoryDefaults(){	logEachStep=true;//temporary	inf_open = false;	logf_open = false;	quit_now = false;	purged=true;	message = "";	next_command[0] = '\0';		trees = NULL;	taxa = NULL;	assumptions = NULL;	characters = NULL;	data=NULL;	charordata=NULL;	ntrees = ntaxa = nchars = 0;	curmodel=0L;	partitions=NULL;	npartitions=0;	paramAlterInfo=NULL;	LSettings=NULL;	DSettings=NULL;	PSettings=NULL;	storebrlens=true;	criterion=criteria(maxLike);		previousLikelihoods=NULL;//for super long calcs that Have to be restarted	nParamDirectionsToSkip=0;//for super long calcs that Have to be restarted	nParamGroupsToSkip=0;	nBranchesToSkip=0;	lastParamImprov=lastBranchImprov=MAXDOUBLE;}Tree* Bull::FindTreeFromName(nxsstring s){	ToUpper(s);	for(int i=0;i<treelist.size();i++)		if(s==treelist[i]->GetName())			return treelist[i];	throw NoSuchTree(s.c_str());}void Bull::FinishAssumptionsBlock(){	#ifdef DZRATES	if(DSettings)		{assert(DSettings->GetNDataPartitions()==1);//DZRATES should be implemented as different partitions		LabelList ll;		assumptions->GetCharSetNames(ll);//TEMPORARY REALLY CRAPPY huge memory leak		for(int i=0;i<assumptions->GetNumCharSets();i++)			{if(ll[i][0]=='L')				{IntSet wholeSet=assumptions->GetCharSet(ll[i]);				for(IntSet::iterator iIt=wholeSet.begin();iIt!=wholeSet.end();iIt++)					{IntSet * tempIS;					tempIS=new IntSet;					tempIS->erase(tempIS->begin(),tempIS->end());					tempIS->insert(*iIt);					DSettings->AddRateSet(tempIS);					}				}			else				DSettings->AddRateSet(&(assumptions->GetCharSet(ll[i])));			}		/*vector<IntSet *> *userRs;		userRs=DSettings->GetRateSets();		for(vector<IntSet *>::iterator*/		}#endif		}void Bull::FinishCharactersBlock()//called in handle execute and always called after FinishTaxaBlock(){	nchars=charordata->GetNChar();	CreateDataMap();	assert(!DSettings);	DSettings=new DataSettings(0,nchars);	LSettings=new LikeSettings(DSettings);	PSettings=new ParsSettings(DSettings,datatype);	for(int i=0;i<ntaxa;i++)		DSettings->AddTaxon(taxa->GetTaxonLabel(i));/*	if(!trees->IsEmpty())		for(vector<Tree *>::iterator treit=treelist.begin();treit!=treelist.end();treit++)			(*treit)->AssignDataToTerm(taxa, rawData);				*/		if(nchars>1)	cout<<nchars <<" characters read from file"<<endl;			else			cout<<nchars <<" character read from file"<<endl;}void Bull::FinishTaxaBlock(){	ntaxa=taxa->GetNumTaxonLabels();	if(ntaxa>1)	cout<<ntaxa<<" taxa in memory"<<endl;	else		cout<<ntaxa<<" taxon in memory"<<endl;}void Bull::FinishTreesBlock(){	ntrees=trees->GetNumTrees();	for(int i=0;i<ntrees;i++){		Tree *temptree=new Tree(trees->GetTranslatedTreeDescription(i));		if(!temptree->IsGood())				throw MTHException("Bad Tree");		nxsstring s=trees->GetTreeName(i);		ToUpper(s);		temptree->SetName(s);		if(charordata)//either characters or data are read in			temptree->AssignDataToTerm(taxa, rawData);		treelist.push_back(temptree);		}	if(ntrees>1)	cout<<ntrees<<" trees read from file"<<endl;	else			cout<<ntrees<<" tree read from file"<<endl;}int Bull::GetPlaceInPackedPartition(int partNum,int rawChar){	//receives the raw number of the character, finds out which character it is  	//from the beginning of its partition, and then queries the partition 	//to find out which packed column contains the character now.	assert(DSettings);	int numInPart= DSettings->FindCharNumInPartition(partNum,rawChar);	assert(partitions);	assert(partitions[partNum]);	return partitions[partNum]->GetPlaceInPackedPartition(numInPart);}void Bull::GetTreeReadyToCalcLike(Tree *t){	if(NeedToPartition())			Partition();	RecursiveNodeList=t->GetRecursiveNodeList();	if(t->AttributesAreDirty() || !t->GetLikeAttributes())		{if(t->GetLikeAttributes() && !DSettings->userInputBrLen)			SetBrlensToNULLIfNotOwner(t);		Node **temp;		temp=RecursiveNodeList;		if(DSettings->userInputBrLen)			{while(*temp)				{				if((*temp)->IsTerm())					(*temp)->ReplaceSetOfLikeInfoButKeepBranchLen(CreateSetOfLikeAttrForANode((*temp)->GetName()));//Destroys old LikeAttr for the nodes (including brLens)				else					(*temp)->ReplaceSetOfLikeInfoButKeepBranchLen(CreateSetOfLikeAttrForANode());//Destroys old LikeAttr for the nodes (including brLens)				temp++;				}			}					else			{while(*temp)				{if((*temp)->IsTerm())					(*temp)->ReplaceSetOfLikeInfo(CreateSetOfLikeAttrForANode((*temp)->GetName()));//Destroys old LikeAttr for the nodes(including brLens)				else					(*temp)->ReplaceSetOfLikeInfo(CreateSetOfLikeAttrForANode());//Destroys old LikeAttr for the nodes (including brLens)				temp++;				}			}		t->SetLikeAttributes(CreateSetOfLikeAttrForATree());//Destroys old LikeAttr for the tree (including brLen Modifiers)		}#ifdef DZRATES	(t->GetLikeAttributes())->AddRateSets(DSettings->GetRateSets());#endif	assert(LSettings);	assert(DSettings);	if(LSettings->useRSBranchLengths)	throw MTHException("Rogers Swofford starting branch lengths are not supported yet");	InstantiateBranchLengths(t);	InstantiateBranchLengthModifiers(t);	InitializeParameters();	t->GetLikeAttributes()->InitializeModelMixingParams();#ifdef CODONHACK	#ifdef ELIMINATEALLZEROS		SSRFCodonSubMod *tempM;		for(int p=0;p<DSettings->GetNDataPartitions();p++)			for(int m=0;m<LSettings->GetNModelsInPart(p);m++)				{tempM=(SSRFCodonSubMod *) t->GetLikeAttributes()->GetModel(p,m);				int origstates=tempM->GetNStates();				tempM->ResizeModel();				if(origstates!=tempM->GetNStates())					t->RecodeTerminalsAndLikeAttr(p,m);				}			#endif#endif}void Bull::GetTreeReadyToCalcPars(Tree *t){		assert(PSettings);	assert(DSettings);	if(NeedToPartition())			Partition();	RecursiveNodeList=t->GetRecursiveNodeList();	if(t->AttributesAreDirty() || !t->GetParsAttributes())		{Node **temp;		temp=RecursiveNodeList;		while(*temp)			{if((*temp)->IsTerm())				(*temp)->ReplaceSetOfParsInfo(CreateSetOfParsAttrForANode((*temp)->GetName()));//Destroys old ParsAttr for the nodes(including brLens)			else				(*temp)->ReplaceSetOfParsInfo(CreateSetOfParsAttrForANode());//Destroys old ParsAttr for the nodes (including brLens)			temp++;			}		t->SetParsAttributes(CreateSetOfParsAttrForATree());//Destroys old LikeAttr for the tree (including brLen Modifiers)		}	}void Bull::InitializeParameters(){	map<Model *,int > modmap;	for(int p=0;p<DSettings->GetNDataPartitions();p++)		for(int m=0;m<LSettings->GetNModelsInPart(p);m++)			{Model *temp;			temp=LSettings->GetModel(p,m);			if(modmap.end()==modmap.find(temp))				{modmap[temp]=1;				temp->InitializeParameters();				}			}}double Bull::InitialLScore(Tree *t){	double thislike;	GetTreeReadyToCalcLike(t);#ifdef CODONHACK	if(previousLikelihoods)		{thislike=0.0;		SetOfTreeLikeAttr *tempTSLA;		tempTSLA=t->GetLikeAttributes();		TreeLikeAttr *tempTLA;		for(int partn=0;partn<npartitions;partn++)			{tempTLA=tempTSLA->GetLikeAtt(partn,0);			if(workingOnBranches && nBranchesToSkip>0)//likelihoods are coming from broptfile and are unmultiplied				{tempTSLA->thisL[partn]=previousLikelihoods[partn];				tempTSLA->thisLMult[partn]=previousLikelihoods[partn]+((t->GetNTax())*log(tempTLA->GetMultiplier()));				}			else				{tempTSLA->thisL[partn]=previousLikelihoods[partn]-((t->GetNTax())*log(tempTLA->GetMultiplier()));				tempTSLA->thisLMult[partn]=previousLikelihoods[partn];				}			thislike+=tempTSLA->thisLMult[partn];			tempTLA->currentLikelihood=tempTSLA->thisL[partn];			tempTLA->needsToBeRescored=false;			}		t->likelihood=thislike;		}	else		if((!workingOnBranches && lastBranchImprov<lastParamImprov) || (nParamGroupsToSkip>0 || nParamDirectionsToSkip>0) )#endif			thislike=t->LScoreAlreadyInitialized();	/*WriteLogFileForCurrentPosition(-1);	assert(0);*/	cout<<"The likelihood is "<<thislike<<endl;	return thislike;} void Bull::InstantiateBranchLengths(Tree *t){	assert(LSettings);	assert(DSettings);	if(DSettings->userInputBrLen)	return;//assumes that the BrLens are already instantiated and in place;  This should be the only case in which the brlens are already instantiated	RecursiveNodeList=t->GetRecursiveNodeList();//probably unnecessary (already done)	int nsetsofblens=LSettings->GetNSetsOfBranchLengths();	Node **temp;	SetOfTreeLikeAttr *treesSetofLA=t->GetLikeAttributes();		int branchLenParameterSetting;	if(LSettings->useRSBranchLengths)		branchLenParameterSetting=par(APPRO)|par(MIN);	else		branchLenParameterSetting=par(DEF)|par(MIN);	PartModIndex owner;	for(int n=0;n<nsetsofblens;n++)//Allocate brlens for all part/models that "own them"		{		owner=LSettings->GetOwnerOfNthSetOfBrLengths(n);		treesSetofLA->SetOwnerOfBrLengths(owner,true);		temp=RecursiveNodeList;		while(*temp)			{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);			assert(!((*temp)->likeInfo->GetBLenParameterPtr()));			PositiveParameter *tempP;			tempP=new PositiveParameter(DEFAULTSTARTINGBRLEN,branchLenParameterSetting,DEFAULTSTARTINGBRLEN);			(*temp)->likeInfo->SetBLenPtr(tempP);			temp++;			}		}	for(int p=0;p<DSettings->GetNDataPartitions();p++)		for(int m=0;m<LSettings->GetNModelsInPart(p);m++)			{owner.Set(p,m);			if(!(treesSetofLA->GetOwnerOfBrLengths(owner)))				{temp=RecursiveNodeList;				while(*temp)					{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);					assert(!((*temp)->likeInfo->GetBLenParameterPtr()));					LikeAttr *tempLa; PartModIndex realOwner;					realOwner=LSettings->GetOwnerOfBrLens(p,m);					tempLa=(*temp)->GetLikeAtt(realOwner.partNum,realOwner.modNum);					(*temp)->likeInfo->SetBLenPtr(tempLa->GetBLenParameterPtr());					temp++;					}				}			}		}void Bull::InstantiateBranchLengthModifiers(Tree *t){	assert(LSettings);	assert(DSettings);	RecursiveNodeList=t->GetRecursiveNodeList();//probably unnecessary (already done)	int nsetsofblenmods=LSettings->GetNSetsOfBranchLengthModifiers();	Node **temp;	SetOfTreeLikeAttr *treesSetofLA=t->GetLikeAttributes();		int branchLenModParameterSetting=par(DEF)|par(MIN);//default value for rate modifiers is 1.0 right now	//Right now the branch length modifier is added to every Node in the tree (no starting relaxed clock values)		PartModIndex owner;	for(int n=0;n<nsetsofblenmods;n++)//Allocate brlens for all part/models that "own them"		{		owner=LSettings->GetOwnerOfNthSetOfBrLengthModifiers(n);		PositiveParameter *tempP;		tempP=new PositiveParameter(1.0,branchLenModParameterSetting,1.0);		treesSetofLA->AddBrLenMod(owner,tempP,true);		temp=RecursiveNodeList;		while(*temp)			{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);			(*temp)->likeInfo->SetBLenModPtr(tempP);			temp++;			}		}	for(int p=0;p<DSettings->GetNDataPartitions();p++)		for(int m=0;m<LSettings->GetNModelsInPart(p);m++)			{owner.Set(p,m);			if(LSettings->HasBrLenMod(p,m))				if(owner!=LSettings->GetOwnerOfBrLenModifiers(p,m)) //if this part/mod doesn't own its own blenMods					{					PositiveParameter *tempP;					tempP=treesSetofLA->GetBrLenMod(LSettings->GetOwnerOfBrLenModifiers(p,m),0);//0 indicates the first brLenMod change it allowing different starting point for relaxed clock type stuff					treesSetofLA->AddBrLenMod(owner,tempP,false);					temp=RecursiveNodeList;					while(*temp)						{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);						(*temp)->likeInfo->SetBLenModPtr(tempP);						temp++;						}					}			}}bool Bull::NeedToBeginAgainBecauseStateSpaceGrew(Tree *t){#ifdef CODONHACK	#ifdef ELIMINATEALLZEROS		SSRFCodonSubMod *tempM;		for(int p=0;p<DSettings->GetNDataPartitions();p++)			for(int m=0;m<LSettings->GetNModelsInPart(p);m++)				{tempM=(SSRFCodonSubMod *) t->GetLikeAttributes()->GetModel(p,m);				if(tempM->NeedToExpandPossibleAA())					return true;				}			#endif#endif	return false;}bool Bull::NeedToPartition(){	if(!partitions)	return true;	if(partitions[0]->dirty)	return true;	if(partitions[0]->partCrit!=criterion) return true;	return false;}void Bull::Partition(){	assert(DSettings);	if(criterion==criteria(maxLike))		assert(LSettings);	else	{assert(criterion==criteria(pars));			assert(PSettings);			}		for(int i=0;i<npartitions;i++)		delete partitions[i];	delete [] partitions;	npartitions=DSettings->GetNDataPartitions();	partitions=new DataPartition *[npartitions];	for(int i=0;i<npartitions;i++)		if(criterion==criteria(maxLike))			partitions[i]=new DataPartition(LSettings, rawData,i);		else			partitions[i]=new DataPartition(PSettings, rawData,i);}int Bull::PScore(Tree *tree){	int score=0;	for(int i=0;i<npartitions;i++)		{int nchars=partitions[i]->GetNChar(i);		int nstates=NumStates(partitions[i]->GetPackingType());		tree->PrepareParsAttrForCalcuation(i);		short *nR=tree->GetParsAttributes()->GetParsAtt(i)->GetNReps();		for(int j=0;j<nchars;j++)			{score+=*nR*(tree->FirstPass(j));			nR++;			}		}	return score;}void Bull::PStateFreqs(Tree *tree){		for(int i=0;i<npartitions;i++)		{int nchars=partitions[i]->GetNChar(i);		int nstates=NumStates(partitions[i]->GetPackingType());		double *stFreq;		stFreq=new double[nstates];		tree->PrepareParsAttrForCalcuation(i);		for(int j=0;j<nchars;j++)			{tree->FirstPass(j);			tree->SecondPass(j);			for(int k=0;k<nstates;k++)				{stFreq[k]=tree->GetPStateFreq(j,k,0);				stFreq[k]+=tree->GetPStateFreq(j,k,1);				}			double tot=0.0;			for(int k=0;k<nstates;k++)				tot+=stFreq[k];			int tc;			bool isChar;			message="For character\t";			message+=1+j;			message+="\t";			//message+="(of this partition)";			LPrintMessage(false,false);			message="(";			for(int k=0;k<nstates-1;k++)				{				/*message="The Frequency of state\t";				tc=GetNameOfIthState(k,partitions[i]->GetPackingType(),&isChar);				if(isChar)	message+=(char) tc;				else		message+=tc;				//message+="\tis\t";				message+="\t";*/				message+=(stFreq[k]/tot);				message+="\t";				}			message+=")\n";			LPrintMessage(false,false);			}		delete [] stFreq;		}}/** * @method PurgeBlocks [void:protected] * * Detaches all blocks, deletes them, creates new blocks, and  * finally adds the new blocks. */void Bull::PurgeBlocks(){	Detach( taxa );	Detach( trees );	Detach( assumptions );	Detach( characters );	Detach( data );		delete characters; characters=NULL;	delete assumptions; assumptions=NULL;	delete trees; trees=NULL;	delete taxa; taxa=NULL;	delete data; data=NULL;	delete LSettings; LSettings=NULL;	delete DSettings; DSettings=NULL;	delete PSettings; PSettings=NULL;	charordata=NULL;		for(vector<Tree *>::iterator treit=treelist.begin();treit!=treelist.end();treit++)		(*treit)->DestroyTreeNotData();	//for_each(treelist.begin(),treelist.end(),mem_fun(&Tree::DestroyTreeNotData));	treelist.erase(treelist.begin(),treelist.end());	for(map<nxsstring, EncodedChars *>::iterator dmit=rawData.begin();dmit!=rawData.end();dmit++)		delete (dmit->second);	rawData.erase(rawData.begin(),rawData.end());		datatype=0;	for(int i=0;i<npartitions;i++)		delete partitions[i];	delete [] partitions;	partitions=NULL;	ntrees=ntaxa=nchars=npartitions=0;	RecursiveNodeList=NULL;			taxa = new TaxaBlock();	trees = new TreesBlock(*taxa);	assumptions = new AssumptionsBlock( *taxa );	characters = new CharactersBlock( *taxa, *assumptions );	data = new DataBlock(*taxa, *assumptions );		charordata=NULL;	Add( taxa );	Add( trees );	Add( assumptions );	Add( characters );	Add( data );	purged=true;}/** * @method Read [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * This function provides the ability to read everything following * the block name (which is read by the Nexus object) to the end or * endblock statement. Characters are read from the input stream * in. Overrides the pure virtual function in the base class. */void Bull::Read( NexusToken& token ){  	   isEmpty = false;   // this should be the semicolon after the block name   //	token.GetNextToken();	if( !token.Equals(";") ) {		errormsg = "Expecting ';' after ";      errormsg += id;      errormsg += " block name, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}		//Get Info from other blocks if not already done	if(purged && !taxa->IsEmpty())		{purged=false;		FinishTaxaBlock();		if(!trees->IsEmpty())			FinishTreesBlock();		if(!data->IsEmpty())			{if(!characters->IsEmpty()) throw XNexus("Can't have both a characters and data block", token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			charordata=data;			FinishCharactersBlock();			}		else	if(!characters->IsEmpty())			{if(!data->IsEmpty()) throw XNexus("Can't have both a characters and data block", token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			charordata=characters;			FinishCharactersBlock();			}		}		for(;;)		{token.GetNextToken();		if( token.Abbreviation("ENdblock") ) 			{HandleEndblock( token );			break;			}		else if( token.Abbreviation("Quit") ) 			{quit_now = true;			message = "\nBull says goodbye\n";			PrintMessage();			break;			}		TryAdvancedCommands(token);		}}void Bull::Reconstruct(Tree *tree,int partNum,int charNum,int displayMode){	tree->PrepareParsAttrForCalcuation(partNum);	tree->FirstPass(charNum);	tree->SecondPass(charNum);	tree->ShowTree(SIOUXSettings.columns,displayMode,charNum);}/** * @method Run [void:public] * * Runs the command line interpreter, allowing Bull to interact with user. * Typically, this is the only function called in main after a Bull object * is created. */void Bull::Run(){	taxa = new TaxaBlock();	trees = new TreesBlock(*taxa);	assumptions = new AssumptionsBlock( *taxa );	characters = new CharactersBlock( *taxa, *assumptions );	data = new DataBlock( *taxa, *assumptions );		Add( taxa );	Add( trees );	Add( assumptions );	Add( characters );	Add( data );	Add( this );		HKY chky;	GTR cgtr;	firstTimeThrough=true;				quit_now = false;try	{while( !quit_now ) 		{			cerr << endl;			cerr << "Bull> ";	#ifdef	DEBUGGING			if(firstTimeThrough)				{#ifdef HALPERNTEST				strcpy(next_command,"Execute HalpernTest");#else				cin.getline( next_command, 256 );				//strcpy(next_command,"Execute FinalPrunedFixedCytb.dat");				//strcpy(next_command,"Execute VeryShort4taxonCytB.dat");				//strcpy(next_command,"Execute shortCytb.dat");#endif				firstTimeThrough=false;				}			else cin.getline( next_command, 256 );			firstTimeThrough=false;	#else			cin.getline( next_command, 256 );	#endif			PreprocessNextCommand();			HandleNextCommand();		}	}catch(MTHException ex)	{cout<<ex.msg<<endl;	char i; cin>>i;	}catch(bad_alloc ba)	{cout<<"There is not enough memory to execute that command, Bull will be crashing now."<<endl;	char i; cin>>i;	}	}void Bull::SetBrlensToNULLIfNotOwner(Tree *t){	assert(LSettings);	assert(DSettings);	assert(!(DSettings->userInputBrLen));	RecursiveNodeList=t->GetRecursiveNodeList();//probably unnecessary (already done)	Node **temp;	SetOfTreeLikeAttr *treesSetofLA=t->GetLikeAttributes();	PartModIndex owner;	for(int p=0;p<DSettings->GetNDataPartitions();p++)		for(int m=0;m<LSettings->GetNModelsInPart(p);m++)			{owner.Set(p,m);			if(!(treesSetofLA->GetOwnerOfBrLengths(owner)))				{temp=RecursiveNodeList;				while(*temp)					{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);					(*temp)->likeInfo->SetBLenPtr(NULL);					temp++;					}				}			}		}void Bull::TryAdvancedCommands(NexusToken &token){	//everything but Endblock and quit	if(token.Abbreviation("CODLIKESTartval") || token.Abbreviation("CLIKESTartval") || token.Abbreviation("CLSTartval"))		HandleCodLikeStartVal(token );	else if(token.Abbreviation("CONTinueanalysis"))		HandleContinueAnalysis(token);	else if( token.Abbreviation("EXecute") ) 			HandleExecute( token );				else if( token.Abbreviation("Gettrees")) 		HandleGetTrees( token );			else if( token.Abbreviation("LOg") ) 		HandleLog( token );		else if( token.Abbreviation("LSCore") ) 		HandleLscore( token );	else if( token.Abbreviation("LSEt") ) 		HandleLset( token );	else if( token.Abbreviation("Pscore") ) 		HandlePscore( token );	else if( token.Abbreviation("Reconstruct") ) 		HandleReconstruct( token );		else if( token.Abbreviation("SHowtrees") ) 		HandleShowTrees( token );		else if( token.Abbreviation("STatefrequencies") || token.Abbreviation("STatefrequency")) 		HandleStateFreq( token );	else if( token.Abbreviation("SUmmarizelog")) 		HandleSummarizeLogs( token );	else if( token.Abbreviation("TAbtree") ) 		HandleTabTree( token );	else if( token.Abbreviation("TRAnslatecodons") ) 		HandleTranslateCodons( token );	else if( token.Abbreviation("UPdatebranchlengths") ) 		HandleUpdateBranchLengths( token );	else if( token.Abbreviation("EXECUTEBull") || token.Abbreviation("EXBull") ) 		HandleExecuteBullBlocksInFile(token);	else	 	{SkippingCommand( token.GetToken() );	    do {	       token.GetNextToken();	    	} 	    while( !token.AtEOF() && !token.Equals(";") );	    if( token.AtEOF() ) {				errormsg = "Unexpected end of file encountered";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	    }	}}void Bull::WriteCharactersBlock(ofstream &tout,bool interleave,int DNATranslation){	assert(charordata);	assert(taxa);	assert(!interleave);//not written yet	assert(ntaxa==taxa->GetNumTaxonLabels());	assert(nchars==charordata->GetNChar());	EncodedChars *tempEC;	short *tempdata;	nxsstring tempstr;	int maxlen=taxa->GetMaxTaxonLabelLength();	int nspci=NumShortsPerCharacter(datatype);	if(!DNATranslation)		{tout<<"BEGIN CHARACTERS;\nDIMENSIONS NCHAR="<<nchars<<";\n";		tout<<"FORMAT DATATYPE=DNA;\nMATRIX\n";		for(int i=0;i<ntaxa;i++)			{tempstr=taxa->GetTaxonLabel(i);			BlanksToUnderscores(tempstr);			tout<<tempstr;			for(int j=taxa->GetTaxonLabel(i).length();j<4+maxlen;j++)				tout<<" ";			tempEC=rawData[taxa->GetTaxonLabel(i)];			assert(tempEC);			tempdata=tempEC->GetDataPtr();			for(int j=0;j<nchars;j++)				tout<<DecodeState((tempdata+j*nspci),datatype);			tout<<"\n";			}		}	else		{assert(charordata->GetDataType()==2);//not written yet		int ntrans,modulo;		ntrans=(int) floor(((double) nchars)/3.0);		modulo=nchars%3;		if(modulo)			ntrans++;		tout<<"BEGIN CHARACTERS;\nDIMENSIONS NCHAR="<<ntrans<<";\n";		tout<<"FORMAT DATATYPE=PROTEIN MISSING='X';\nMATRIX\n";		for(int i=0;i<ntaxa;i++)			{tempstr=taxa->GetTaxonLabel(i);			BlanksToUnderscores(tempstr);			tout<<tempstr;			cout<<tempstr<<endl;			for(int j=taxa->GetTaxonLabel(i).length();j<4+maxlen;j++)				tout<<" ";			tempEC=rawData[taxa->GetTaxonLabel(i)];			assert(tempEC);			tempdata=tempEC->GetDataPtr();			if(DNATranslation==1)// mammal mitochondrial written				for(int j=0;j<ntrans;j++)					{if(!modulo || j<ntrans-1)							tempstr=MitoTranslateThreeNucleotides(tempdata+j*3);					else	tempstr=MitoTranslateThreeMinusSecondArgNucleotides(tempdata+j*3,modulo);					if(tempstr.length()==1)	tout<<tempstr;					else	tout<<"{"<<tempstr<<"}";					}			else if(DNATranslation==2) //nuclear				for(int j=0;j<ntrans;j++)					{if(!modulo || j<ntrans-1)							tempstr=NucTranslateThreeNucleotides(tempdata+j*3);					else	tempstr=NucTranslateThreeMinusSecondArgNucleotides(tempdata+j*3,modulo);					if(tempstr.length()==1)	tout<<tempstr;					else	tout<<"{"<<tempstr<<"}";					}			tout<<"\n";			}		}	tout<<";\nENDBLOCK;\n";	}void Bull::WriteLogFileForCurrentPosition(int pgtoskip,int patoskip,bool startBranches/*=false*/){	#ifdef CODONHACK	nxsstring tempstr=commandFileTag;		tempstr+=commandFileNum;	commandFileNum++;	ofstream nextCF;	nextCF.open(tempstr.c_str());		assert(modArr);	assert(*modArr);	if(pgtoskip)		{nextCF<<"#NEXUS\nBEGIN BULL;\n\tcodlikestartval currbranchlengths groupskip="<<pgtoskip<<"\n";		}	else		{nextCF<<"#NEXUS\nBEGIN BULL;\n\tcodlikestartval currbranchlengths groupskip=";		nextCF<<pgtoskip<<" paramskip="<<patoskip<"\n";		}	nextCF<<"\t\tlastParamImprovement = "<<lastParamImprov<<" lastBranchImprovement = "<<lastBranchImprov<<"\n";		//TEMPORARY ASSUMES THAT TREE BEING SCORED IS TREELIST[0]	nextCF<<"\t\tPARAMIMPROVEThisround = "<<likeAtBegOfThisRound-(treelist[0]->likelihood)<<"\n";	nextCF<<"\t\tnst=6 basefreq = ( ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::freqA)->val;	nextCF<<" "<<(*modArr)->GetParameter(SSRFCodonSubMod::freqC)->val<<" ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::freqG)->val<<")\n\t\trMatrix = ( ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::rAC)->val<<" ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::rAG)->val<<" ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::rAT)->val<<" ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::rCG)->val<<" ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::rCT)->val<<" ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::rGT)->val<<")\n\t\ttreescale = ";	nextCF<<(*modArr)->GetParameter(SSRFCodonSubMod::blenMult)->val<<"\n";	nextCF<<"\t\taafreq = ( "<<sizeOfModArr<<"\n";	for(int i=0;i<sizeOfModArr;i++)		{nextCF<<"\t\t\t(";		modArr[i]->AddAminoAcidFreqs(nextCF);		nextCF<<")\n";		}	nextCF<<"\t\t)\n\tmult = (";	for(int i=0;i<sizeOfModArr;i++)		{nextCF<<" ";		nextCF<<modArr[i]->GetMultiplier();		}	nextCF<<")\n";		SetOfTreeLikeAttr *onlyTreeAtt;	TreeLikeAttr *tla;	assert(treelist.size()==1);	onlyTreeAtt=treelist[0]->GetLikeAttributes();	double *likearray;	if(startBranches)		nextCF<<"branchskip ";	else		{nextCF<<"\tprevlike = (";		likearray=onlyTreeAtt->thisLMult;		for(int i=0;i<sizeOfModArr;i++)			{nextCF<<" ";			tla=onlyTreeAtt->GetLikeAtt(i,0);			nextCF<<likearray[i];			}		nextCF<<")";		}	nextCF<<";\nENDBLOCK;"<<endl;	nextCF.close();		/*nxsstring tempstr="log stop";	strcpy(next_command,tempstr.c_str());	PreprocessNextCommand();	istrstream lscmdin( next_command );//HandleNext Command without the catch statement, so any errors will get thrown to higher level	NexusToken lstoken(lscmdin);	Read( lstoken );		logNum++;	tempstr="log file=";	tempstr+=logTag;		tempstr+=logNum;	strcpy(next_command,tempstr.c_str());	PreprocessNextCommand();		istrstream lcmdin( next_command );//HandleNext Command without the catch statement, so any errors will get thrown to higher level	NexusToken ltoken(lcmdin);	Read( ltoken );	logEachStep=true;	cout<<"Just opened new log file. Type any key to continue"<<endl;	char c;	//cin>>c;	*/#else	throw	MTHException("Entered unwritten code WriteLogFileForCurrentPosition" );#endif}/** * @method CharLabelToNumber [int:protected] * @param s [nxsstring] the character label to be translated to character number * * The code here is identical to the base class version (simply returns 0), * so the code here should either be modified or this derived version * eliminated altogether.  Under what circumstances would you need to * modify the default code, you ask?  This function should be modified * to something meaningful if this derived class needs to construct and * run a SetReader object to read a set involving characters.  The SetReader * object may need to use this function to look up a character label * encountered in the set.  A class that overrides this method should * return the character index in the range [1..nchar]; i.e., add one to the * 0-offset index. */int Bull::CharLabelToNumber( nxsstring /*s*/ ){   return 0;}/** * @method EnteringBlock [virtual void:public] * @param blockName [nxsstring] the name of the block just entered * * Called by the Nexus object when a block named blockName is entered. * Allows program to notify user of progress in parsing the NEXUS file. * Virtual function that overrides the pure virtual function in the * base class Nexus. */void Bull::EnteringBlock( nxsstring blockName ){	message = "Reading ";	message += blockName;	message += " block...";	PrintMessage();}/*	a fast way to issue a command from code the tempstr is the command a user would type*/void Bull::FakeACommand(const char *tempstr){	strcpy(next_command,tempstr);	PreprocessNextCommand();	istrstream lcmdin( next_command );//HandleNext Command without the catch statement, so any errors will get thrown to higher level	NexusToken ltoken(lcmdin);	Read( ltoken );}/** * @method FileExists [bool:protected] * @param fn [const char*] the name of the file to check * * Returns true if file named fn already exists,  * false otherwise. */bool Bull::FileExists( const char* fn ){	ifstream testst;	testst.open(fn);	if(testst.good())		{testst.close();		return true;		}	testst.close();	return false;}/** * @method HandleEndblock [nxsstring:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called whenever a file name needs to be read from either * the command line or a file.  Expects next token to be "=" * followed by the token representing the file name.  Call * this function after, say, the keyword "file" has been  * read in the following LOG command: * <pre> * log file=doofus.txt start replace; * </pre> * Note that this function will read only "=doofus.txt " * leaving "start replace;" in the stream for reading * at a later time. */nxsstring Bull::GetFileName( NexusToken& token ){	// Eat the equals sign	//	token.GetNextToken();		if( !token.Equals("=") ) {		errormsg = "Expecting an equals sign, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}		// Now get the filename itself	//	token.GetNextToken();		return token.GetToken();}void Bull::LPrintMessage( bool linefeed /* = true */ , bool flusht /*= true*/){	if( logf_open ) {		logf << message;		if( linefeed )			if(flusht)	logf << endl;			else	logf<<'\n';	}}/** * @method NexusError [virtual void:public] * @param msg [nxsstring&] the error message * @param pos [streampos] the point in the NEXUS file where the error occurred * @param line [long] the line in the NEXUS file where the error occurred * @param col [long] the column in the NEXUS file where the error occurred * * Called when an error is encountered in a NEXUS file. Allows program to * give user details of the error as well as the precise location of the * error. Virtual function that overrides the pure virtual function in the * base class Nexus. */void Bull::NexusError( nxsstring& msg, streampos /* pos */, long line, long col ){	message = "\n";	message += msg;	PrintMessage();		if( inf_open )	{		message = "Line:   ";		message += line;		PrintMessage();			message = "Column: ";		message += col;		PrintMessage();	}}/** * @method PreprocessNextCommand [void:public] * * Begins with the command just entered by the user, which is stored in * the data member next_command, adds a semicolon (if the user failed * to supply one), and then adds "end;" so the whole bundle looks * like a very short Bull block.  This is then passed to HandleNextCommand, * which processes it just like a real Bull block in a NEXUS data file. */void Bull::PreprocessNextCommand(){	// If user failed to add the terminating semicolon,	// we'll do it now. We will also remove the line feed	// at the end and add the command "end;" to the end	// of the line (see explanation below).	//	int len = strlen(next_command);	assert( len > 0 );	// Remove any whitespace characters from end of string entered by user	//	int i = len;	while( i > 0 && next_command[i-1] == ' ' || next_command[i-1] == '\t' || next_command[i-1] == '\n' )		i--;	// If character at position i-1 is a semicolon, put '\0' terminator at position i;	// otherwise, put a semicolon at position i and terminator at i+1	//	if( next_command[i-1] != ';' ) {		next_command[i] = ';';		i++;	}	assert( i <= COMMAND_MAXLEN );	next_command[i] = '\0';		// Now add a semicolon at the beginning and terminate with an "END;" command 	// so that we can pretend this is simply a very short private NEXUS block	// containing only one command.  This allows us to simply use the Read 	// function we inherited from the base class BstBase to process the command.	//	len = strlen(next_command);	assert( len < COMMAND_MAXLEN-2 );	nxsstring tmp = ";";	tmp += next_command;	tmp += "end;";	strcpy( next_command, tmp.c_str() );}/** * @method PrintMessage [void:public] * @param linefeed [bool] if true, places newline character after message * * All output handled here.  Writes string currently stored in message  * (a nxsstring data member) to the output file stream, if open, and also  * to the console via cerr. Places newline after string if linefeed is true. */void Bull::PrintMessage( bool linefeed /* = true */ , bool flusht /*= true*/){	cout << message;	if( linefeed )		if(flusht)	cout << endl;		else	cout<<'\n';	if( logf_open ) {		logf << message;		if( linefeed )			if(flusht)	logf << endl;			else	logf<<'\n';	}}/** * @method Reset [void:protected] * * Overrides the pure virtual function in the base class. */void Bull::Reset(){   isEmpty = true;	inf_open = false;	quit_now = false;	message = "";	next_command[0] = '\0';}/** * @method Report [virtual void:public] * @param out [ostream&] the output stream to which to write the report * * This function outputs a brief report of the contents of this Bull block. * Overrides the pure virtual function in the base class. */void Bull::Report( ostream& /* out */ ){	message = "";	PrintMessage();	message = id;	message += " block contains...";	PrintMessage();}/** * @method SkippingBlock [virtual void:public] * @param blockName [nxsstring] the unrecognized block name * * Called when program does not recognize a block name encountered in a  * NEXUS file.  Virtual function that overrides the pure virtual function  * in the base class Nexus. */void Bull::SkippingBlock( nxsstring blockName ){	message = "Skipping unknown block (";	message += blockName;	message += ")";	PrintMessage();}/** * @method SkippingCommand [virtual void:public] * @param commandName [nxsstring] the name of the command being skipped * * This function is called when an unknown command named commandName is * about to be skipped.  This version of the function (which is identical * to the base class version) does nothing (i.e., no warning is issued * that a command was unrecognized).  Modify this virtual function to * provide such warnings to the user (or eliminate it altogether since * the base class version already does what this does). */void Bull::SkippingCommand( nxsstring commandName ){	message = "Skipping unknown command (";	message += commandName;	message += ")";	PrintMessage();}/** * @method TaxonLabelToNumber [int:protected] * @param s [nxsstring] the taxon label to be translated to a taxon number * * The code here is identical to the base class version (simply returns 0), * so the code here should either be modified or this derived version * eliminated altogether.  Under what circumstances would you need to * modify the default code, you ask?  This function should be modified * to something meaningful if this derived class needs to construct and * run a SetReader object to read a set involving taxa.  The SetReader * object may need to use this function to look up a taxon label * encountered in the set.  A class that overrides this method should * return the taxon index in the range [1..ntax]; i.e., add one to the * 0-offset index. */int Bull::TaxonLabelToNumber( nxsstring /* s */ ){   return 0;}/** * @method TaxonLabelToNumber [virtual bool:public] * @param mb_message [nxsstring] the question posed to the user * @param mb_title [nxsstring] the title of the message box * * Asks user if "something" is ok, where "something" is expressed * in the title and message displayed.  This is a virtual function * so it can be overridden in a derived class to use a different * (perhaps graphical) means for displaying the message. * Note: mb_message should terminate with a quesiton mark; none * will be provided by this function. */bool Bull::UserSaysOk( nxsstring mb_message, nxsstring mb_title ){	cerr << endl;	cerr << mb_title << endl;	cerr << "  " << mb_message;	cerr << " (y/n) ";		cin.getline( next_command, COMMAND_MAXLEN );	bool yep  = ( next_command[0] == 'y' && next_command[1] == '\0' );	bool nope = ( next_command[0] == 'n' && next_command[1] == '\0' );		while( !yep && !nope )	{		cerr << endl;		cerr << "Must answer by typing either y or n and then pressing the Enter key" << endl;		cerr << endl;		cerr << mb_title << endl;		cerr << "  " << mb_message;		cerr << " (y/n) ";				cin.getline( next_command, COMMAND_MAXLEN );		yep  = ( next_command[0] == 'y' && next_command[1] == '\0' );		nope = ( next_command[0] == 'n' && next_command[1] == '\0' );	}		return yep;}/*double Bull::MaximizeLikelihoodAlreadyInitialized(Tree *t)	{	//this approach is an adaptation of Powell's method from Numerical recipes//the difference arises from the fact that there are quicker(?) optimizations of branch lengths, so branch lengths aren't//put into the vector of parameters to be optimized by powell's method, but I wanted to optimize them at the start of each loop of the method	int iter=0;	double prevlike;	paramAlterInfo->ResetDirections();	do	{prevlike=t->likelihood;		for(int i=0;i<paramAlterInfo->nBrLenParams;i++)			t->BranchLengthSmoothingPass(paramAlterInfo->GetBranchLengthOwner(i),paramAlterInfo->GetAffectedBrLen(i));				}	while(iter<LSettings->maxPasses && (t->likelihood-prevlike)<LSettings->delta);		return t->likelihood;}*/void Bull::WriteTaxaBlock(ofstream &tout){	assert(taxa);	tout<<"BEGIN TAXA;\nDIMENSIONS NTAX="<<taxa->GetNumTaxonLabels()<<";\nTAXLABELS\t";	for(int i=0;i<taxa->GetNumTaxonLabels();i++)		{nxsstring tempstr=taxa->GetTaxonLabel(i);		BlanksToUnderscores(tempstr);		tout<<tempstr;		if(i<ntaxa-1)			tout<<"\n\t\t\t";		else tout<<";\nENDBLOCK;\n";		}}