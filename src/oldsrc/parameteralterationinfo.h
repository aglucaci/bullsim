#ifndef PARAMATERALTERATIONINFO#define PARAMATERALTERATIONINFO#include "settings.h"#include "basicbulldefs.h"#include "datapartition.h"#include "likeattributes.h"#include "tree.h"#include <fstream.h>#include <iostream.h>class Bull;class TinyParamException : public MTHException{};/*this class is used for relatively quick access to a parameter, whenit isn't known if it will be an independent parameter, or might be a member of a paramgroup*/class ParamOrGroupPtr	{	Parameter *parPtr;	FreqParamGroup *groupPtr;	int paramInGroupIndex;	public :	bool isIndependent;	ParamOrGroupPtr(Parameter *p)				{groupPtr=NULL; parPtr=p; isIndependent=true;}	ParamOrGroupPtr(FreqParamGroup *pg,int i)				{groupPtr=pg; parPtr=NULL; isIndependent=false; paramInGroupIndex=i;}	double GetReparameterized()	{		if(isIndependent)			return parPtr->val;		return groupPtr->GetReparameterized(paramInGroupIndex);		}	bool SetReparameterized(double v)	{//will throw ParamOutOfRangeExcep(); if parameter is out of range		if(isIndependent)	parPtr->SetCurrent(v);		else 				groupPtr->SetReparameterized(paramInGroupIndex,v);		return true;		}	Parameter *GetParameter()	{if(isIndependent)	return parPtr;								return groupPtr->GetParameter(paramInGroupIndex);								}	FreqParamGroup *GetGroup()	{return groupPtr;}	bool 	HasMaximum()	{if(isIndependent)	return (parPtr->HasMax() | parPtr->HasUpperBound());							return true;							}	bool 	HasMinimum()	{if(isIndependent) return (parPtr->HasMin() | parPtr->HasLowerBound());							return true;							}	double GetReparameterizedMax()	{if(isIndependent)	return parPtr->GetLowerOfMaxOrUbound();	 									return groupPtr->GetReparameterizedMax(paramInGroupIndex);									}	double GetReparameterizedMin()	{if(isIndependent)	return  parPtr->GetHigherOfMinOrLbound();									return groupPtr->GetReparameterizedMin(paramInGroupIndex);									}	};/*	this class is designed to speed up the maximization of like or running of a chain by storing info on all of the parameters that are being optimized/integrated outthe affectedModelsInfo store info on what partition/models need to have their likelihoods recalculated when a parameter's value changes.  the type of the parameter specifies is from the par enumeration in parameter.h and specifiesthe whether their is a max, min, etc.for model parameters a pointer is stored to the actual parameter.for branch lengths (and modifiers) the parameters are in the likeAttributes of the Nodes of a tree	and ParameterAlterationInfo just stores info on what partition "owns" them so they are only modified once	per round	NOTE the getting elements out of vecTypeOfParam and affectedModelsInfo requires knowing nModParams,nBrLenParams,nBrLenModParams*/typedef vector<PartModIndex> vecPMI;typedef vector<int> vecInts;	class ParameterAlterationInfo	{	int currVecIndex;	vector<vecInts> vecOfRelatedParams;	vector<vecPMI> affectedModelsInfo;//for all types of parameters	vector<int> vecTypeOfParam;//for all types of parameters		vector<Parameter *> vecModParam;	vector<FreqParamGroup *> vecFreqParamGroups;	vector<PartModIndex> branchLengthOwners;	vector<PartModIndex> modelsWithRateModifiers;	vector<int> numModifiersOwned;	vector<int> modMixing;	Bull *bullPtr;/*the following doubles are used for maximization, note that member of FreqParamGroups are reparameterizedto each go from 0 to 1*/	double *oldParamVals,*PowellParamVals,*PrevScoredVals,*BrentParamVals,**directions,*netDirection,*currDirection,*reparamDirection,*beforeRelatedParam;	double **smallDir;	double **linearAlgWorkSpace;	ParamOrGroupPtr **parOrGroupPArray;	int	*affectedConversionIndex;	bool optimizingBrLens;	int powellRound;	bool loggingEachStep;	int parDirsToSkip,parGroupsToSkip,branchesToSkip;int currpos;	public :		int nModParams,nFreqParamGroups,nBrLenParams,nBrLenModParams,nModMix;/*I'm currently maximizing branch lengths in a different way than other params, so I need to know how many other params there are (nMaximizedParams), note that this counts each independent member of a FreqParamGroup (not just one for the whole group)*/	int nMaximizedParams;	int nTimesNearMaxDist;	Tree *tree;		ParameterAlterationInfo(LikeSettings *ls,DataPartition **dps,SetOfTreeLikeAttr *tsla,Tree *t,Bull *b);	~ParameterAlterationInfo();	vector<PartModIndex> *GetAffectedMod(int i);	vector<PartModIndex> *GetAffectedFreq(int i);	vector<PartModIndex> *GetAffectedBrLen(int i);	PartModIndex 			GetBranchLengthOwner(int i)	{return branchLengthOwners[i];}	vector<PartModIndex> *GetAffectedBrLenMod(int i);	vector<PartModIndex> *GetAffectedModMix(int i);	void NotifyModelOfChangedParameter(int cm);	void NotifyModelsThatFreqParamChangesAreDone(int cm,FreqParamGroup *fpg);	//functions for maximizing likelihood	void ResetDirections();	double PowellMaximization(int maxPasses,double delta);	bool UpdateParams();	void LinearBrent(int maxPasses,double delta);	void MoveBrentValsAlongLineFromPowellVals(double coeff);	//bool PositiveCoefficientTowardMinimum(double d);	void GetBracket(double *a, double *b, double *c,double *ascore,double *bscore,double *cscore);	bool CanMove(bool dir);	double GetMaxLegalCoeff(double pt,bool dir);	double GetAbsValOfCoeffRelativeToMostSensParam(double pt);	void MoveToFirstSignificantlyDifferentSpot(double* current,double *future,double* currscore,double *futurescore,double stepSize,double maxDist);	bool ThereIsABoundOnMovement(bool dir);	void GetBracketFromThisDirection(double maxDist,double stepSize,int numPtsToTrust,double *a, double *b, double *c,double *ascore,double *bscore,double *cscore);	void ResetToPowellValues();	void ScoreBrentVals(double coeff);	void UpdateButDontScore(double coeff,double prevscore);	void CreateThirdPointInMiddle(double *a,double *b,double *c,double *ascore,double *bscore,double *cscore);	double ExtremeValueOfCoeff(bool dir);	void SetPowellValsToBrent();	void NotifyModelForEveryParameterInCurrDirection();	double *GetReparameterizedDirection(int i);	void ReparameterizeThisFreqGroup(int firstmem,int dir,int n);	void GeneralizeDirection(double *);	void GeneralizeThisGroup(int firstmem,int n,double *dest);	bool HasAtLeastOneNonZeroDir(double *d);	bool HasAtLeastTwoNonZeroDir(double *d);	bool DoesntReplicateACurrentDir(double *d);};template <class T>bool vecContainSameElements(vector<T> *fir,vector<T> *sec);double GetReasonableStepSize(double maxDist,double stepSize,double pt);#endif