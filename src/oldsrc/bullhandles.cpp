#include "AdvancedBullDefs.h"#include "bull.h"#include <sioux.h>#include <profiler.h>#include "setreader.h"using namespace std; //introduces namespace stddouble EuclideanDistance(int arrSize,double *f,double *s);void NormalizeGTRParams(double *curr,double *currNorm);double DistanceRateParamsMoved(double *curr,double *prev);void Bull::HandleCodLikeStartVal(NexusToken& token ){	if(!DSettings)			{errormsg="You can't specify likelihood settings without an active data file";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}	//Negative values mean after parsing the command mean you must get previous/default values	int currbrlen=-1,nst=-1,naa=-1;	double *sharedModParam,kapp=-1.0;	sharedModParam=new double [10];	for(int i=0;i<10;i++)		sharedModParam[i]=-1.0;	double **aafreq,*mults;	double treesc=1.0;	int code=gencode(mito);#ifdef ALLOWMULTIHITS	double mh=0.0;#endif		aafreq=NULL;	mults=NULL;	delete[] previousLikelihoods;	previousLikelihoods=NULL;	nParamDirectionsToSkip=0;	nParamGroupsToSkip=0;	nBranchesToSkip=0;	workingOnBranches=false;	paramImprovThisRound=0.0;	ParseCodLikeStartValCommand(token,currbrlen,nst,naa,sharedModParam,kapp,aafreq,mults,treesc,code);		//TEMPORARY should be modified to allow parameter/options to be persistent	if(nst==1)			{sharedModParam[3]=sharedModParam[4]=sharedModParam[5]=sharedModParam[6]=sharedModParam[7]=sharedModParam[8]=1.0;}	else	if(nst==2)			{if(kapp<-1)				{if(sharedModParam[3]<0.0)				{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Kappa must be specified  option to CodLikeStartVal command");}			else	if(fabs(sharedModParam[3]-sharedModParam[5])>0.00001 || fabs(sharedModParam[3]-sharedModParam[6])>0.00001|| fabs(sharedModParam[3]-sharedModParam[8])>0.00001 || fabs(sharedModParam[4]-sharedModParam[7])>0.00001)					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("The specified rmatrix doenst conform to K2P in CodLikeStartVal command");}			sharedModParam[4]/=sharedModParam[3];			sharedModParam[7]/=sharedModParam[3];			sharedModParam[3]=sharedModParam[4]=sharedModParam[5]=sharedModParam[8]=1.0;			}		else			{sharedModParam[3]=sharedModParam[5]=sharedModParam[6]=sharedModParam[8]=1.0;			sharedModParam[4]=sharedModParam[7]=kapp;			}		}	else	if(nst==6)		{if(sharedModParam[3]<0.0)			{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("RMatrix must be specified  option to CodLikeStartVal command");}		}	else	if(kapp<0.0)				{if(sharedModParam[3]<0.0)					{sharedModParam[3]=sharedModParam[4]=sharedModParam[5]=sharedModParam[6]=sharedModParam[7]=sharedModParam[8]=1.0;}				}	else	{sharedModParam[3]=sharedModParam[5]=sharedModParam[6]=sharedModParam[8]=1.0;			sharedModParam[4]=sharedModParam[7]=kapp;			}	if(sharedModParam[1]<0.0)	{sharedModParam[0]=sharedModParam[1]=sharedModParam[2]=0.25;}	if(naa<1)		{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("You must specify the number of amino acid freqs in CodLikeStartVal command");}	if(nchars%(3*naa))		{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Right now the number of characters must be a multiple of the number of amino acid freqs in CodLikeStartVal command");} #ifdef	ALLOWMULTIHITS	sharedModParam[9]=mh;#endifModel **arrOfMods;	arrOfMods=new Model*[naa];#ifdef CODONHACK	modArr=new SSRFCodonSubMod*[naa];	sizeOfModArr=naa;	CreateSetOfSSRFCodonSubMods(naa,sharedModParam,aafreq,modArr,mults,treesc,code);	for(int k=0;k<naa;k++)		arrOfMods[k]=(Model *)modArr[k];#else	CreateSetOfSSRFCodons(naa,sharedModParam,aafreq,arrOfMods,code);#endif	DSettings->SeparateIntoCharPartititonsOfLengthN(nchars/naa);	LSettings->RefreshPartitions();	PSettings->RefreshPartitions();	LSettings->ReplaceModels(naa,arrOfMods);	delete []arrOfMods;	delete []sharedModParam;}void Bull::ParseCodLikeStartValCommand(NexusToken& token,int& currbrlen,int& nst,int& naa,	double *&sharedModParam,double& kapp,double **&aafreq,double *&mults,double& treesc,int &code){	token.GetNextToken();	while(token.GetToken()!=";")		{bool needsAnother=true;		if(token.Abbreviation("CURREntbranchlengths") || token.Abbreviation("CURRBranchlengths"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")				{token.GetNextToken();				if(token.Abbreviation("No"))					currbrlen=0;				else 	if(token.Abbreviation("Yes"))							currbrlen=1;						else	{while(token.GetToken()!=";")	token.GetNextToken();								delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);								throw XNexus("Expecting YES or NO after CurrentBranchLengths = option to CodLikeStartVal command");								}				token.GetNextToken();				}			else	{currbrlen=1;needsAnother=false;}			}		else	if(token.Abbreviation("LASTParamimprovement"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			lastParamImprov=atof(token.GetToken().c_str());			if(lastParamImprov<0.0)				{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("lastParamImprov  must be >=0.0 CodLikeStartVal command");				}			}		else	if(token.Abbreviation("PARAMIMPROVEThisround"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			paramImprovThisRound=atof(token.GetToken().c_str());			if(lastParamImprov<0.0)				{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("paramImprovThisRound  must be >=0.0 CodLikeStartVal command");				}			}		else	if(token.Abbreviation("LASTBranchimprovement"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			lastBranchImprov=atof(token.GetToken().c_str());			if(lastParamImprov<0.0)				{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("lastBranchImprov  must be >=0.0 CodLikeStartVal command");				}			}		else	if(token.Abbreviation("GRoupskip"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			nParamGroupsToSkip=(int) token.GetLongEquivalent();			if(nParamGroupsToSkip<0)					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("Expecting positive number before Groupskip option to CodLikeStartVal command");					}			}		else	if(token.Abbreviation("PARAMskip"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			nParamDirectionsToSkip=(int) token.GetLongEquivalent();			if(nParamDirectionsToSkip<0)					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("Expecting positive number before Paramskip option to CodLikeStartVal command");					}			}		else	if(token.Abbreviation("BRanchskip"))			{ifstream branchSkip;			int maxBrLenFileNum=GetHighestFileNum("NumBranchesOptimized");			nxsstring fname="NumBranchesOptimized";			fname+=maxBrLenFileNum;			branchSkip.open(fname.c_str());			branchSkip>>nBranchesToSkip;			branchSkip.close();			workingOnBranches=true;			if(nBranchesToSkip>0)				{int maxBranchesOnThisTree=treelist[0]->GetNumBranches();				assert(maxBranchesOnThisTree!=nBranchesToSkip);				assert(treelist.size()==1);				double *optBranchLengths;				optBranchLengths=new double[nBranchesToSkip];				nxsstring sname="NumBranchesOptimized";				sname+=maxBrLenFileNum;				branchSkip.open(sname.c_str());				for(int i=0;i<nBranchesToSkip;i++)					branchSkip>>optBranchLengths[i];				assert(branchSkip.good());				branchSkip.close();				treelist[0]->UpdateBranchesInRecursiveOrder(optBranchLengths,nBranchesToSkip);				delete [] optBranchLengths;				optBranchLengths=NULL;				if(naa<0)					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("Expecting BranchSkip after aafreqs  option to CodLikeStartVal command");					}				nxsstring tname="BranchLengthsLikelihoods";				tname+=maxBrLenFileNum;				branchSkip.open(tname.c_str());				char tempstr[80];				tempstr[0]='\0';				for(int i=0;i<nBranchesToSkip;i++)					{while(strcmp(tempstr,"Branch"))						branchSkip>>tempstr;					branchSkip>>tempstr;					}				if(previousLikelihoods)					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("Expecting BranchSkip instead of prevlike  option to CodLikeStartVal command");					}				previousLikelihoods=new double[naa];				assert(atoi(tempstr)==nBranchesToSkip);				for(int ii=0;ii<naa;ii++)					branchSkip>>previousLikelihoods[ii];				branchSkip.close();					}			}		else	if(token.Abbreviation("GEneticCode"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			if(token.Abbreviation("Mitochondrial"))				code=gencode(mito);			else				if(token.Abbreviation("Nuclear"))					code=gencode(nuc);				else 					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("Expecting either Mito or Nuclear code");					}							}		else	if(token.Equals("nst"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			if(token.Equals("1") || token.Equals("2") || token.Equals("6"))				nst=token.GetLongEquivalent();			else	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);					throw XNexus("Expecting 1 , 2 or 6 after nst option to CodLikeStartVal command");					}			}		else	if(token.Abbreviation("BASEfreq"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			if(!token.Equals("("))	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ( after basefreq option to CodLikeStartVal command");}			for(int i=0;i<3;i++)				{token.GetNextToken();				sharedModParam[i]=atof(token.GetToken().c_str());				if(sharedModParam[i]<=0.0)	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("basefreqs must be >0.0 CodLikeStartVal command");}				}			if(sharedModParam[1]+sharedModParam[2]+sharedModParam[0]>=1.0)				{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Sum of A, C, and G must be <1.0 CodLikeStartVal command");}			token.GetNextToken();			if(!token.Equals(")"))	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ) after basefreq option to CodLikeStartVal command");}			}		else	if(token.Abbreviation("RMATrix"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			if(!token.Equals("("))	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ( after rmatrix option to CodLikeStartVal command");}			for(int i=0;i<6;i++)				{token.GetNextToken();				sharedModParam[3+i]=atof(token.GetToken().c_str());				if(sharedModParam[3+i]<=0.0)						{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);						throw XNexus("rmatrix  must be >0.0 CodLikeStartVal command");}				}			token.GetNextToken();			if(!token.Equals(")"))	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ) after rmatrix  option to CodLikeStartVal command");}			}		else	if(token.Abbreviation("KAPpa"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			kapp=atof(token.GetToken().c_str());			if(kapp<0.0)	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("kappa  must be >0.0 CodLikeStartVal command");}			}#ifdef	ALLOWMULTIHITS		else	if(token.Abbreviation("DOublehit"))//not a great name, but allows multiplier abbreviation to work			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			mh=atof(token.GetToken().c_str());			if(mh<0.0)	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("MultipleHitProb  must be >=0.0 CodLikeStartVal command");}			}#endif		else	if(token.Abbreviation("AAFreq"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			if(!token.Equals("("))					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ( after aafreq option to CodLikeStartVal command");}			token.GetNextToken();			if(!token.IsInteger())					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting number of codons after aafreq=( option to CodLikeStartVal command");}			naa=token.GetLongEquivalent();			if(naa<1)					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("number of codons must be >0 in  CodLikeStartVal command");}			aafreq=new_RectMats(naa,20);			for(int ii=0;ii<naa;ii++)				{token.GetNextToken();				if(!token.Equals("("))						{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ( for next site in aafreq option to CodLikeStartVal command");}				for(int j=0;j<20;j++)					{token.GetNextToken();					aafreq[ii][j]=atof(token.GetToken().c_str());					if(aafreq[ii][j]<0.0)							{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("each amino acid freq  must be >0.0 CodLikeStartVal command");}					}				token.GetNextToken();				if(!token.Equals(")"))						{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ) for next site in aafreq option to CodLikeStartVal command");}				}			token.GetNextToken();			if(!token.Equals(")"))	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ) after aafreq  option to CodLikeStartVal command");}			}		else	if(token.Abbreviation("MUlt"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			if(!token.Equals("("))					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ( after mult option to CodLikeStartVal command");}			if(naa<1)					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("number of codons must be specified before the mult option is used in CodLikeStartVal command");}			mults=new double[naa];			for(int ii=0;ii<naa;ii++)				{token.GetNextToken();				mults[ii]=atof(token.GetToken().c_str());				if(mults[ii]<0.0)							{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("multiplier  must be >0.0 CodLikeStartVal command");}				}			token.GetNextToken();			if(!token.Equals(")"))	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ) after mult  option to CodLikeStartVal command");}			}		else	if(token.Abbreviation("PRevlike"))			{if(naa<1)					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("number of codons must be specified before the mult option is used in CodLikeStartVal command");}			if(previousLikelihoods)	delete[] previousLikelihoods;			previousLikelihoods=new double [naa];			token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			if(!token.Equals("("))					{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ( after prevlike option to CodLikeStartVal command");}			if(workingOnBranches && previousLikelihoods)				{for(int ii=0;ii<naa;ii++)					token.GetNextToken();				}			else				{previousLikelihoods=new double[naa];				for(int ii=0;ii<naa;ii++)					{token.GetNextToken();					previousLikelihoods[ii]=atof(token.GetToken().c_str());							}				}			token.GetNextToken();			if(!token.Equals(")"))	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("Expecting ) after prevLike  option to CodLikeStartVal command");}			}		else	if(token.Abbreviation("TReescale"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			treesc=atof(token.GetToken().c_str());			if(treesc<0.0)	{delete []mults; delete [] previousLikelihoods; previousLikelihoods=NULL;free_RectMats(aafreq);	throw XNexus("The Tree scaling  must be >0.0 CodLikeStartVal command");}			}		if(needsAnother)	token.GetNextToken();		}}void Bull::HandleContinueAnalysis( NexusToken& token ){	bool name_provided = false;		// Retrieve all tokens for this command, stopping only in the event	// of a semicolon or an unrecognized keyword	//	for(;;)	{		token.GetNextToken();		if( token.Equals(";") ) {			break;		}		else if( token.Abbreviation("File") ) {			commandFileTag = GetFileName(token);			name_provided = true;		}		else {			errormsg = "Unexpected keyword (";	      errormsg += token.GetToken();	      errormsg += ") encountered reading LOG command";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}   }      	// If this far, must be attempting to open a log file	//	if( !name_provided ) {		errormsg = "Must provide a file name when continuing an analysis\n";		errormsg += "e.g., continue file=doofus;";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}   		commandFileNum=GetHighestFileNum(commandFileTag);		if(commandFileNum<0)		{errormsg = "Couldn't open file ";		errormsg += commandFileTag;		errormsg += "0";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}   	/*nxsstring tempstr="log file=";	tempstr+=commandFileTag;		tempstr+=(commandFileNum+1);	strcpy(next_command,tempstr.c_str());	PreprocessNextCommand();		istrstream lcmdin( next_command );//HandleNext Command without the catch statement, so any errors will get thrown to higher level	NexusToken ltoken(lcmdin);	Read( ltoken );	*/	logEachStep=true;		nxsstring tempstr="executebull "	;	tempstr+=commandFileTag;		tempstr+=commandFileNum;	commandFileNum++;	strcpy(next_command,tempstr.c_str());	PreprocessNextCommand();	istrstream ecmdin( next_command );//HandleNext Command without the catch statement, so any errors will get thrown to higher level	NexusToken etoken(ecmdin);	Read( etoken );	}/** * @method HandleEndblock [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called when the END or ENDBLOCK command needs to be parsed * from within the Bull block.  Basically just checks to make * sure the next token in  the data file is a semicolon. */void Bull::HandleEndblock( NexusToken& token ){	// get the semicolon following END or ENDBLOCK token   //	token.GetNextToken();		if( !token.Equals(";") ) {		errormsg = "Expecting ';' to terminate the END or ENDBLOCK command, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}}/** * @method HandleExecute [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Handles everything after the EXecute keyword and the terminating * semicolon.  Flushes all blocks before executing file specified, * and no warning is given of this */void Bull::HandleExecute( NexusToken& token ){	// Issuing the EXECUTE command from within a file is a no-no   //	if( inf_open ) {		errormsg = "Cannot issue execute command from within a Bull block";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		//HandleExecuteBullBlocksInFile(token);		return;	}		// Get the file name to execute   //	token.GetNextToken();		nxsstring fn = token.GetToken();	// get the semicolon terminating the EXECUTE command   //	token.GetNextToken();		if( !token.Equals(";") ) {		errormsg = "Expecting ';' to terminate the EXECUTE command, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}	// Before going through with this, make sure we're not going to overwrite 	// any stored blocks	bool stuff_stored = !taxa->IsEmpty();	stuff_stored = ( stuff_stored || !trees->IsEmpty() );	stuff_stored = ( stuff_stored || !assumptions->IsEmpty() );	stuff_stored = ( stuff_stored || charordata );	if( stuff_stored && UserSaysOk( "Ok to delete?", "Data has already been read and stored" ) )		PurgeBlocks();	else if( stuff_stored ) {		message = "\nExecute command aborted.";		PrintMessage();		return;	}	cerr << endl;	cerr << "Opening " << token.GetToken() << "..." << endl;		ifstream inf( fn.c_str(), ios::binary );	inf_open = true;	NexusToken ftoken(inf);		try {		Execute( ftoken );	}		catch( XNexus x ) 	{		if(errormsg.length()==0)				NexusError( x.msg, x.pos, x.line, x.col );		else	NexusError( errormsg, x.pos, x.line, x.col );      Reset();	}		if( inf_open )		inf.close();	inf_open = false;		if( purged && !taxa->IsEmpty() ) {		purged=false;		//cerr << "  TAXA block found" << endl;		if( logf_open )			taxa->Report(logf);		FinishTaxaBlock();		if(!trees->IsEmpty())			FinishTreesBlock();		if(!data->IsEmpty())			{if(!characters->IsEmpty()) throw XNexus("Can't have both a characters and data block", token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			charordata=data;			FinishCharactersBlock();			}		else if(!characters->IsEmpty())			{charordata=characters;			FinishCharactersBlock();			}		if(!assumptions->IsEmpty() )			FinishAssumptionsBlock();	}	if( !trees->IsEmpty() ) {		//cerr << "  TREES block found" << endl;		if( logf_open )			trees->Report(logf);	}	if( !assumptions->IsEmpty() ) {		//cerr << "  ASSUMPTIONS block found" << endl;		if( logf_open )			assumptions->Report(logf);	}	if( !characters->IsEmpty() ) {		//cerr << "  CHARACTERS block found" << endl;		if( logf_open )			characters->Report(logf);		charordata=characters;	}		if( !data->IsEmpty() ) {		if(!characters->IsEmpty() ) throw XNexus("Cannot define both a characters and a data block" );		//cerr << "  DATA block found" << endl;		if( logf_open )			data->Report(logf);		charordata=data;	}}void Bull::HandleExecuteBullBlocksInFile( NexusToken& tok ){	//only allows bull block commands to be executed (not other blocks)	// Get the file name to execute   //	tok.GetNextToken();	nxsstring fn = tok.GetToken();	// get the semicolon terminating the EXECUTE command   //	tok.GetNextToken();		if( !tok.Equals(";") ) {		errormsg = "Expecting ';' to terminate the EXECUTE command, but found ";      errormsg += tok.GetToken();      errormsg += " instead";		throw XNexus( errormsg, tok.GetFilePosition(), tok.GetFileLine(), tok.GetFileColumn() );	}	ifstream inf( fn.c_str(), ios::binary );	NexusToken ftoken(inf);	nxsstring ferrormsg;   ftoken.GetNextToken();	if( !ftoken.Equals("#NEXUS") ) {      ferrormsg = "Expecting #NEXUS to be the first token in the file, but found ";      ferrormsg += ftoken.GetToken();      ferrormsg += " instead";		throw XNexus( ferrormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );	}		ExecuteStarting();		for(;;)	{	ftoken.SetLabileFlagBit( NexusToken::saveCommandComments );		ftoken.GetNextToken();		if( ftoken.AtEOF() )			break;		if( ftoken.Equals("BEGIN") )			{			ftoken.GetNextToken();			if(ftoken.Equals( "BULL") )				{EnteringBlock( ftoken.GetToken() );            	ftoken.GetNextToken();				if( !ftoken.Equals(";") ) 					{ferrormsg = "Expecting ; AFTER BEGIN BULL ";			      	throw XNexus( ferrormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );				  	}				for(;;)            		{ftoken.GetNextToken();					if( ftoken.Abbreviation("ENdblock") ) 						{HandleEndblock( ftoken );						break;						}					else if( ftoken.Abbreviation("Quit") ) 						{message = "\nIgnoring Quit command from non-primary file\n";						PrintMessage();						break;						}					TryAdvancedCommands(ftoken);					}				}			else				{           		 nxsstring currBlock = ftoken.GetToken();				SkippingBlock( currBlock );				for(;;)				{					ftoken.GetNextToken();					if( ftoken.Equals("END") || ftoken.Equals("ENDBLOCK") ) {						ftoken.GetNextToken();						if( !ftoken.Equals(";") ) {							ferrormsg = "Expecting ';' after END or ENDBLOCK command, but found ";                    		ferrormsg += ftoken.GetToken();                     		ferrormsg += " instead";							throw XNexus( ferrormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );						}						break;					}					if( ftoken.AtEOF() ) {						ferrormsg = "Encountered end of file before END or ENDBLOCK in block ";                  		ferrormsg += currBlock;						throw XNexus( ferrormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );                  		}				}			} // if token not found amongst known block IDs		} // if token equals BEGIN	} // for(;;)		ExecuteStopping();}void Bull::HandleGetTrees(NexusToken& token ){	if(!taxa)			{errormsg="You can't get trees without an active set of taxa";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}	nxsstring filename,filePref;	bool readingMostRecent=false;	long fromTree=-1,toTree=-1,mode=7;	token.GetNextToken();	while(token.GetToken()!=";")		{if(token.Abbreviation("STOREBrlens"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")				{token.GetNextToken();				if(token.Abbreviation("No"))					storebrlens=false;				else 	if(token.Abbreviation("Yes"))							storebrlens=true;						else	{errormsg="Expecting YES or NO after CurrentBranchLengths = option to LSCORE command";								throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );								}				token.GetNextToken();				}			else	storebrlens=true;			}		if(token.Abbreviation("FRom"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")	token.GetNextToken();			if(token.IsInteger())		fromTree=token.GetLongEquivalent();			if(fromTree<0)				{errormsg="Expecting positive integer after FROM option of GETTREES";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}				}		if(token.Abbreviation("To"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")	token.GetNextToken();			if(token.IsInteger())		toTree=token.GetLongEquivalent();			if(toTree<0)				{errormsg="Expecting positive integer after TO option of GETTREES";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}				}		if(token.Abbreviation("Mode"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")	token.GetNextToken();			if(token.IsInteger())		mode=token.GetLongEquivalent();			else	{errormsg="Expecting positive integer after MODE option of GETTREES";					throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );					}			if(mode!=3 && mode!=7)				{errormsg="Right now bull only get trees with mode 3 or mode 7";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}				}		if(token.Abbreviation("FIle"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")					token.GetNextToken();			filename=token.GetToken();			}		if(token.Abbreviation("PREfix"))			{token.GetNextToken();			if(token.GetToken()=="=")					token.GetNextToken();			filePref=token.GetToken();			}		if(token.Abbreviation("MOStrecent"))			readingMostRecent=true;		token.GetNextToken();		}		if(readingMostRecent)		{int highNum=GetHighestFileNum(filePref);		if(highNum<0)			{errormsg = "Couldn't open file "; errormsg += filePref; errormsg += "0";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			}  		filename=filePref;		filename+=highNum;		}		ifstream treefile(filename.c_str());	if(!treefile.good())	{errormsg="Couldn't open the file "; errormsg+=filename;							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}	MyNexus tempNexus(this);	TreesBlock tempTree(*taxa);	tempNexus.Add(&tempTree);	NexusToken ftoken(treefile);	try {		tempNexus.Execute( ftoken );		}	catch( XNexus x ) 		{		if(errormsg.length()==0)				tempNexus.NexusError( x.msg, x.pos, x.line, x.col );		else	tempNexus.NexusError( errormsg, x.pos, x.line, x.col );		}	if( treefile.good() )		treefile.close();	if(tempTree.IsEmpty())		{errormsg="No Trees Block found in "; errormsg+=filename;		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}	int ntreesInFile=tempTree.GetNumTrees();	if(ntreesInFile<1)		{errormsg="No Trees found in "; errormsg+=filename;		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}	if(fromTree>toTree)		if(toTree<0)	toTree=ntreesInFile-1;		else {errormsg="Cant get Trees from "; errormsg+=fromTree; errormsg+=" to "; errormsg+=toTree;			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			}	if(fromTree<1)	fromTree=0;	else			fromTree--;	if(toTree==0)	toTree++;	if(toTree>ntreesInFile || toTree==-1)	toTree=ntreesInFile;	if(fromTree>toTree)		if(toTree<0)	toTree=ntreesInFile-1;		else {errormsg="Cant get Trees from "; errormsg+=fromTree; errormsg+=" to "; errormsg+=toTree;			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			}	vector<Tree *> treesToBeAdded;	for(int i=fromTree;i<toTree;i++)		{		Tree *temptree;		if(storebrlens)	temptree=new Tree(tempTree.GetTranslatedTreeDescription(i));		else	temptree=new Tree(tempTree.GetTranslatedTreeDescription(i),false);		if(!temptree->IsGood())				{for(int j=0;j<=i-fromTree;j++)				delete treesToBeAdded[j];			errormsg="Problem Reading Tree Description of  "; errormsg+=tempTree.GetTreeName(i);			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			}		nxsstring s=tempTree.GetTreeName(i);		ToUpper(s);		temptree->SetName(s);		if(charordata)//either characters or data are read in			temptree->AssignDataToTerm(taxa, rawData);		treesToBeAdded.push_back(temptree);		}	message="";	message+=(int)(toTree-fromTree); 	message+=" trees read from "; message+=filename;		if(mode==3)		{if(treelist.size()>0)			message+="\nReplacing trees currently in memory.";		for(int i=0;i<treelist.size();i++)			delete treelist[i];		treelist.erase(treelist.begin(),treelist.end());		ntrees=0;		}	else	if(treelist.size()>0)	message+="\nAppending to trees currently in memory.";	for(int i=0;i<treesToBeAdded.size();i++)		{treelist.push_back(treesToBeAdded[i]);		ntrees++;		}	message+="\n"; message+=((int) ntrees); message+=" trees now in memory.";	PrintMessage();	}void Bull::HandleLscore(NexusToken& token ){	if(!LSettings)			{errormsg="You can't score under likelihood without an active data file";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}	if(treelist.empty())	{errormsg="You can't score under likelihood without a tree in memory";							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}	criterion=criteria(maxLike);	token.GetNextToken();	assert(LSettings);	assert(DSettings);	bool dontModifyBLens=false;	Tree *temptre;	vector<Tree *> toscoreT;	vector<nxsstring> toscoreN;	while(token.GetToken()!=";")		{if(token.Abbreviation("CURREntbranchlengths") || token.Abbreviation("CURRBranchlengths"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")				{token.GetNextToken();				if(token.Abbreviation("No"))					LSettings->SetUseCurrentBrLen(false);				else 	if(token.Abbreviation("Yes"))							LSettings->SetUseCurrentBrLen(true);						else	{errormsg="Expecting YES or NO after CurrentBranchLengths = option to LSCORE command";								throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );								}				token.GetNextToken();				}			else	LSettings->SetUseCurrentBrLen(true);			}		if(token.IsInteger())			{long tn=token.GetLongEquivalent();			if(tn>ntrees || tn<1)				{errormsg="Tree ";				errormsg+=token.GetToken();				errormsg+=" unknown.  Lscore aborted.";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}			temptre=treelist[tn-1];			}		else			{try 				{temptre=FindTreeFromName(token.GetToken());				}			catch (NoSuchTree)				{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  Lscore aborted.";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}			}		toscoreN.push_back(token.GetToken());//keeps track of what the user called the tree		toscoreT.push_back(temptre);		token.GetNextToken();		}	if(toscoreT.empty())		for(int i=0;i<treelist.size();i++)			{toscoreT.push_back(treelist[i]);			toscoreN.push_back(i);			}	time_t bef,aft;	for(int i=0;i<toscoreT.size();i++)		{double x;		if(LSettings->AllStationaryModels())			{bool isFirstParamRound=true;			x=InitialLScore(toscoreT[i]);			bef=time(NULL);			double befOptLike;			if(LSettings->maximize)				{if(workingOnBranches)//codonhack only					{// in the middle of branch length optimization					//likeAtBegOfThisRound=befOptLike=toscoreT[i]->likelihood;					EliminateAminoAcidsThatHaveFreqZero(toscoreT[i]);					double improv=toscoreT[i]->BranchLengthSmoothingPass(PartModIndex(0,0),NULL,LSettings->maxPasses,LSettings->delta,nBranchesToSkip);					likeAtBegOfThisRound=befOptLike=toscoreT[i]->likelihood+improv;					workingOnBranches=false;nBranchesToSkip=0;					FakeACommand("UpdateBranchLengths");					WriteLogFileForCurrentPosition(0,0);					assert(0);					lastBranchImprov=befOptLike-toscoreT[i]->likelihood;					}				else if(nParamGroupsToSkip>0 || nParamDirectionsToSkip>0)					{//in the middle of parameter optimization					likeAtBegOfThisRound=toscoreT[i]->likelihood+paramImprovThisRound;					CreateParameterAlterationInfo(toscoreT[i]->GetLikeAttributes(),toscoreT[i]);					EliminateAminoAcidsThatHaveFreqZero(toscoreT[i]);					paramAlterInfo->PowellMaximization(LSettings->maxPasses,LSettings->delta);					nParamGroupsToSkip=nParamDirectionsToSkip=0;					lastParamImprov=likeAtBegOfThisRound-toscoreT[i]->likelihood;					isFirstParamRound=false;					}								//repeat the optimization that provided the best improvement last time				while(lastBranchImprov>0.1 || lastParamImprov>0.1)					{likeAtBegOfThisRound=toscoreT[i]->likelihood;					if(lastBranchImprov>=lastParamImprov)						{if(paramAlterInfo)							{delete paramAlterInfo;							paramAlterInfo=NULL;							}						WriteLogFileForCurrentPosition(0,0,true);						int branchOptLogNum=GetHighestFileNum("NumBranchesOptimized");						Node::branchLengthOptLogNum=branchOptLogNum+1;						nxsstring fname="NumBranchesOptimized";						fname+=Node::branchLengthOptLogNum;						ofstream	newNBO;						newNBO.open(fname.c_str());						newNBO<<"0"<<endl;						newNBO.close();						//befOptLike=toscoreT[i]->likelihood;						EliminateAminoAcidsThatHaveFreqZero(toscoreT[i]);						cout<<"About To Start Branch Length Optimization."<<endl;						double improv=toscoreT[i]->BranchLengthSmoothingPass(PartModIndex(0,0),NULL,LSettings->maxPasses,LSettings->delta,nBranchesToSkip);						likeAtBegOfThisRound=befOptLike=toscoreT[i]->likelihood+improv;						cout<<"Branch Length Optimization is completed.  Improved "<<improv<<endl;						FakeACommand("UpdateBranchLengths");						WriteLogFileForCurrentPosition(0,0);						lastBranchImprov=befOptLike-toscoreT[i]->likelihood;						}					else						{WriteLogFileForCurrentPosition(0,0);						/* TEMPORARY						if(!isFirstParamRound)							if(NeedToBeginAgainBecauseStateSpaceGrew(toscoreT[i]))								{throw MTHException("Need to restart because the model grew");}						*/						if(!paramAlterInfo)							CreateParameterAlterationInfo(toscoreT[i]->GetLikeAttributes(),toscoreT[i]);						EliminateAminoAcidsThatHaveFreqZero(toscoreT[i]);						cout<<"About To Start Parameter Optimization."<<endl;						paramAlterInfo->PowellMaximization(LSettings->maxPasses,LSettings->delta);						cout<<"Parameter Optimization is completed"<<endl;						lastParamImprov=likeAtBegOfThisRound-toscoreT[i]->likelihood;						isFirstParamRound=false;						}					}				}								}		else throw IncompleteModel("Non stationary models aren't implemented yet");				/*cout<< "Ln Likelihood score of "<<toscoreN[i]<<" is "<<x<<endl;		logf<< "Ln Likelihood score of "<<toscoreN[i]<<" is "<<x<<endl;		aft=time(NULL);		cout<<"maximization took "<<difftime(aft,bef)<<" seconds and "<<Tree::timesscored<<" scorings"<<endl;		cout<<"BEGIN TREES;\n";		toscoreT[i]->Print(cout,true);		cout<<"end;\n\nBEGIN PAUP;";		toscoreT[i]->PrintModel(cout);		cout<<"end;"<<endl;*/		}	delete []previousLikelihoods;	previousLikelihoods=NULL;	}void Bull::HandleLset(NexusToken& token ){	if(!LSettings)			{errormsg="You can't specify likelihood settings without an active data file";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}		delete []previousLikelihoods;	previousLikelihoods=NULL;		token.GetNextToken();	while(token.GetToken()!=";")		{if(token.Abbreviation("CURREntbranchlengths") || token.Abbreviation("CURRBranchlengths"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")				{token.GetNextToken();				if(token.Abbreviation("No"))					LSettings->SetUseCurrentBrLen(false);				else 	if(token.Abbreviation("Yes"))							LSettings->SetUseCurrentBrLen(true);						else	{while(token.GetToken()!=";")	token.GetNextToken();								throw XNexus("Expecting YES or NO after CurrentBranchLengths = option to LSCORE command");								}				token.GetNextToken();				}			else	LSettings->SetUseCurrentBrLen(true);			}		token.GetNextToken();		}	}/** * @method HandleLog [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called when the LOG command needs to be parsed * from within the Bull block. */void Bull::HandleLog( NexusToken& token ){	bool starting = false;	bool stopping = false;	bool appending = false;	bool replacing = false;	bool name_provided = false;	nxsstring logfname;		// Retrieve all tokens for this command, stopping only in the event	// of a semicolon or an unrecognized keyword	//	for(;;)	{		token.GetNextToken();		if( token.Equals(";") ) {			break;		}		else if( token.Abbreviation("STOp") ) {			stopping = true;		}		else if( token.Abbreviation("STArt") ) {			starting = true;		}		else if( token.Abbreviation("Replace") ) {			replacing = true;		}		else if( token.Abbreviation("Append") ) {			appending = true;		}		else if( token.Abbreviation("File") ) {			logfname = GetFileName(token);			name_provided = true;		}		else {			errormsg = "Unexpected keyword (";	      errormsg += token.GetToken();	      errormsg += ") encountered reading LOG command";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}   }      // Check for incompatible combinations of keywords   //   if( stopping && ( starting || appending || replacing || name_provided ) ) {		errormsg = "Cannot specify STOP with any of the following START, APPEND, REPLACE, FILE";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }      if( appending && replacing ) {		errormsg = "Cannot specify APPEND and REPLACE at the same time";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }   if( logf_open && ( starting || name_provided || appending || replacing ) ) {		errormsg = "Cannot start log file since log file is already open";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }   // Is user closing an open log file?   //   if( stopping ) {		logf.close();		logf_open = false;		logEachStep=false;				//message = "\nLog file closed";		//PrintMessage();		cout<<"\nLog file closed"<<endl;		return;   }   	// If this far, must be attempting to open a log file	//	if( !name_provided ) {		errormsg = "Must provide a file name when opening a log file\n";		errormsg += "e.g., log file=doofus.txt start replace;";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}   		if( appending ) {		logf_open = true;		logf.open( logfname.c_str(), ios::out | ios::app );		message = "\nAppending to log file ";		message += logfname;		PrintMessage();	}	else if( replacing ) {		logf_open = true;		logf.open( logfname.c_str() );		message = "\nReplacing log file ";		message += logfname;		PrintMessage();	}	else  {		bool exists = FileExists( logfname.c_str() );		bool userok = true;		if( exists && !UserSaysOk( "Ok to replace?", "Log file specified already exists" ) )			userok = false;		if( userok ) {			logf_open = true;			logf.open( logfname.c_str() );			logf<<setprecision(8);		}		if( exists && userok ) {			//message = "\nReplacing log file ";			//message += logfname;			cout<<"\nReplacing log file "<<logfname<<endl;		}		else if( userok ) {			//message = "\nLog file ";			//message += logfname;			//message += " opened";			cout<<"\nLog file "<<logfname<<" opened"<<endl;		}		else {			message = "\nLog command aborted";		}		PrintMessage();	}}/** * @method PreprocessNextCommand [void:public] * * Accepts a string in the form of a Bull block containing one command * and processes it just like a real Bull block in a NEXUS data file. */void Bull::HandleNextCommand(){	istrstream cmdin( next_command );	NexusToken token(cmdin);	try {		Read( token );	}	catch( XNexus x ) 	{		if(errormsg.length()==0)				NexusError( x.msg, x.pos, x.line, x.col );		else	NexusError( errormsg, x.pos, x.line, x.col );      Reset();	}}void Bull::HandlePscore(NexusToken& token ){	if(!PSettings)			{errormsg="You can't score under parsimony without an active data file";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}	if(treelist.empty())	{errormsg="You can't score under parsimony without a tree in memory";							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}	criterion=criteria(pars);	token.GetNextToken();	assert(PSettings);	bool dontModifyBLens=false;	Tree *temptre;	vector<Tree *> toscoreT;	vector<nxsstring> toscoreN;	while(token.GetToken()!=";")		{if(token.IsInteger())			{long tn=token.GetLongEquivalent();			if(tn>ntrees || tn<1)				{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}			temptre=treelist[tn-1];			}		else			{try 				{if(!(token.Equals(";")))					temptre=FindTreeFromName(token.GetToken());				}			catch (NoSuchTree)				{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}			}		toscoreN.push_back(token.GetToken());//keeps track of what the user called the tree		toscoreT.push_back(temptre);		token.GetNextToken();		}			if(toscoreT.empty())		for(int i=0;i<treelist.size();i++)			{toscoreT.push_back(treelist[i]);			toscoreN.push_back(i);			}			for(int i=0;i<toscoreT.size();i++)                		{GetTreeReadyToCalcPars(toscoreT[i]);		cout<<"The parsimony score of tree "<<toscoreN[i]<<" is "<<PScore(toscoreT[i]);		}}void Bull::HandleReconstruct(NexusToken& token ){	//eventually should handle other optimality tie-breaking criteria, now uses parsimony up pass	assert(PSettings);	if(treelist.empty())	{errormsg="You can't score under parsimony without a tree in memory";							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}	token.GetNextToken();	Tree *temptre; vector<Tree *> toshowT; vector<nxsstring> toshowN;	IntSet charlist;	nxsstring tempstr;	bool opnumread=false;		while(token.GetToken()!=";" && token.GetToken()!="/")		{opnumread=true;		tempstr+=token.GetToken();		token.GetNextToken();		}			if(token.GetToken()!=";")			token.GetNextToken();	while(token.GetToken()!=";")//optional list of characters to be reconstructed		{if(token.IsInteger())			{long tn=token.GetLongEquivalent();			if(tn>ntrees || tn<1)	{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";									throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );									}			temptre=treelist[tn-1];			}		else	{try	{if(!(token.Equals(";")))							temptre=FindTreeFromName(token.GetToken());						}				catch (NoSuchTree)	{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";									throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );									}				}		toshowN.push_back(token.GetToken());//keeps track of what the user called the tree		toshowT.push_back(temptre);		token.GetNextToken();		}	if(!opnumread)		tempstr+="1 - .;"; 	else tempstr+=";";	assert(charordata);	try	{istrstream cmdin( tempstr.c_str() );		NexusToken temptoken(cmdin);		SetReader tempReader(temptoken,nchars,charlist,*charordata);		tempReader.Run();		}	catch (XNexus x)	{errormsg="Character set unreadable.  Reconstruction aborted.";							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}		if(toshowT.empty())//default is all		for(int i=0;i<treelist.size();i++) {toshowT.push_back(treelist[i]); toshowN.push_back(i); }		for(int i=0;i<toshowT.size();i++)                		GetTreeReadyToCalcPars(toshowT[i]);		for(IntSet::iterator cIt=charlist.begin();cIt!=charlist.end();cIt++)		for(int i=0;i<toshowT.size();i++)                			{cout<<"Character "<<1+*cIt<<" Tree "<<toshowN[i]<<"\n";			int pn=DSettings->FindPartition(*cIt);			Reconstruct(toshowT[i],pn,GetPlaceInPackedPartition(pn,*cIt),branchDisplay(ParsUpPass));			}}void Bull::HandleShowTrees(NexusToken& token ){	if(treelist.empty())	{errormsg="You can't score under parsimony without a tree in memory";							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}	token.GetNextToken();	Tree *temptre; vector<Tree *> toshowT; vector<nxsstring> toshowN;	while(token.GetToken()!=";")		{if(token.IsInteger())			{long tn=token.GetLongEquivalent();			if(tn>ntrees || tn<1)	{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";									throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );									}			temptre=treelist[tn-1];			}		else	{try	{if(!(token.Equals(";")))							temptre=FindTreeFromName(token.GetToken());						}				catch (NoSuchTree)	{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";									throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );									}				}		toshowN.push_back(token.GetToken());//keeps track of what the user called the tree		toshowT.push_back(temptre);		token.GetNextToken();		}			if(toshowT.empty())//default is all		for(int i=0;i<treelist.size();i++)			{toshowT.push_back(treelist[i]);			toshowN.push_back(i);			}			for(int i=0;i<toshowT.size();i++)                		{cout<<toshowN[i]<<"\n";		toshowT[i]->ShowTree(SIOUXSettings.columns);		}}void Bull::HandleStateFreq(NexusToken& token ){		criterion=criteria(pars);	token.GetNextToken();	bool dontModifyBLens=false;	Tree *temptre;	vector<Tree *> toscoreT;	vector<nxsstring> toscoreN;	bool usePars=true;	while(token.GetToken()!=";")		{bool needanother=true;		if(token.Abbreviation("CURRentbranchlengths") || token.Abbreviation("CURRbranchlengths"))//long abbreviations to avoid conflict with simple names			{if(treelist.empty())	{errormsg="You can't score under parsimony without a tree in memory";							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}			token.GetNextToken();			needanother=false;			if(token.GetToken()=="=")				{token.GetNextToken();				if(token.Abbreviation("No"))					PSettings->SetUseCurrentBrLen(false);				else 	if(token.Abbreviation("Yes"))							PSettings->SetUseCurrentBrLen(true);						else	{errormsg="Expecting YES or NO after CurrentBranchLengths = option to PSTATEFREQ command";								throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );								}				token.GetNextToken();								}			else	PSettings->SetUseCurrentBrLen(true);			}		else	if(token.Abbreviation("Empirical"))					usePars=false;		else				{if(token.IsInteger())				{if(treelist.empty())	{errormsg="You can't get tree-based state frequencies without a tree in memory";								throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );								}				long tn=token.GetLongEquivalent();				if(tn>ntrees || tn<1)					{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";					throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );					}				temptre=treelist[tn-1];				}			else				{				if(!(token.Abbreviation("Empirical") || token.Abbreviation("CURREntbranchlengths") || token.Abbreviation("CURRBranchlengths")))					{if(treelist.empty())	{errormsg="You can't score under parsimony without a tree in memory";								throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );								}					try 						{if(!(token.Equals(";")))							temptre=FindTreeFromName(token.GetToken());						}					catch (NoSuchTree)						{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";						throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );						}					}				}			toscoreN.push_back(token.GetToken());//keeps track of what the user called the tree			toscoreT.push_back(temptre);			}		if(needanother)			token.GetNextToken();		}			if(usePars)		{if(!PSettings)				{errormsg="You can't get tree-based state frequencies without an active data file";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			}		if(treelist.empty())	{errormsg="You get tree-based state frequencies without a tree in memory";							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}		if(toscoreT.empty())			for(int i=0;i<treelist.size();i++)				{toscoreT.push_back(treelist[i]);				toscoreN.push_back(i);				}		for(int i=0;i<toscoreT.size();i++)                			{GetTreeReadyToCalcPars(toscoreT[i]);			PStateFreqs(toscoreT[i]);			}		}	else	//use empirical		EStateFreqs();	cout<<endl;}void Bull::HandleSummarizeLogs(NexusToken & token){	#ifdef CODONHACK	ifstream testf;	nxsstring tempstr;	nxsstring prefix="PrevRound";	int maxFileName=GetHighestFileNum(prefix);	int initialNAA;	int cbl,nst,naa,code;	double kapp;	double **currAAFreq,**prevAAFreq;	double *currSharedModParam,*prevSharedModParam;	prevSharedModParam=new double[10];	currSharedModParam=new double[10];	double *currMults,*prevMults,currTreeSc,prevTreeSc;	double *prevPLikes,currLike,prevLike,*aaMoves;	currMults=NULL;	for(int fileNum=0;fileNum<=maxFileName;fileNum++)		{cout<<fileNum<<endl;		tempstr=prefix;		tempstr+=fileNum;				naa=-1;		currTreeSc=1.0;		#ifdef ALLOWMULTIHITS			double mh=0.0;		#endif			currAAFreq=NULL;		delete[] previousLikelihoods;		previousLikelihoods=NULL;		for(int i=0;i<10;i++)			prevSharedModParam[i]=currSharedModParam[i]=-1.0;			ScanFileForCodLikeStartValCommandAndParse(tempstr,cbl,nst,naa, currSharedModParam,				kapp,currAAFreq,currMults,currTreeSc,code);		assert(previousLikelihoods);		assert(currAAFreq);		currLike=0.0;		for(int i=0;i<initialNAA;i++)			currLike+=previousLikelihoods[i];		if(fileNum)			{assert(naa==initialNAA);			ofstream outxl;			outxl.open("OptimizationSummary",ios::app);			outxl<<setprecision(12);			outxl<<fileNum<<"\t"<<currLike<<"\t"<<currLike-prevLike;			double rateMove=DistanceRateParamsMoved(currSharedModParam,prevSharedModParam);			double baseMove=EuclideanDistance(4,currSharedModParam,prevSharedModParam);			for(int i=0;i<initialNAA;i++)				aaMoves[i]=EuclideanDistance(20,currAAFreq[i],prevAAFreq[i]);			double totalMove=fabs(currTreeSc-prevTreeSc);			totalMove+=rateMove+baseMove;			for(int i=0;i<initialNAA;i++)				totalMove+=aaMoves[i];			outxl<<"\t"<<totalMove;			if(fabs(currTreeSc-prevTreeSc)>SMALLDOUBLE)				outxl<<"\tscale\t"<<currTreeSc-prevTreeSc;			if(fabs(rateMove)>SMALLDOUBLE)				outxl<<"\trateMatrix\t"<<rateMove;			for(int i=0;i<initialNAA;i++)				if(fabs(aaMoves[i])>SMALLDOUBLE)					outxl<<"\tAA"<<i<<"\t"<<aaMoves[i];			outxl<<"\n";			outxl.close();						}		else			{initialNAA=naa;			prevAAFreq=new_RectMats(naa,20);			prevPLikes=new double[naa];			aaMoves=new double[naa];			}				for(int i=0;i<10;i++)			prevSharedModParam[i]=currSharedModParam[i];		for(int i=0;i<initialNAA;i++)			{prevPLikes[i]=previousLikelihoods[i];			for(int j=0;j<20;j++)				prevAAFreq[i][j]=currAAFreq[i][j];			}		prevTreeSc=currTreeSc;		prevLike=currLike;				free_RectMats(currAAFreq);			delete []currMults;		currMults=NULL;		}	free_RectMats(prevAAFreq);		delete []prevPLikes;		delete [] aaMoves;	delete [] prevSharedModParam;	delete [] currSharedModParam;	#else	assert(0);#endif				}void Bull::ScanFileForCodLikeStartValCommandAndParse(nxsstring fn,int& currbrlen,int& nst,int& naa,	double *&sharedModParam,double& kapp,double **&aafreq,double *&mults,double& treesc,int &code){	ifstream inf( fn.c_str(), ios::binary );	NexusToken ftoken(inf);	nxsstring ferrormsg;   ftoken.GetNextToken();	if( !ftoken.Equals("#NEXUS") ) {      ferrormsg = "Expecting #NEXUS to be the first token in the file, but found ";      ferrormsg += ftoken.GetToken();      ferrormsg += " instead";		throw XNexus( ferrormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );	}		ExecuteStarting();		for(;;)		{ftoken.SetLabileFlagBit( NexusToken::saveCommandComments );		ftoken.GetNextToken();		if( ftoken.AtEOF() )			break;		if( ftoken.Equals("BEGIN") )			{ftoken.GetNextToken();			if(ftoken.Equals( "BULL") )				{EnteringBlock( ftoken.GetToken() );            	ftoken.GetNextToken();				if( !ftoken.Equals(";") ) 					{ferrormsg = "Expecting ; AFTER BEGIN BULL ";			      	throw XNexus( ferrormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );				  	}				for(;;)            		{ftoken.GetNextToken();					if( ftoken.Abbreviation("ENdblock") ) 						{HandleEndblock( ftoken );						break;						}					else if(ftoken.Abbreviation("CODLIKESTartval") || ftoken.Abbreviation("CLIKESTartval") || ftoken.Abbreviation("CLSTartval"))						ParseCodLikeStartValCommand(ftoken ,currbrlen,nst,naa,sharedModParam,									kapp,aafreq,mults,treesc,code);					else					 	{SkippingCommand( ftoken.GetToken() );					    do 	{ftoken.GetNextToken();					    	} 					    while( !ftoken.AtEOF() && !ftoken.Equals(";") );						if( ftoken.AtEOF() ) 							{errormsg = "Unexpected end of file encountered";							throw XNexus( errormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );					    	}							}					}				}			else				{nxsstring currBlock = ftoken.GetToken();				SkippingBlock( currBlock );				for(;;)					{ftoken.GetNextToken();					if( ftoken.Equals("END") || ftoken.Equals("ENDBLOCK") ) 						{ftoken.GetNextToken();						if( !ftoken.Equals(";") ) 							{ferrormsg = "Expecting ';' after END or ENDBLOCK command, but found ";                    		ferrormsg += ftoken.GetToken();                     		ferrormsg += " instead";							throw XNexus( ferrormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );							}						break;						}					if( ftoken.AtEOF() )						{ferrormsg = "Encountered end of file before END or ENDBLOCK in block ";                  		ferrormsg += currBlock;						throw XNexus( ferrormsg, ftoken.GetFilePosition(), ftoken.GetFileLine(), ftoken.GetFileColumn() );                  		}					}				}// if token not found amongst known block IDs			} // if token equals BEGIN		} // for(;;)	ExecuteStopping();}void Bull::HandleTabTree(NexusToken& token ){	if(treelist.empty())	{errormsg="No trees in memory";							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}	token.GetNextToken();	bool dontModifyBLens=true;	Tree *temptre;	vector<Tree *> toscoreT;	vector<nxsstring> toscoreN;	nxsstring filename;	while(token.GetToken()!=";")		{if(token.Abbreviation("FILE"))			{token.GetNextToken();			if(token.Equals("="))	token.GetNextToken();			filename=token.GetToken();			}		else			{			if(token.IsInteger())				{long tn=token.GetLongEquivalent();				if(tn>ntrees || tn<1)					{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";					throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );					}				temptre=treelist[tn-1];				}			else				{try 					{if(!(token.Equals(";")))						temptre=FindTreeFromName(token.GetToken());					}				catch (NoSuchTree)					{errormsg="Tree "; errormsg+=token.GetToken(); errormsg+=" unknown.  PStateFreq aborted.";					throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );					}				}			toscoreN.push_back(token.GetToken());//keeps track of what the user called the tree			toscoreT.push_back(temptre);			}		token.GetNextToken();		}			if(toscoreT.empty())		for(int i=0;i<treelist.size();i++)			{toscoreT.push_back(treelist[i]);			toscoreN.push_back(i);			}	if(filename.length()==0)		filename="Tabbed.tre";		ofstream	ttreeOut(filename.c_str());	if(!ttreeOut.good())	{errormsg="Couldn't open"; errormsg+=filename;							throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );							}	for(int i=0;i<toscoreT.size();i++)                		{ttreeOut<<"BEGIN TREES;\n";		toscoreT[i]->Print(ttreeOut,true,true);		ttreeOut<<"end;"<<endl;		}	ttreeOut.close();	}void Bull::HandleTranslateCodons(NexusToken& token ){	int code=0;	token.GetNextToken();	do	{		if(token.Abbreviation("Nuclear"))//long abbreviations to avoid conflict with simple names			code=2;		if(token.Abbreviation("Mitochondria") || token.Abbreviation("Mitochondrial"))//long abbreviations to avoid conflict with simple names			code=1;		token.GetNextToken();		}	while(token.GetToken()!=";");	if(!taxa)	{errormsg="TranslateCodons not allowed unless there is an active taxa block.";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}	if(!charordata)	{errormsg="TranslateCodons not allowed unless there is an active characters block.";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}	if(charordata->GetDataType()!=2) {errormsg="TranslateCodons not allowed unless there is the datatype is DNA.";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );				}	cout<<"Writing to default file Translation.out"<<endl;	ofstream tout("Translation.out");	tout<<"#NEXUS\n";	WriteTaxaBlock(tout);	WriteCharactersBlock(tout,false,code);	tout.close();}/** * @method HandleUpdateBranchLengths [void:protected] * @param token [NexusToken&] the token used to read from in *  * * called by bull::TryAdvancedCommands to read branch lengths * from the optimization log file and put them into the next * tree file. The tree to be updated must be in memory (and identical * even in terms of branch rotation to the optimized tree, because * the updated is left first sweep down traversal) */void Bull::HandleUpdateBranchLengths(NexusToken& token ){	while(token.GetToken()!=";")		token.GetNextToken();	ifstream logfs;	int nBranchesToSkip;	int branchOptLogNum=GetHighestFileNum("NumBranchesOptimized");	nxsstring fname="NumBranchesOptimized";	fname+=branchOptLogNum;	logfs.open(fname.c_str());		logfs>>nBranchesToSkip;	logfs.close();		if(nBranchesToSkip>0)		{double *optBranchLengths;		optBranchLengths=new double[nBranchesToSkip];		nxsstring sfname="OptimizedBranchLengths";		sfname+=branchOptLogNum;		logfs.open(sfname.c_str());				for(int i=0;i<nBranchesToSkip;i++)			logfs>>optBranchLengths[i];		assert(logfs.good());		logfs.close();		assert(treelist.size()==1);		treelist[0]->UpdateBranchesInRecursiveOrder(optBranchLengths,nBranchesToSkip);		delete[] optBranchLengths;		optBranchLengths=NULL;		nxsstring tag;				tag="OptTree";				int highestNum=GetHighestFileNum(tag);		if(highestNum<0)			{errormsg = "Couldn't open file "; errormsg += tag;	errormsg += "0";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			}		highestNum++;		tag+=highestNum;		ofstream newTf;		newTf.open(tag.c_str());		assert(newTf.good());		newTf<<"#NEXUS\nBEGIN TREES;\n";		treelist[0]->Print(newTf,true,true);		newTf<<"end;"<<endl;		newTf.close();		}}/** * @method GetHighestFileNum [int] * @param tag [nxsstring] the tag that starts file name *  * * returns -1 if no files are named with the tag followed by a number * returns the highest number on the end of a file other wise */int GetHighestFileNum(nxsstring tag){	ifstream testf;	int num=0;	nxsstring tempstr;	tempstr=tag;	tempstr+=num;	testf.open(tempstr.c_str());	while(testf.good())		{testf.close();		num++;		tempstr=tag;		tempstr+=num;		testf.open(tempstr.c_str());		}	testf.close();	num--;	return num;}// a hack the first 3 params are base freqs, then come the GTR rate parametersdouble DistanceRateParamsMoved(double *curr,double *prev){	//normalize then take the euclidean distance	double normCurr[6],normPrev[6];	NormalizeGTRParams(curr,normCurr);	NormalizeGTRParams(prev,normPrev);	return EuclideanDistance(6,normCurr,normPrev);}void NormalizeGTRParams(double *curr,double *currNorm){	double cbases=0.0;	double csum=0.0;	for(int i=0;i<3;i++)			cbases+=curr[i];	double ct;	ct=1.0-cbases;	for(int i=0;i<4;i++)			for(int j=0;j<4;j++)			if(i!=j)				{double cterm;				if(i<3)	cterm=curr[i];				else	cterm=ct;								if(i==0 ||j==0)					{if(i==1 || j==1)						{cterm*=curr[3];  }					else if (i==2 || j==2)						{cterm*=curr[4];  }					else						{cterm*=curr[5];  }					}				else if(i==1 || j==1)					{if(i==2 ||j==2)						{cterm*=curr[6];  }					else						{cterm*=curr[7];  }					}				else 	{cterm*=curr[8];  }								if(j<3)	{cterm*=curr[j];  }				else	{cterm*=ct;  }										csum+=cterm;				}	for(int i=0;i<6;i++)		currNorm[i]=curr[i]/csum;}double EuclideanDistance(int arrSize,double *f,double *s){	double dist=0.0;	for(int i=0;i<arrSize;i++)		dist+=pow(fabs(*f++ - *s++),2);	return dist;}