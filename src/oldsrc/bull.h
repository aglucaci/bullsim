#ifndef __BULLCMDLINE_H#define __BULLCMDLINE_H#include "basicbulldefs.h"#include <list>#include <map>#include <algorithm>#include <strstream>#include <fstream.h>#include <iomanip.h>#include <unistd.h>#include <stdio.h>#include "mynexus.h"#include "encodedchars.h"#include "basicfuncs.h"#include "tree.h"#include "models.h"#include "settings.h"#include "datapartition.h"#include "parameteralterationinfo.h"#define COMMAND_MAXLEN  255class NoSuchTree : public MTHException { public :	NoSuchTree() : MTHException() {}	NoSuchTree(const char *c) :MTHException(c) { }	};class NoModel : public MTHException { public :	NoModel() : MTHException() {}	NoModel(const char *c) :MTHException(c) { }	};class Bull :  public NexusBlock, public Nexus{   // Adding a new data member? Don't forget to:   // 1. Describe it in the class header comment at the top of "emptyblock.cpp"   // 2. Initialize it (unless it is self-initializing) in the constructor   //    and reinitialize it in the Reset function   // 3. Describe the initial state in the constructor documentation   // 4. Delete memory allocated to it in both the destructor and Reset function   // 5. Report it in some way in the Report functionenum criteria {maxLike , pars , bayesian};protected:#ifdef	DEBUGGING	bool firstTimeThrough;#endif	bool inf_open , logf_open , quit_now , purged;	bool storebrlens;		ofstream logf;		nxsstring message;	char next_command[COMMAND_MAXLEN+1];	int criterion,datatype;	TreesBlock* trees;	TaxaBlock* taxa;	AssumptionsBlock* assumptions;	CharactersBlock* charordata, *characters;	DataBlock *data;		DataSettings *DSettings;	LikeSettings *LSettings;	ParsSettings *PSettings;	ParameterAlterationInfo *paramAlterInfo;		int ntrees , ntaxa , nchars,npartitions;	vector<Tree *> treelist;	map<nxsstring, EncodedChars *> rawData;	DataPartition **partitions;		double *previousLikelihoods;	/*previousLikelihoods is Implemented dangerously with no checks 	that the likelihoods apply to the model/data/tree that is about 	to be scored.	Allocation and Deallocation occur in several places in the program*/		nxsstring commandFileTag;	int commandFileNum;	int nParamDirectionsToSkip,nParamGroupsToSkip,nBranchesToSkip;	double paramImprovThisRound,likeAtBegOfThisRound;	double lastBranchImprov,lastParamImprov;#ifdef CODONHACK	bool logEachStep,workingOnBranches;//codonhack only	SSRFCodonSubMod ** modArr;	int sizeOfModArr;	#endif			Model *curmodel;	Node **RecursiveNodeList;	protected:	void CreateDataMap();	void CreateParameterAlterationInfo(SetOfTreeLikeAttr *tsla,Tree * t);	SetOfLikeAttr *CreateSetOfLikeAttrForANode(void);//creates Set for Internal Nodes	SetOfLikeAttr *CreateSetOfLikeAttrForANode(nxsstring termName);//creates set for terminals	SetOfTreeLikeAttr *CreateSetOfLikeAttrForATree(void);	SetOfParsAttr *CreateSetOfParsAttrForANode(void);//creates Set for Internal Nodes	SetOfParsAttr *CreateSetOfParsAttrForANode(nxsstring termName);//creates set for terminals	SetOfTreeParsAttr *CreateSetOfParsAttrForATree(void);	void EliminateAminoAcidsThatHaveFreqZero(Tree *t);	void EStateFreqs();	void FactoryDefaults();    Tree *FindTreeFromName(nxsstring);	void FinishCharactersBlock();	void FinishAssumptionsBlock();	void FinishTaxaBlock();	void FinishTreesBlock();	int GetPlaceInPackedPartition(int partNum,int rawChar);	void GetTreeReadyToCalcLike(Tree *);	void GetTreeReadyToCalcPars(Tree *);	void InitializeParameters();	bool NeedToBeginAgainBecauseStateSpaceGrew(Tree *t);	bool FileExists( const char* fn );	nxsstring GetFileName( NexusToken& token );	void HandleCodLikeStartVal(NexusToken& token );	void ParseCodLikeStartValCommand(NexusToken& ttoken,int& currbrlen,		int& nst,int& naa, double *&sharedModParam,double& kapp,		double **&aafreq, double *&mults,double& reesc,int &code);	void ScanFileForCodLikeStartValCommandAndParse(nxsstring fn,		int& currbrlen,int& nst,int& naa, double *&sharedModParam,		double& kapp,double **&aafreq,double *&mults,double& treesc,		int &code);	void HandleContinueAnalysis( NexusToken& token );	void HandleEndblock( NexusToken& token );	void HandleExecute( NexusToken& token );	void HandleExecuteBullBlocksInFile( NexusToken& token );	void HandleGetTrees(NexusToken& token );	void HandleLog( NexusToken& token );	void HandleLscore(NexusToken& token );	void HandleLset(NexusToken& token );	void HandleStateFreq(NexusToken& token );	void HandlePscore(NexusToken& token );	void HandleReconstruct(NexusToken& token );	void HandleShowTrees(NexusToken& token );	void HandleSummarizeLogs(NexusToken& token );	void HandleTabTree(NexusToken& token );	void HandleTranslateCodons(NexusToken& token );	void HandleUpdateBranchLengths(NexusToken& token);		void PurgeBlocks();	void Read( NexusToken& token );	void Reset();		double InitialLScore(Tree *);	bool NeedToPartition();	void Partition();		void InstantiateBranchLengths(Tree *t);	void InstantiateBranchLengthModifiers(Tree *t);	void SetBrlensToNULLIfNotOwner(Tree *t);	void TryAdvancedCommands(NexusToken &token);		void PStateFreqs(Tree *tree);	int PScore(Tree *tree);	void Reconstruct(Tree *tree,int partNum,int charNum,int displayMode);		//OUTPUT	void WriteTaxaBlock(ofstream &tout);	void WriteCharactersBlock(ofstream &tout,bool interleave,int DNATranslation);public:	Bull();   ~Bull();	void ExecuteStarting() {}	void ExecuteStopping() {}	void OutputComment( nxsstring s ) {			cout << endl;			cout << s << endl;			logf << endl;			logf << s << endl;		}	void ExitingBlock( nxsstring blockName ) {			cout << "Finished with \"" << blockName << "\" block." << endl;			logf << "Finished with \"" << blockName << "\" block." << endl;		}	void EnteringBlock( nxsstring blockName );	void HandleNextCommand();	void NexusError( nxsstring& msg, streampos pos, long line, long col );	void PreprocessNextCommand();	void PrintMessage( bool linefeed = true ,bool flusht = true);	void LPrintMessage( bool linefeed  = true  , bool flusht = true);	void Report( ostream& out );	void Run();	void SkippingBlock( nxsstring blockName );	void SkippingCommand( nxsstring commandName );	bool UserSaysOk( nxsstring mb_message, nxsstring mb_title );	nxsstring *GetMessage()	{return &message;}	bool GetLoggingEachStep() {return logEachStep;}	int GetNumberOfParameterDirectionToStartAt() {return nParamDirectionsToSkip;}	int GetNumberOfParameterGroupToStartAt() {return nParamGroupsToSkip;}	int GetNumberOfBranchToStartAt() {return nBranchesToSkip;}	void WriteLogFileForCurrentPosition(int pgtoskip,int patoskip,bool startBranches=false);	void FakeACommand(const char *tempstr);};int GetHighestFileNum(nxsstring tag);#endif