#include "parameteralterationinfo.h"#include "bull.h"#include "basicfuncs.h"#include "AdvancedBullDefs.h"#include <algorithm.h>#define TINYPARAMCUTOFF 1.0e-9#define SMALLPARAMTOTRY 5.0e-8#define STEPSIZEMULTIPLIER 1.5#define MAXSTEPSIZEBUMPS 30ParameterAlterationInfo::ParameterAlterationInfo(LikeSettings *ls,DataPartition **dps,SetOfTreeLikeAttr *tsla,Tree *t,Bull *bp){	//may have problems with maps changing orders between runs, if they are sorted by pointers.  This should be corrected for codon	//hack mode (not for model mixing, branch lengths, or brLen Modifiers	bullPtr=bp;	loggingEachStep=bullPtr->GetLoggingEachStep();	parDirsToSkip=bullPtr->GetNumberOfParameterDirectionToStartAt();	parGroupsToSkip=bullPtr->GetNumberOfParameterGroupToStartAt();	branchesToSkip=bullPtr->GetNumberOfBranchToStartAt();		beforeRelatedParam=NULL;	tree=t;	optimizingBrLens=ls->optimizingBrLens;	vecPMI emptyPMIVec;	map<int,vecPMI> modelMap;	map<Model *,int> modelToNumberMap;	map<int,Model *> numberToModelMap; 		Model *tempM;	PartModIndex thisPMI;	pair<Model *,PartModIndex> thispair;	int currentIndex=0;	for(int p=0;p<ls->sharedDataSettings->GetNDataPartitions();p++)//Create vectors of brLens and mods and Map of Model and Partitions it affects		{for(int m=0;m<ls->GetNModelsInPart(p);m++)			{thisPMI.Set(p,m);			if(thisPMI==ls->GetOwnerOfBrLens(p,m))				branchLengthOwners.push_back(thisPMI);			if(ls->HasBrLenMod(p,m))				if(thisPMI==ls->GetOwnerOfBrLenModifiers(p,m))					{modelsWithRateModifiers.push_back(thisPMI);					numModifiersOwned.push_back(ls->GetNumBrLenMod(p,m));					}			tempM=ls->GetModel(p,m);			if(modelToNumberMap.find(tempM)==modelToNumberMap.end())//make sure that not all models are sharing a vector				{assert(currentIndex==modelToNumberMap.size());				modelToNumberMap[tempM]=currentIndex;				numberToModelMap[currentIndex]=tempM;				modelMap[currentIndex]=emptyPMIVec;				modelMap[currentIndex].push_back(thisPMI);					currentIndex++;				}			else				modelMap[modelToNumberMap[tempM]].push_back(thisPMI);				}		}			typedef vector<Model *> vMod;	vMod emptyModVec;	FreqParamGroup *tempFPG;	Parameter *tempP;		map<Parameter *,int> paramToNumberMap;	map<int,vMod> paramEffectsMap;	map<int,Parameter*> numberToParamMap;	int totalParamsIndex=0;		map<FreqParamGroup *,int> freqParamToNumberMap;	map<int,vMod> FreqParamEffectsMap;	map<int,FreqParamGroup *> numberToFreqParamMap;	int totalFreqParamsIndex=0;		//Create maps of indeces of parameters (and Parameter Groups) to their affected models	for(int modelIt=0;modelIt<numberToModelMap.size();modelIt++)		{vector<FreqParamGroup *> thisSetOfFPG;		thisSetOfFPG.erase(thisSetOfFPG.begin(),thisSetOfFPG.end());		Model *tempMod=numberToModelMap[modelIt];		for(int i=0;i<tempMod->GetNFreqGroups();i++)			{tempFPG=tempMod->GetFreqParamGroup(i);			assert(tempFPG);			thisSetOfFPG.push_back(tempFPG);			if(freqParamToNumberMap.find(tempFPG)==freqParamToNumberMap.end())//make sure that not all models are sharing a vector				{assert(totalFreqParamsIndex==freqParamToNumberMap.size());				freqParamToNumberMap[tempFPG]=totalFreqParamsIndex;				numberToFreqParamMap[totalFreqParamsIndex]=tempFPG;				FreqParamEffectsMap[totalFreqParamsIndex]=emptyModVec;				FreqParamEffectsMap[totalFreqParamsIndex].push_back(tempMod);				totalFreqParamsIndex++;				}			else				FreqParamEffectsMap[freqParamToNumberMap[tempFPG]].push_back(tempMod);				}		for(int i=0;i<tempMod->GetNParams();i++)			{//check to make sure that the parameter isn't part of one of the freqParamGroups, if it isn't add it to the ParmamMap			tempP=tempMod->GetParameter(i);			bool InGroup=false;			for(int j=0;(!InGroup && j<thisSetOfFPG.size());j++)				InGroup=thisSetOfFPG[j]->IsAMember(tempP);			if(!InGroup)				{				if(paramToNumberMap.find(tempP)==paramToNumberMap.end())//make sure that not all models are sharing a vector					{assert(totalParamsIndex==paramToNumberMap.size());					paramToNumberMap[tempP]=totalParamsIndex;					numberToParamMap[totalParamsIndex]=tempP;					paramEffectsMap[totalParamsIndex]=emptyModVec;					paramEffectsMap[totalParamsIndex].push_back(tempMod);					totalParamsIndex++;					}				else					paramEffectsMap[paramToNumberMap[tempP]].push_back(tempMod);					}			}		}			//Create a vector of non freq params and which models they affect	for(int pit=0;pit<totalParamsIndex;pit++)		{if(!(numberToParamMap[pit]->Fixed()))			{emptyPMIVec.erase(emptyPMIVec.begin(),emptyPMIVec.end());			for(vector<Model *>::iterator mit=paramEffectsMap[pit].begin();mit!=paramEffectsMap[pit].end();mit++)				for(vector<PartModIndex>::iterator pmiIt=(modelMap[modelToNumberMap[*mit]]).begin();pmiIt!=(modelMap[modelToNumberMap[*mit]]).end();pmiIt++)					emptyPMIVec.push_back(*pmiIt);			vecModParam.push_back(numberToParamMap[pit]);			affectedModelsInfo.push_back(emptyPMIVec);			vecTypeOfParam.push_back(numberToParamMap[pit]->GetSetting());			}		}	nModParams=affectedModelsInfo.size();		for(int fpgit=0;fpgit<totalFreqParamsIndex;fpgit++)		{if(!(numberToFreqParamMap[fpgit]->Fixed()))			{emptyPMIVec.erase(emptyPMIVec.begin(),emptyPMIVec.end());			for(vector<Model *>::iterator mit=FreqParamEffectsMap[fpgit].begin();mit!=FreqParamEffectsMap[fpgit].end();mit++)				for(vector<PartModIndex>::iterator pmiIt=(modelMap[modelToNumberMap[*mit]]).begin();pmiIt!=(modelMap[modelToNumberMap[*mit]]).end();pmiIt++)					emptyPMIVec.push_back(*pmiIt);			vecFreqParamGroups.push_back(numberToFreqParamMap[fpgit]);			affectedModelsInfo.push_back(emptyPMIVec);			vecTypeOfParam.push_back(numberToFreqParamMap[fpgit]->GetSetting());			}		}	nFreqParamGroups=affectedModelsInfo.size()-nModParams;		vector<PartModIndex>::iterator bloIt=branchLengthOwners.begin();	while(bloIt!=branchLengthOwners.end())		{if((ls->GetBLenSetting(bloIt->partNum,bloIt->modNum))&par(FIX))			bloIt=branchLengthOwners.erase(bloIt);		else	bloIt++;		}	nBrLenParams=branchLengthOwners.size();	for(bloIt=branchLengthOwners.begin();bloIt!=branchLengthOwners.end();bloIt++)		{emptyPMIVec.erase(emptyPMIVec.begin(),emptyPMIVec.end());		for(int p=0;p<ls->sharedDataSettings->GetNDataPartitions();p++)			for(int m=0;m<ls->GetNModelsInPart(p);m++)				if(*bloIt==ls->GetOwnerOfBrLens(p,m))					{thisPMI.Set(p,m);					emptyPMIVec.push_back(thisPMI);					}		affectedModelsInfo.push_back(emptyPMIVec);		vecTypeOfParam.push_back(ls->GetBLenSetting(bloIt->partNum,bloIt->modNum));			}						vector<PartModIndex>::iterator rmIt=modelsWithRateModifiers.begin();	vector<int>::iterator nrmIt=numModifiersOwned.begin();	while(rmIt!=modelsWithRateModifiers.end())		{if((ls->GetBLenModSetting(rmIt->partNum,rmIt->modNum))&par(FIX))			{rmIt=modelsWithRateModifiers.erase(rmIt);			nrmIt=numModifiersOwned.erase(nrmIt);			}		else	{rmIt++;				nrmIt++;				}		}	nBrLenModParams=modelsWithRateModifiers.size();	for(rmIt=modelsWithRateModifiers.begin();rmIt!=modelsWithRateModifiers.end();rmIt++)		{emptyPMIVec.erase(emptyPMIVec.begin(),emptyPMIVec.end());		for(int p=0;p<ls->sharedDataSettings->GetNDataPartitions();p++)			for(int m=0;m<ls->GetNModelsInPart(p);m++)				if(ls->HasBrLenMod(p,m))					if(*rmIt==ls->GetOwnerOfBrLenModifiers(p,m))						{thisPMI.Set(p,m);						emptyPMIVec.push_back(thisPMI);						}		affectedModelsInfo.push_back(emptyPMIVec);		vecTypeOfParam.push_back(ls->GetBLenSetting(rmIt->partNum,rmIt->modNum));			}		for(int p=0;p<ls->sharedDataSettings->GetNDataPartitions();p++)		if(!(ls->partSettings[p]->ModelMixingSetting)&par(FIX))			{emptyPMIVec.erase(emptyPMIVec.begin(),emptyPMIVec.end());			for(int m=0;m<ls->GetNModelsInPart(p);m++)				{thisPMI.Set(p,m);				emptyPMIVec.push_back(thisPMI);				}			affectedModelsInfo.push_back(emptyPMIVec);			vecTypeOfParam.push_back(ls->partSettings[p]->ModelMixingSetting);			modMixing.push_back(p);			}	nModMix=modMixing.size();		//FOR MAXIMIZATIONS	nMaximizedParams=nModParams+nModMix;	for(int i=0;i<nFreqParamGroups;i++)		//First Try at reparmeterization	nMaximizedParams+=(vecFreqParamGroups[i]->GetNParams()-1);		//Second Try at reparmeterization			nMaximizedParams+=(vecFreqParamGroups[i]->GetNParams());	for(int i=0;i<nBrLenModParams;i++)		nMaximizedParams+=numModifiersOwned[i];	oldParamVals=new double [nMaximizedParams];	PowellParamVals=new double [nMaximizedParams];	PrevScoredVals=new double [nMaximizedParams];	BrentParamVals=new double [nMaximizedParams];	netDirection=new double [nMaximizedParams];	reparamDirection=new double [nMaximizedParams];	affectedConversionIndex=new int[nMaximizedParams];	parOrGroupPArray=new ParamOrGroupPtr*[nMaximizedParams];	for(int ijk=0;ijk<nMaximizedParams;ijk++)		parOrGroupPArray[ijk]=NULL;	int parind=0,maxfg=0;	for(;parind<nModParams;parind++)		{parOrGroupPArray[parind]=new ParamOrGroupPtr(vecModParam[parind]);		affectedConversionIndex[parind]=parind;		}	for(int i=0;i<nFreqParamGroups;i++)		{		/*First Try at reparmeterization		for(int j=0;j<vecFreqParamGroups[i]->GetNParams()-1;j++)			{affectedConversionIndex[parind]=nModParams+i;			parOrGroupPArray[parind++]=new ParamOrGroupPtr(vecFreqParamGroups[i],j);			}*/		//Second Try at reparmeterization		for(int j=0;j<vecFreqParamGroups[i]->GetNParams();j++)			{affectedConversionIndex[parind]=nModParams+i;			parOrGroupPArray[parind++]=new ParamOrGroupPtr(vecFreqParamGroups[i],j);			}		if(vecFreqParamGroups[i]->GetNParams()>maxfg)			maxfg=vecFreqParamGroups[i]->GetNParams();		}	int k=0;	for(int i=0;i<nBrLenModParams;i++)		for(int j=0;j<numModifiersOwned[i];j++)			{affectedConversionIndex[parind]=nModParams+nFreqParamGroups+nBrLenParams+k;			parOrGroupPArray[parind++]=new ParamOrGroupPtr(tsla->GetBrLenMod(modelsWithRateModifiers[i],j));			k++;			}	for(int i=0;i<nModMix;i++)		{FreqParamGroup *tempFPG;		tempFPG=dps[i]->GetModelMixingParam();		/*First Try at reparmeterization		for(int j=0;j<tempFPG->GetNParams()-1;j++)			{affectedConversionIndex[parind]=nModParams+nFreqParamGroups+nBrLenParams+nBrLenModParams+i;			parOrGroupPArray[parind++]=new ParamOrGroupPtr(tempFPG,j);			}*/		//Second Try at reparmeterization		for(int j=0;j<tempFPG->GetNParams();j++)			{affectedConversionIndex[parind]=nModParams+nFreqParamGroups+nBrLenParams+nBrLenModParams+i;			parOrGroupPArray[parind++]=new ParamOrGroupPtr(tempFPG,j);			}		if(tempFPG->GetNParams()>maxfg)			maxfg=tempFPG->GetNParams();		}	if(nMaximizedParams<1000)		{smallDir=NULL;		linearAlgWorkSpace=psdmatrix(maxfg+1);		directions=psdmatrix(nMaximizedParams);		beforeRelatedParam=NULL;		}	else {//system Creates vector vector of ints that specify an order of going through parameters so they		//are grouped based on which model/partitions that they affect 		//and allocates  enough memeory to store enough directions to do a powell like method on the largest group		// of related parameters		 int largestGroup;		 typedef pair<vecInts,vecPMI> parAndAff;		 vecInts tempvi;		 vector<parAndAff> vecOfParamsByAffectedMods;		 int nRelatedGroups=0;		 for(int tempi=0;tempi<nMaximizedParams;tempi++)		 	{bool found=false;		 	for(int j=0;(!found && j<nRelatedGroups);j++)		 		if(vecContainSameElements(&((vecOfParamsByAffectedMods[j]).second),&(affectedModelsInfo[affectedConversionIndex[tempi]])))		 			{found=true;		 			(vecOfParamsByAffectedMods[j]).first.push_back(tempi);		 			}		 	if(!found)		 		{tempvi.erase(tempvi.begin(),tempvi.end());		 		tempvi.push_back(tempi);		 		nRelatedGroups++;		 		//int firstPartAffected=affectedModelsInfo[affectedConversionIndex[tempi]][0].partNum;		 		//int NumPartsAffected=affectedModelsInfo[affectedConversionIndex[tempi]].size();		 		//int LastPartAffected=affectedModelsInfo[affectedConversionIndex[tempi]][NumPartsAffected-1].partNum;		 		//cout<<firstPartAffected<<"\t"<<LastPartAffected<<"\t"<<NumPartsAffected<<"\n";		 		vecOfParamsByAffectedMods.push_back(make_pair(tempvi,affectedModelsInfo[affectedConversionIndex[tempi]]));		 		}		 	}		 //cout<<"the number of params is "<<nMaximizedParams<<endl;		// assert(0);		 largestGroup=(vecOfParamsByAffectedMods[0]).first.size();		 for(int i=0;i<nRelatedGroups;i++)		 	{int temp=(vecOfParamsByAffectedMods[i]).first.size();		 	if(temp>largestGroup)		 		largestGroup=temp;		 	}		 smallDir=new_RectMats(largestGroup,nMaximizedParams);		 for(int j=0;j<nRelatedGroups;j++)		 	vecOfRelatedParams.push_back((vecOfParamsByAffectedMods[j]).first);		 directions=NULL;		 beforeRelatedParam=new double[nMaximizedParams];		 currVecIndex=0;		 }	assert(parind==nMaximizedParams);	for(int i=0;i<nMaximizedParams;i++)		oldParamVals[i]=PowellParamVals[i]=BrentParamVals[i]=parOrGroupPArray[i]->GetReparameterized();	ResetDirections();		assert(affectedModelsInfo.size()==nModParams+nFreqParamGroups+nBrLenParams+nBrLenModParams+nModMix);	}void ParameterAlterationInfo::ResetDirections(){	if(directions)		for(int i=0;i<nMaximizedParams;i++)			{for(int j=0;j<nMaximizedParams;j++)				directions[i][j]=0.0;			directions[i][i]=1.0;			}	else		for(int i=0;i<(vecOfRelatedParams[currVecIndex]).size();i++)			{for(int j=0;j<nMaximizedParams;j++)				smallDir[i][j]=0.0;			smallDir[i][(vecOfRelatedParams[currVecIndex])[i]]=1.0;			}}	ParameterAlterationInfo::~ParameterAlterationInfo(){	if(directions)	free_psdmatrix(directions);	else	free_RectMats(smallDir);	delete [] PowellParamVals;	delete [] BrentParamVals;	for(int i=0;i<nMaximizedParams;i++)		delete parOrGroupPArray[i];	delete [] parOrGroupPArray;	delete [] oldParamVals;	delete [] netDirection;	delete [] reparamDirection;	delete [] affectedConversionIndex;	free_psdmatrix(linearAlgWorkSpace);	delete [] PrevScoredVals;	delete [] beforeRelatedParam;	}vector<PartModIndex> *ParameterAlterationInfo::GetAffectedMod(int i){	assert(i<nModParams);	return &affectedModelsInfo[i];}vector<PartModIndex> *ParameterAlterationInfo::GetAffectedFreq(int i){	assert(i<nFreqParamGroups);	return &affectedModelsInfo[i+nModParams];}vector<PartModIndex> *ParameterAlterationInfo::GetAffectedBrLen(int i){	assert(i<nBrLenParams);	return &affectedModelsInfo[i+nModParams+nFreqParamGroups];}vector<PartModIndex> *ParameterAlterationInfo::GetAffectedBrLenMod(int i){	assert(i<nBrLenModParams);	return &affectedModelsInfo[i+nModParams+nFreqParamGroups+nBrLenParams];}vector<PartModIndex> *ParameterAlterationInfo::GetAffectedModMix(int i){	assert(i<nModMix);	return &affectedModelsInfo[i+nModParams+nFreqParamGroups+nBrLenParams+nBrLenModParams];}double ParameterAlterationInfo::PowellMaximization(int maxPasses,double delta)	{	assert(delta>FTOL);/*this approach is an adaptation of Powell's method from Numerical recipesthe difference arises from the fact that there are quicker(?) optimizations of branch lengths, so branch lengths aren'tput into the vector of parameters to be optimized by powell's method, but I wanted to optimize them at the start of each loop of the method*/	currpos=0;	powellRound=0;	currVecIndex=0;	int i,bestDirInd;	bool parametersChanged=true;	bool brLenConverged=true;	double prevlike,likeBeforeThisOpt,powdelta,beforePowellLike,prevBrLenLike;	for(i=0;i<nMaximizedParams;i++)		PowellParamVals[i]=oldParamVals[i];	ResetDirections();	Model *tempMod=tree->GetLikeAttributes()->GetModel(0,0);	// TEMPORARY COMMENTING OUT BECAUSE HANDLELSCORE IS NOW CONTROLLING HOW MANY REPS ARE DONE	//do	{		prevlike=tree->likelihood;				//Work on branches the second time through and increase n of passes each round of Powell maximizations#ifndef CODONHACK		/*TEMPORARY COMMENTING OUT BECAUSE HANDLELSCORE IS CONTROLLING BRANCH OPT		if(optimizingBrLens)			{int numSmoothpass=0;			prevBrLenLike=tree->likelihood+10*delta;			// smooth a bit, but make sure that if the parameters aren't changing you are doing plenty of brlensmoothing			while((numSmoothpass<=powellRound || (!parametersChanged && numSmoothpass<=maxPasses) )&& (prevBrLenLike-tree->likelihood)>delta)				{				numSmoothpass++;				prevBrLenLike=tree->likelihood;				for(int i=0;i<nBrLenParams;i++)//over all of the sets of branch lengths (multiple models only)					tree->BranchLengthSmoothingPass(GetBranchLengthOwner(i),GetAffectedBrLen(i),maxPasses,delta,branchesToSkip);				}			if((prevBrLenLike-tree->likelihood)>delta)		brLenConverged=false;			else											brLenConverged=true;			}*/#endif				//Parameter optimizations				beforePowellLike=tree->likelihood;		powdelta=0.0;bestDirInd=0;		if(directions)						//reasonable number of parameters will use this system			{for(i=0;i<nMaximizedParams;i++)				{likeBeforeThisOpt=tree->likelihood;				currDirection=GetReparameterizedDirection(i);				if(powellRound || parDirsToSkip<=0)//lets you skip parameters that have already been optimized the previous time the program was run					{if(HasAtLeastOneNonZeroDir(currDirection))						{LinearBrent(maxPasses,delta);						if(loggingEachStep)							//bullPtr->WriteLogFileForCurrentPosition(i+1);							{							bullPtr->WriteLogFileForCurrentPosition(0,currpos+1);							}						//LinearBrent(min(maxPasses,5+powellRound),delta);						if((likeBeforeThisOpt - tree->likelihood)> powdelta)//new best direction							{powdelta=(tree->likelihood-likeBeforeThisOpt);							bestDirInd=i;							}						}					else						cout<<"That's odd"<<endl;					}				currpos++;				parDirsToSkip--;				}			}				else								//too many parameters to keep track of all the directions, there should be a vector of vectors of ints that				// lets you step through related groups and do a Powell like procedure on parameters that are likely to influence each other			{for(currVecIndex=0;currVecIndex<vecOfRelatedParams.size();currVecIndex++)				{if(parGroupsToSkip<=0)					{for(i=0;i<nMaximizedParams;i++)						beforeRelatedParam[i]=PowellParamVals[i];					//random_shuffle((vecOfRelatedParams[currVecIndex]).begin(),(vecOfRelatedParams[currVecIndex]).end());					ResetDirections();					//imitate the powell method 					for(i=0;i<(vecOfRelatedParams[currVecIndex]).size();i++)						{likeBeforeThisOpt=tree->likelihood;						currDirection=GetReparameterizedDirection(i);						if(currVecIndex || parDirsToSkip<=0)//in the codon hack mode, you can only skip individual parameters in the group 0 (the mutational parameters)							{if(HasAtLeastOneNonZeroDir(currDirection))								{LinearBrent(maxPasses,delta);								//LinearBrent(min(maxPasses,5+powellRound),delta);								if(!currVecIndex && loggingEachStep)									bullPtr->WriteLogFileForCurrentPosition(currVecIndex,i+1);								}							else								cout<<"That's odd"<<endl;							}						currpos++;						if(!currVecIndex)							parDirsToSkip--;						}					if(loggingEachStep)						bullPtr->WriteLogFileForCurrentPosition(currVecIndex+1,0);													//TEMPORARY COMMENT OUT					/*					if(powellRound || assert(0))//need to redone because parsDirToSkip has changed//not equal so that guarantees that something was done in the previous round						{for(i=0;i<nMaximizedParams;i++)							{netDirection[i]=PowellParamVals[i]-beforeRelatedParam[i];							BrentParamVals[i]=PowellParamVals[i]+netDirection[i];							beforeRelatedParam[i]=PowellParamVals[i];							}						currDirection=netDirection;						likeBeforeThisOpt=tree->likelihood;						if(HasAtLeastOneNonZeroDir(currDirection))							{if(UpdateParams())								{try {tree->LScoreDirtyParts();}								catch (LikeUnderFlow)	{tree->likelihood=MAXDOUBLE;}								if(tree->likelihood<likeBeforeThisOpt)									{double powcriterion;									powcriterion=(beforePowellLike-2.0*likeBeforeThisOpt+tree->likelihood)*sqrt(beforePowellLike-likeBeforeThisOpt-powdelta)-powdelta*sqrt(beforePowellLike-tree->likelihood);									if(powcriterion<0.0)										{										LinearBrent(maxPasses,delta);										if(loggingEachStep)											bullPtr->WriteLogFileForCurrentPosition(currpos);										//LinearBrent(min(maxPasses,5+powellRound),delta);										}									//else	I don' think I want this else double check  TEMPORARY									SetPowellValsToBrent();									}								else	{UpdateButDontScore(0,likeBeforeThisOpt);										NotifyModelForEveryParameterInCurrDirection();												}								}							else	UpdateButDontScore(0,likeBeforeThisOpt);							}						}	*/					}				parGroupsToSkip--;				}			}		if(nMaximizedParams>1)			{for(i=0;i<nMaximizedParams;i++)				{netDirection[i]=PowellParamVals[i]-oldParamVals[i];				BrentParamVals[i]=PowellParamVals[i]+netDirection[i];				oldParamVals[i]=PowellParamVals[i];				}			currDirection=netDirection;			likeBeforeThisOpt=tree->likelihood;			//TEMPORARY COMMENT OUT			/*			if(HasAtLeastOneNonZeroDir(currDirection))				{if(UpdateParams())					{					try {tree->LScoreDirtyParts();}					catch (LikeUnderFlow)	{tree->likelihood=MAXDOUBLE;}					if(tree->likelihood<likeBeforeThisOpt)						{double powcriterion;						powcriterion=(beforePowellLike-2.0*likeBeforeThisOpt+tree->likelihood)*sqrt(beforePowellLike-likeBeforeThisOpt-powdelta)-powdelta*sqrt(beforePowellLike-tree->likelihood);						if(powcriterion<0.0)							{							LinearBrent(maxPasses,delta);							if(loggingEachStep)								bullPtr->WriteLogFileForCurrentPosition(0);							//LinearBrent(min(maxPasses,5+powellRound),delta);							if(directions)								{GeneralizeDirection(netDirection);								if(HasAtLeastTwoNonZeroDir(netDirection))									for(i=0;i<nMaximizedParams;i++)										{directions[bestDirInd][i]=directions[nMaximizedParams-1][i];										directions[nMaximizedParams-1][i]=netDirection[i];										}								else	if(DoesntReplicateACurrentDir(netDirection))									for(i=0;i<nMaximizedParams;i++)										{directions[bestDirInd][i]=directions[nMaximizedParams-1][i];										directions[nMaximizedParams-1][i]=netDirection[i];										}								}							}						//else	I don' think I want this else double check  TEMPORARY						SetPowellValsToBrent();						}					else	{UpdateButDontScore(0,likeBeforeThisOpt);							NotifyModelForEveryParameterInCurrDirection();									}					}				else	UpdateButDontScore(0,likeBeforeThisOpt);				}	*/			}		powellRound++;		if(beforePowellLike-tree->likelihood>delta)	parametersChanged=true;		else										parametersChanged=false;	//	}	//TEMPORARY COMMENTING OUT BECAUSE HANDLELSCORE IS NOW CONTROLLING HOW MANY REPS ARE DONE	//while(/*iter<maxPasses && */(prevlike-tree->likelihood)>delta  || !brLenConverged);	for(i=0;i<nMaximizedParams;i++)		oldParamVals[i]=parOrGroupPArray[i]->GetReparameterized();		return tree->likelihood;}	void ParameterAlterationInfo::LinearBrent(int maxPasses,double delta){	//this function is essentially the linmin from Numerical Recipes	//It assumes the point in space that we're at is in PowellParamVals (and PowellParamVals need to get the final point at the end)	// and the direction that we're moving in is in the vector currDirection.  this function optimizes the 	// the distance you want to move in that direction. UpdateParams returns false if a movement that large in that	//direction results in illegal parameter values	Model *tempMod=tree->GetLikeAttributes()->GetModel(0,0);		double initialLike=tree->likelihood;	nTimesNearMaxDist=0;	//the first step is to decide which direction to move in (forward or backward) 	//bool usePosCoeff=PositiveCoefficientTowardMinimum(0.0);	double a,b,c,ascore,bscore,cscore;#ifdef HALPERNTEST	for(;;)		{double y;		cout<<"Direction"<<endl;		cin>>y;		ScoreBrentVals(y);		if(y==0.0)			assert(0);		}#endif		try {GetBracket(&a,&b,&c,&ascore,&bscore,&cscore);		}	catch (TinyParamException x)			{//TEMPORARY 		double beflike=tree->likelihood;		double smallparam=SMALLPARAMTOTRY;		for(;;)			{ScoreBrentVals(smallparam);			if(fabs(tree->likelihood-beflike)>SMALLDOUBLE)				if(tree->likelihood<beflike)					{UpdateButDontScore(SMALLPARAMTOTRY,tree->likelihood);					SetPowellValsToBrent();//return because the movement was really small (or the bracket is really small)					cout<<"Tiny Parameter bumped up and now going to Run Linear Brent"<<endl;					LinearBrent(maxPasses, delta);					return;					}				else					{UpdateButDontScore(0,beflike);					cout<<"Tiny Parameter bumped up and Skipping Linear Brent"<<endl;					return;					}			else				smallparam*=2;			}		return;		}	catch (MaximizationError m)	{throw m;}	catch (...)	{				if(tree->likelihood<initialLike)					{SetPowellValsToBrent();					}				else					{MoveBrentValsAlongLineFromPowellVals(0);//restore initial state (if necessary) and mark the conditional likelihood arrays as dirty					UpdateParams();					NotifyModelForEveryParameterInCurrDirection();	//doesn't catch TaxonWithoutStateException because it shouldn't be thrown when resetting to initial vals					tree->likelihood=initialLike;					}					return;				}	//sort the three values and scores	double temp;	if(a>b)	{temp=ascore;ascore=bscore;bscore=temp;temp=a;a=b;b=temp;}	if(a>c)	{temp=ascore;ascore=cscore;cscore=temp;temp=a;a=c;c=temp;}	if(b>c)	{temp=bscore;bscore=cscore;cscore=temp;temp=b;b=c;c=temp;}		assert(bscore<ascore && bscore<cscore);//requirement of  brent's method		double x=b,w=b,v=b,xscore=bscore,wscore=bscore,vscore=bscore,xm,u,uscore;		int iter=0;	double tolOne,tolTwo,e=0.0,d;	bool firstrep=true;	/*if(powellRound==0)		maxPasses=5;*/	do	{xm=(a+c)/2.0;		tolTwo=2.0*(tolOne=FTOL*fabs(x)+ZEPS);		if(fabs(x-xm)<=(tolTwo-((c-a)/2.0)) && !firstrep)			{UpdateButDontScore(x,xscore);			SetPowellValsToBrent();//return because the movement was really small (or the bracket is really small)			return ;			}		if(fabs(e)>FTOL)//make parabolic fit			{double r,p,q,etemp;			r=(x-w)*(xscore-vscore);			q=(x-v)*(xscore-wscore);			p=(x-v)*q-(x-w)*r;			q=2.0*(q-r);			if(q>0.0)	p=-p;			else		q=-q;			etemp=e;			e=d;			if(fabs(p)>=fabs(q*etemp*0.5) || p<= q*(a-x) || p>=q*(c-x))					d=CGOLDEN*(e=(x>xm ? a-x : c-x));			else	{d=p/q;					 u=x+d;					 if(u-a <tolTwo || c-u <tolTwo)					 	d = ((xm-x)<0.0 ? -tolOne : tolOne);					 }			}		else			d=CGOLDEN*(e=(x>=xm ?a-x : c-x));		u=(fabs(d) >=tolOne ? x+d : x + (d<0.0 ? -tolOne :tolOne));		ScoreBrentVals(u);		uscore=tree->likelihood;		firstrep=false;		if(uscore<=xscore)			{if(u>=x)	a=x;			else		c=x;			v=w;w=x;x=u;			vscore=wscore;wscore=xscore;xscore=uscore;			}		else			{if(u<x)	a=u;			else		c=u;			if(uscore<=wscore || w==x)				{v=w;w=u;				vscore=wscore;wscore=uscore;				}			else				if(uscore<=vscore || v==x || v==w)					{v=u;					vscore=uscore;					}			}		iter++;		}	while(iter<maxPasses && (wscore-xscore)>delta);	tree->likelihood=xscore;	MoveBrentValsAlongLineFromPowellVals(x);	SetPowellValsToBrent();										}void ParameterAlterationInfo::SetPowellValsToBrent(){	assert(UpdateParams());//doesn't catch TaxonWithoutStateException, because it shouldn't be thrown 	if(directions)		for(int i=0;i<nMaximizedParams;i++)			PowellParamVals[i]=parOrGroupPArray[i]->GetReparameterized();	else		{int s=(vecOfRelatedParams[currVecIndex]).size();		for(int i=0;i<s;i++)			{int index=vecOfRelatedParams[currVecIndex][i];			PowellParamVals[index]=parOrGroupPArray[index]->GetReparameterized();			}		}}bool ParameterAlterationInfo::UpdateParams(){	//Tries to update the parameters to the values in the double array BrentParamVal.	//If successfull it alerts the tree and it's like attributes about which parts of the model have changed	//the reason for failure would be that the parameter is taking an illegal value.  Note that the values in BrentParamVal	//are only guaranteed to correspond to the Parameter values if the whole function is completed.	vector<FreqParamGroup *> affectedFPGS;vector<int> vecInd;	if(directions)		{try	{for(int i=0;i<nMaximizedParams;i++)				{				PrevScoredVals[i]=parOrGroupPArray[i]->GetReparameterized();				parOrGroupPArray[i]->SetReparameterized(BrentParamVals[i]);				}			}		catch ( ParamOutOfRangeExcep )			{	return false;			}		for(int i=0;i<nMaximizedParams;i++)			if(fabs(BrentParamVals[i]-PrevScoredVals[i])>FTOL)				{NotifyModelOfChangedParameter(i);				if(!(parOrGroupPArray[i]->isIndependent))						{FreqParamGroup *tempfpg=parOrGroupPArray[i]->GetGroup();					if(	find(affectedFPGS.begin(),affectedFPGS.end(),tempfpg)==affectedFPGS.end())						{affectedFPGS.push_back(tempfpg);						vecInd.push_back(i);						}					}				}		int safpg=affectedFPGS.size();		assert(safpg==vecInd.size());		for(int i=0;i<safpg;i++)			NotifyModelsThatFreqParamChangesAreDone(vecInd[i],affectedFPGS[i]);		return true;		}	//too many parameters	int s=(vecOfRelatedParams[currVecIndex]).size();	try	{for(int i=0;i<s;i++)			{int index=vecOfRelatedParams[currVecIndex][i];			PrevScoredVals[index]=parOrGroupPArray[index]->GetReparameterized();			parOrGroupPArray[index]->SetReparameterized(BrentParamVals[index]);			}		}	catch ( ParamOutOfRangeExcep )		{	return false;		}	for(int i=0;i<s;i++)		{int index=vecOfRelatedParams[currVecIndex][i];		if(fabs(BrentParamVals[index]-PrevScoredVals[index])>FTOL)			{NotifyModelOfChangedParameter(index);			if(!(parOrGroupPArray[index]->isIndependent))					{FreqParamGroup *tempfpg=parOrGroupPArray[index]->GetGroup();				if(	find(affectedFPGS.begin(),affectedFPGS.end(),tempfpg)==affectedFPGS.end())					{affectedFPGS.push_back(tempfpg);					vecInd.push_back(index);					}				}			}		}	int safpg=affectedFPGS.size();	assert(safpg==vecInd.size());	for(int i=0;i<safpg;i++)		NotifyModelsThatFreqParamChangesAreDone(vecInd[i],affectedFPGS[i]);	return true;		}void ParameterAlterationInfo::NotifyModelForEveryParameterInCurrDirection(){	//use after resetting 	for(int i=0;i<nMaximizedParams;i++)		if(fabs(currDirection[i])>FTOL)			NotifyModelOfChangedParameter(i);}void ParameterAlterationInfo::GetBracket(double *a, double *b, double *c,double *ascore,double *bscore,double *cscore){	//The purpose is to find three point in which the middle point has the best score.  If	// the max is not parabolic (at the border of parameter space) the function should 	// set the brent values to the best known point and throw an exception	double maxRight,maxLeft;	double divOfMostSensParam=20.0;//controls size of initial step	double stepSize;		*b=0.0;	*bscore=tree->likelihood;	if(CanMove(true))		if(ThereIsABoundOnMovement(true))			{if(CanMove(false))				if(ThereIsABoundOnMovement(false))					{//bounded to the right, there is a bounded to the left					maxRight = GetMaxLegalCoeff(0.0,true);					stepSize = GetAbsValOfCoeffRelativeToMostSensParam(0.0); stepSize = (stepSize<maxRight ? stepSize : maxRight); stepSize/=divOfMostSensParam;					try	{MoveToFirstSignificantlyDifferentSpot(b,c,bscore,cscore,stepSize,maxRight);						}					catch	(LikePlateau)							{*c=maxRight;						*cscore=tree->likelihood;						ResetToPowellValues();						maxLeft=GetMaxLegalCoeff(0.0,false);						if(*cscore<*bscore)							CreateThirdPointInMiddle(c,b,a,cscore,bscore,ascore);						else if(*cscore>*bscore)							{stepSize*=divOfMostSensParam; stepSize = (stepSize<maxLeft ? stepSize : maxLeft); stepSize/=divOfMostSensParam;							GetBracketFromThisDirection(-maxLeft,-stepSize,2,b,c,a,bscore,cscore,ascore);							}						else							{stepSize*=divOfMostSensParam; stepSize = (stepSize<maxLeft ? stepSize : maxLeft); stepSize/=divOfMostSensParam;							GetBracketFromThisDirection(-maxLeft,-stepSize,1,b,c,a,bscore,cscore,ascore);							}						return;						}					catch	(CloseToMaxDistException)						{ScoreBrentVals(maxRight);						*b=maxRight;						*bscore=tree->likelihood;						ResetToPowellValues();						maxLeft=GetMaxLegalCoeff(0.0,false);						stepSize*=divOfMostSensParam; stepSize = (stepSize<maxLeft ? stepSize : maxLeft); stepSize/=divOfMostSensParam;						GetBracketFromThisDirection(-maxLeft,-stepSize,1,b,c,a,bscore,cscore,ascore);						return;						}					ResetToPowellValues();					maxLeft=GetMaxLegalCoeff(0.0,false);					if(*cscore>*bscore)						{stepSize*=divOfMostSensParam;stepSize = (stepSize<maxLeft ? stepSize : maxLeft);stepSize/=divOfMostSensParam;						GetBracketFromThisDirection(-maxLeft,-stepSize,2,b,c,a,bscore,cscore,ascore);						}					else							GetBracketFromThisDirection(maxRight,stepSize,2,c,b,a,cscore,bscore,ascore);					return;					}				else					{//bounded to the right, unbounded on the left					maxRight = GetMaxLegalCoeff(0.0,true);					stepSize = GetAbsValOfCoeffRelativeToMostSensParam(0.0); stepSize = (stepSize<maxRight ? stepSize : maxRight); stepSize/=divOfMostSensParam;					try	{MoveToFirstSignificantlyDifferentSpot(b,c,bscore,cscore,stepSize,maxRight);						}					catch	(LikePlateau)							{*c=maxRight;						*cscore=tree->likelihood;						if(*cscore<*bscore)							CreateThirdPointInMiddle(c,b,a,cscore,bscore,ascore);						else	if(*cscore>*bscore)							GetBracketFromThisDirection(1,-stepSize,2,b,c,a,bscore,cscore,ascore);						else							GetBracketFromThisDirection(1,-stepSize,1,b,c,a,bscore,cscore,ascore);						return;						}					catch	(CloseToMaxDistException)						{ScoreBrentVals(maxRight);						*b=maxRight;						*bscore=tree->likelihood;						GetBracketFromThisDirection(1,-stepSize,1,b,c,a,bscore,cscore,ascore);						return;						}					if(*cscore>*bscore)						GetBracketFromThisDirection(1.0,-stepSize,2,b,c,a,bscore,cscore,ascore);					else							GetBracketFromThisDirection(maxRight,stepSize,2,c,b,a,cscore,bscore,ascore);					return;					}			else				{//bounded to the right, cant move left				maxRight = GetMaxLegalCoeff(0.0,true);				stepSize = GetAbsValOfCoeffRelativeToMostSensParam(0.0); stepSize = (stepSize<maxRight ? stepSize : maxRight); stepSize/=divOfMostSensParam;				try	{MoveToFirstSignificantlyDifferentSpot(b,c,bscore,cscore,stepSize,maxRight);					}				catch	(LikePlateau)						{*c=maxRight;					*cscore=tree->likelihood;					CreateThirdPointInMiddle(c,b,a,cscore,bscore,ascore);					return;					}				catch	(CloseToMaxDistException)					{ScoreBrentVals(maxRight);					throw AtPeakLike();					}				if(*cscore>*bscore)					CreateThirdPointInMiddle(c,b,a,cscore,bscore,ascore);				else						GetBracketFromThisDirection(maxRight,stepSize,2,c,b,a,cscore,bscore,ascore);				return;				}			}		else			{if(CanMove(false))				if(ThereIsABoundOnMovement(false))					{//unbounded to the right,there is a bounded to the left					maxLeft=GetMaxLegalCoeff(0.0,false);					stepSize = GetAbsValOfCoeffRelativeToMostSensParam(0.0); stepSize = (stepSize<maxLeft ? stepSize : maxLeft); stepSize/=divOfMostSensParam;					try	{MoveToFirstSignificantlyDifferentSpot(b,a,bscore,ascore,-stepSize,-maxLeft);						}					catch	(LikePlateau)							{*a=maxLeft;						*ascore=tree->likelihood;						if(*ascore<*bscore)							CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);						else	if(*ascore>*bscore)							GetBracketFromThisDirection(-1,stepSize,2,b,a,c,bscore,ascore,cscore);						else							GetBracketFromThisDirection(-1,stepSize,1,b,a,c,bscore,ascore,cscore);						return;						}					catch	(CloseToMaxDistException)						{ScoreBrentVals(maxLeft);						*b=maxLeft;						*bscore=tree->likelihood;						GetBracketFromThisDirection(-1,stepSize,1,b,c,a,bscore,cscore,ascore);						return;						}					if(*ascore>*bscore)						GetBracketFromThisDirection(-1,stepSize,2,b,a,c,bscore,ascore,cscore);					else							GetBracketFromThisDirection(-maxLeft,-stepSize,2,a,b,c,ascore,bscore,cscore);					return;					}				else					{//unbounded to the right, unbounded on the left					stepSize = GetAbsValOfCoeffRelativeToMostSensParam(0.0); stepSize/=divOfMostSensParam;					try	{MoveToFirstSignificantlyDifferentSpot(b,a,bscore,ascore,-stepSize,1);						}					catch	(LikePlateau)							{*a=*b-stepSize;						*ascore=tree->likelihood;						if(*ascore<*bscore)							CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);						else if(*ascore>*bscore)							GetBracketFromThisDirection(-1,stepSize,2,b,a,c,bscore,ascore,cscore);						else							GetBracketFromThisDirection(-1,stepSize,1,b,a,c,bscore,ascore,cscore);						return;						}					if(*ascore>*bscore)						GetBracketFromThisDirection(-1,stepSize,2,b,a,c,bscore,ascore,cscore);					else							GetBracketFromThisDirection(1,-stepSize,2,a,b,c,ascore,bscore,cscore);					return;					}			else				{//unbounded to the right, cant move left				stepSize = GetAbsValOfCoeffRelativeToMostSensParam(0.0); stepSize/=divOfMostSensParam;				try	{MoveToFirstSignificantlyDifferentSpot(b,c,bscore,cscore,stepSize,-1);					}				catch	(LikePlateau)						{*c=*b+stepSize;					*cscore=tree->likelihood;					CreateThirdPointInMiddle(c,b,a,cscore,bscore,ascore);					return;					}				if(*cscore>*bscore)					CreateThirdPointInMiddle(c,b,a,cscore,bscore,ascore);				else						GetBracketFromThisDirection(-1,stepSize,2,c,b,a,cscore,bscore,ascore);				return;				}			}	else		{if(CanMove(false))			if(ThereIsABoundOnMovement(false))				{//can't move right,  there is a bounded to the left				maxLeft=GetMaxLegalCoeff(0.0,false);				stepSize = GetAbsValOfCoeffRelativeToMostSensParam(0.0); stepSize = (stepSize<maxLeft ? stepSize : maxLeft); stepSize/=divOfMostSensParam;				try	{MoveToFirstSignificantlyDifferentSpot(b,a,bscore,ascore,-stepSize,-maxLeft);					}				catch	(LikePlateau)						{*a=maxLeft;					*ascore=tree->likelihood;					CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);					return;					}				catch	(CloseToMaxDistException)					{ScoreBrentVals(maxLeft);					throw AtPeakLike();					}				if(*ascore>*bscore)					CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);				else						GetBracketFromThisDirection(-maxLeft,-stepSize,2,a,b,c,ascore,bscore,cscore);				return;				}			else				{//at right max , unbounded on the left				stepSize = GetAbsValOfCoeffRelativeToMostSensParam(0.0);				stepSize/=divOfMostSensParam;				try	{MoveToFirstSignificantlyDifferentSpot(b,a,bscore,ascore,-stepSize,1);					}				catch	(LikePlateau)						{*a=maxLeft;					*ascore=tree->likelihood;					CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);					return;					}				if(*ascore>*bscore)					CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);				else						GetBracketFromThisDirection(1,-stepSize,2,a,b,c,ascore,bscore,cscore);				return;				}		else			throw CantMove();		}}void ParameterAlterationInfo::GetBracketFromThisDirection(double maxDist,double stepSize,int numPtsToTrust,double *a, double *b, double *c,double *ascore,double *bscore,double *cscore){	//the sign of stepSize determines which direction you are moving in	//the purpose of this function is to quickly find a bracketing of point	//1<2<3 or 1>2>3 such that 2score<3score and 2score<1score or throw a plateau exception 	//a is the best (or only point so far)		stepSize=GetReasonableStepSize(maxDist,stepSize,*a);		if(numPtsToTrust==1)		{try	{MoveToFirstSignificantlyDifferentSpot(a,b,ascore,bscore,stepSize,maxDist);				}		catch	(LikePlateau)			{*b=*a+stepSize;			*bscore=tree->likelihood;			CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);			return;			}		catch	(CloseToMaxDistException)			{ScoreBrentVals(*a+maxDist);			if(tree->likelihood>*ascore)				UpdateButDontScore(*a,*ascore);			throw AtPeakLike();				}		if(*bscore>*ascore)			CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);		else			GetBracketFromThisDirection(maxDist,stepSize,2,b,a,c,bscore,ascore,cscore);		return;		}		//a and b are already scored.	assert(*bscore>*ascore);	if((maxDist<0  && stepSize<0) || (maxDist>0  && stepSize>0))		{//bounded		try	{MoveToFirstSignificantlyDifferentSpot(a,c,ascore,cscore,stepSize,maxDist);//these 4 lines should cover most cases (if the inital estimate isn't bad and the stepSize is appropriate			}		catch	(LikePlateau)				{CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);				return;				}		catch	(CloseToMaxDistException)				{CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);				return;				}		if(*cscore>*ascore)			return;		if(maxDist/stepSize>2.0)			GetBracketFromThisDirection(maxDist,stepSize*STEPSIZEMULTIPLIER,2,c,a,b,cscore,ascore,bscore);		else			{nTimesNearMaxDist++;//keep getting better likelihoods as we move in one direction			if(nTimesNearMaxDist<4)				GetBracketFromThisDirection(maxDist,(maxDist-(*c-*a)+stepSize)/2.0,2,c,a,b,cscore,ascore,bscore);			else				{ScoreBrentVals(maxDist);				*c=maxDist;				*cscore=tree->likelihood;				if(*cscore<*ascore)					CreateThirdPointInMiddle(a,c,b,ascore,cscore,bscore);				}			}		return;		}//not bounded	try	{MoveToFirstSignificantlyDifferentSpot(a,c,ascore,cscore,stepSize,maxDist);		}	catch	(LikePlateau)				{CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);				return;				}	if(*cscore>*ascore)			return;	stepSize=*c-*a;	for(int i=0;i<MAXSTEPSIZEBUMPS;i++)		{*b=*a;		*a=*c;		*bscore=*ascore;		*ascore=*cscore;		stepSize*=STEPSIZEMULTIPLIER;		try	{MoveToFirstSignificantlyDifferentSpot(a,c,ascore,cscore,stepSize*2,maxDist);			if(*cscore>*ascore)				return;				}		catch (LikePlateau){}		}	*b=*a;	*a=*c;	*bscore=*ascore;	*ascore=*cscore;	if(stepSize>0.0)		*c=ExtremeValueOfCoeff(true);	else		*c=ExtremeValueOfCoeff(false);	try	{MoveToFirstSignificantlyDifferentSpot(a,c,ascore,cscore,(*c-*a)*2,(*a-*c));//maxdist is just set so it will be unbounded		}	catch	(LikePlateau)				{CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore);				return;				}	if(*cscore>*ascore);		return;	throw AtPeakLike();	return;	}void ParameterAlterationInfo::CreateThirdPointInMiddle(double *a,double *b,double *c,double *ascore,double *bscore,double *cscore){	if(*ascore>*bscore)		{double *temp;		temp=ascore;		ascore=bscore;		bscore=temp;		temp=a;		a=b;		b=temp;		}	double stepSize=(*b-*a)/2.0;	*c=*a+stepSize;	ScoreBrentVals(*c);	*cscore=tree->likelihood;	if(*cscore<*ascore)		return;	if(PointsAreFarEnoughApart(*a,*a+stepSize) && PointsAreFarEnoughApart(*b,*b-stepSize))		{CreateThirdPointInMiddle(a,c,b,ascore,cscore,bscore);		return;		}	else		{UpdateButDontScore(*a,*ascore);		throw AtPeakLike();		}		assert(0);	/*	*c=MoveToFirstSignificantlyDifferentSpot(*a,CGOLDEN*(*c-*a)/(1+(decreaseInStepSizePerLevel*(double) level)),(1-CGOLDEN)*(*c-*a));	*cscore=tree->likelihood;	if(*cscore<*ascore && *cscore<*bscore)	return;			//only gets here in the unexpected event that you are on a hill in between the putatitive bracket	//the tact taken is to check out the two brackets, if neither is lower throw an exception	//if(level==10)		//	throw MaximizationError();		if(*cscore>*ascore && *cscore>*bscore)		{double sa,sb,sc,sascore,sbscore,scscore;		sa=*a;		sc=*c;		sascore=*ascore;		scscore=*cscore;		CreateThirdPointInMiddle(&sa,&sc,&sb,&sascore,&scscore,&sbscore,level+1);				double ta,tb,tc,tascore,tbscore,tcscore;		tb=*b;		tc=*c;		tbscore=*bscore;		tcscore=*cscore;		CreateThirdPointInMiddle(&tc,&tb,&ta,&tcscore,&tbscore,&tascore,level+1);		if(sbscore<tascore)			{*a=sa;			*b=sb;			*c=sc;			*ascore=sascore;			*bscore=sbscore;			*cscore=scscore;			}		else			{*a=ta;			*b=tb;			*c=tc;			*ascore=tascore;			*bscore=tbscore;			*cscore=tcscore;			}		}	else 		{//try the point closest to the best point		if(*bscore>*ascore)			{*b=MoveToFirstSignificantlyDifferentSpot(*a,(*c-*a)/10.0,(*c-*a)*(.91));//will score a max of 9 point (if the surface is really flat)			*bscore=tree->likelihood;			if(*bscore>*ascore)				if(*bscore>*cscore)					CreateThirdPointInMiddle(a,c,b,ascore,cscore,bscore,level+1);//problem peak in between				else					CreateThirdPointInMiddle(a,b,c,ascore,bscore,cscore,level+1);			}		else			{*a=MoveToFirstSignificantlyDifferentSpot(*b,(*c-*b)/10.0,(*c-*b)*(.91));//will score a max of 9 point (if the surface is really flat)			*ascore=tree->likelihood;			if(*ascore>*bscore)				if(*ascore>*cscore)					CreateThirdPointInMiddle(b,c,a,bscore,cscore,ascore,level+1);//problem peak in between				else					CreateThirdPointInMiddle(b,a,c,bscore,ascore,cscore,level+1);			}		}*/}void ParameterAlterationInfo::MoveToFirstSignificantlyDifferentSpot(double* current,double *future,double* currscore,double *futurescore,double stepSize,double maxDist){	//An implicit assumption is that the movement is always going away from zero (which is the start point of the GetBracket function)	//Tries to find a point that is significantly different from pt in both distance and Lscore	int counter=0;	//new make sure that stepSize and MaxDist are far enough, based on PointsAreFarEnoughApart()	stepSize=GetReasonableStepSize(maxDist,stepSize,*current);	int i=1;	if((maxDist<0  && stepSize<0) || (maxDist>0  && stepSize>0))		{//bounded		while(fabs(*current+i*stepSize)<=fabs(maxDist))			{*future=*current+i*stepSize;			ScoreBrentVals(*future);			if(fabs((*currscore)-tree->likelihood)>SMALLDOUBLE)				{*futurescore=tree->likelihood;				return;				}			i++;			stepSize*=STEPSIZEMULTIPLIER;			}		*future=maxDist;		ScoreBrentVals(*future);		*futurescore=tree->likelihood;		if(fabs((*currscore)-tree->likelihood)<=SMALLDOUBLE)			throw LikePlateau();		return;		}	while(i<MAXSTEPSIZEBUMPS)//scores over a range of 1 milliontimes the step size		{*future=*current+i*stepSize;		ScoreBrentVals(*future);		if(fabs((*currscore)-tree->likelihood)>SMALLDOUBLE)			{*futurescore=tree->likelihood;			return;			}		stepSize*=STEPSIZEMULTIPLIER;		i++;		}	UpdateButDontScore(*current,*currscore);	throw LikePlateau();	return;//never get here	}/*{	//Tries to find a point that is significantly different from pt in both distance and Lscore	int counter=0;	//new make sure that stepSize and MaxDist are far enough, based on PointsAreFarEnoughApart()	stepSize=GetReasonableStepSize(maxDist,stepSize,pt);	double initialLike=tree->likelihood;	int i=1;	if((maxDist<0  && stepSize<0) || (maxDist>0  && stepSize>0))		{//bounded		while(fabs(i*stepSize)<=fabs(maxDist))			{ScoreBrentVals(pt+i*stepSize);			if(fabs(initialLike-tree->likelihood)>SMALLDOUBLE)				return (pt+i*stepSize);			i++;			}		ScoreBrentVals(pt+maxDist);		if(fabs(initialLike-tree->likelihood)<=SMALLDOUBLE)			throw LikePlateau();		return maxDist;		}	while(i<MAXSTEPSIZEBUMPS)//scores over a range of 1 milliontimes the step size		{ScoreBrentVals(pt+stepSize);		if(fabs(initialLike-tree->likelihood)>SMALLDOUBLE)			return (pt+stepSize);		stepSize*=STEPSIZEMULTIPLIER;		i++;		}	UpdateButDontScore(pt,initialLike);	throw LikePlateau();	return 0.0;//never get here	}*/void ParameterAlterationInfo::ScoreBrentVals(double coeff){	MoveBrentValsAlongLineFromPowellVals(coeff);	try	{bool success= UpdateParams();		if(!success)	assert(0);		}	catch (TaxonWithoutStateException)		{tree->likelihood=MAXDOUBLE;		return;		}	//bullPtr->WriteLogFileForCurrentPosition(currpos);	try	{tree->LScoreDirtyParts();}	catch (LikeUnderFlow)	{tree->likelihood=MAXDOUBLE;}}		void ParameterAlterationInfo::UpdateButDontScore(double coeff,double prevscore){	MoveBrentValsAlongLineFromPowellVals(coeff);	assert(UpdateParams());//doesn't catch TaxonWithoutState because it shouldn't be thrown	tree->likelihood=prevscore;}		void ParameterAlterationInfo::NotifyModelOfChangedParameter(int cm){		int n=affectedModelsInfo[affectedConversionIndex[cm]].size();	if(parOrGroupPArray[cm]->isIndependent)		for(int i=0;i<n;i++)			tree->NotifyModelOfChangedParameter(affectedModelsInfo[affectedConversionIndex[cm]][i],parOrGroupPArray[cm]->GetParameter());	else		for(int i=0;i<n;i++)			tree->NotifyModelOfChangedParameter(affectedModelsInfo[affectedConversionIndex[cm]][i],parOrGroupPArray[cm]->GetGroup());}void ParameterAlterationInfo::NotifyModelsThatFreqParamChangesAreDone(int cm,FreqParamGroup *fpg){	int n=affectedModelsInfo[affectedConversionIndex[cm]].size();	for(int i=0;i<n;i++)		tree->NotifyModelsThatFreqParamChangesAreDone(affectedModelsInfo[affectedConversionIndex[cm]][i],fpg);}#undef NOISYvoid ParameterAlterationInfo::MoveBrentValsAlongLineFromPowellVals(double coeff){	if(directions)		for(int i=0;i<nMaximizedParams;i++)			BrentParamVals[i]=PowellParamVals[i]+coeff*currDirection[i];	else		{int s=(vecOfRelatedParams[currVecIndex]).size();		for(int i=0;i<s;i++)			{int index=vecOfRelatedParams[currVecIndex][i];			BrentParamVals[index]=PowellParamVals[index]+coeff*currDirection[index];			}		}			#ifdef NOISY	ofstream logfilestr;	logfilestr.open("OptimizationLog",ios::app);	logfilestr<<setprecision(15);	if(directions)		{for(int i=0;i<nMaximizedParams;i++)			if(currDirection[i])				{cout<<"Parameter "<<i<<" going from "<<PowellParamVals[i]<<" to "<<BrentParamVals[i]<<endl;				logfilestr<<"Parameter "<<i<<" going from "<<PowellParamVals[i]<<" to "<<BrentParamVals[i]<<endl;				}		}	else		{int s=(vecOfRelatedParams[currVecIndex]).size();		cout<<"( ";		logfilestr<<"( ";		for(int i=0;i<s;i++)			{int index=vecOfRelatedParams[currVecIndex][i];			if(currDirection[index])				{cout<<BrentParamVals[index]<<" ";				logfilestr<<BrentParamVals[index]<<" ";				}			}		cout<<")\n";		logfilestr<<")\n";		}	logfilestr.close();#endif}void ParameterAlterationInfo::ResetToPowellValues(){	if(directions)		for(int i=0;i<nMaximizedParams;i++)			BrentParamVals[i]=PowellParamVals[i];	else		{int s=(vecOfRelatedParams[currVecIndex]).size();		for(int i=0;i<s;i++)			{int index=vecOfRelatedParams[currVecIndex][i];			BrentParamVals[index]=PowellParamVals[index];			}		}	assert(UpdateParams());//doesn't catch TaxonWithoutStateException, because it shouldn't be thrown}					bool ParameterAlterationInfo::CanMove(bool dir){	bool cm=true;	for(int i=0;i<nMaximizedParams;i++)		if(currDirection[i]!=0.0)			if(fabs(currDirection[i])<SMALLDOUBLE)				currDirection[i]=0.0;			else				{if((currDirection[i]>0.0 && dir) || (currDirection[i]<0.0 && !dir))					{if(parOrGroupPArray[i]->HasMaximum())						{if(parOrGroupPArray[i]->GetReparameterized()>=(parOrGroupPArray[i]->GetReparameterizedMax()-SMALLDOUBLE))							return false;						}					}				else					if(parOrGroupPArray[i]->HasMinimum())						{if(parOrGroupPArray[i]->GetReparameterized()<=(parOrGroupPArray[i]->GetReparameterizedMin()+SMALLDOUBLE))							return false;						}				}	return true;}bool ParameterAlterationInfo::ThereIsABoundOnMovement(bool dir){	bool cm=false;	for(int i=0;i<nMaximizedParams;i++)		if(fabs(currDirection[i])>SMALLDOUBLE)			{if((currDirection[i]>0.0 && dir) || (currDirection[i]<0.0 && !dir))				{if(parOrGroupPArray[i]->HasMaximum())					return true;				}			else				{if(parOrGroupPArray[i]->HasMinimum())					return true;				}			}	return false;}double ParameterAlterationInfo::GetMaxLegalCoeff(double pt,bool dir){	double maxc=0.0,temp,thismax,thismin;	bool maxadded=false;	for(int i=0;i<nMaximizedParams;i++)		if(fabs(currDirection[i])>SMALLDOUBLE)			{if((currDirection[i]>0.0 && dir) || (currDirection[i]<0.0 && !dir))				{if(parOrGroupPArray[i]->HasMaximum())					{thismax=parOrGroupPArray[i]->GetReparameterizedMax();					thismax-=pt*currDirection[i];					thismax-=parOrGroupPArray[i]->GetReparameterized();					temp=fabs(thismax/currDirection[i]);					if(!maxadded)	{maxadded=true;	maxc=temp;}					else	if(temp<maxc)	maxc=temp;					}				}			else				if(parOrGroupPArray[i]->HasMinimum())					{thismin=parOrGroupPArray[i]->GetReparameterizedMin();					thismin-=pt*currDirection[i];					thismin-=parOrGroupPArray[i]->GetReparameterized();					temp=fabs(thismin/currDirection[i]);					if(!maxadded)	{maxadded=true;	maxc=temp;}					else	if(temp<maxc)	maxc=temp;					}			}	return maxc;}double ParameterAlterationInfo::GetAbsValOfCoeffRelativeToMostSensParam(double pt){	double c=0.0,temp;	//TEMPoRARY  its just an ad hoc way of picking a step size relative to the size of the parameter and the magnitude of its	//coefficient in the currDirection array	bool first=true;	bool tinyParam=true;	if(directions)		{for(int i=0;i<nMaximizedParams;i++)			{if(fabs(currDirection[i])>SMALLDOUBLE)				{temp=parOrGroupPArray[i]->GetReparameterized()+pt*currDirection[i];				if(first)					{if(fabs(currDirection[i])>0.0 && temp>TINYPARAMCUTOFF)						tinyParam=false;					first=false;					if(fabs(temp)<SMALLDOUBLE)						c=fabs(currDirection[i]/10.0);					else						c=fabs(temp/currDirection[i]);					}				else					{if(currDirection[i]>0.0 && temp>TINYPARAMCUTOFF)						tinyParam=false;					if(fabs(temp)<SMALLDOUBLE)						{if(c>fabs(currDirection[i]/10.0))							c=fabs(currDirection[i]/10.0);						}					else						{if(c>fabs(temp/currDirection[i]))							c=fabs(temp/currDirection[i]);						}					}				}			}		}	else		{int s=(vecOfRelatedParams[currVecIndex]).size();		for(int index=0;index<s;index++)			{int i=vecOfRelatedParams[currVecIndex][index];			if(fabs(currDirection[i])>SMALLDOUBLE)				{temp=parOrGroupPArray[i]->GetReparameterized()+pt*currDirection[i];				if(first)					{if(fabs(currDirection[i])>0.0 && temp>TINYPARAMCUTOFF)						tinyParam=false;					first=false;					if(fabs(temp)<SMALLDOUBLE)						c=fabs(currDirection[i]/10.0);					else						c=fabs(temp/currDirection[i]);					}				else					{if(currDirection[i]>0.0 && temp>TINYPARAMCUTOFF)						tinyParam=false;					if(fabs(temp)<SMALLDOUBLE)						{if(c>fabs(currDirection[i]/10.0))							c=fabs(currDirection[i]/10.0);						}					else						{if(c>fabs(temp/currDirection[i]))							c=fabs(temp/currDirection[i]);						}					}				}			}		}	if(tinyParam)		throw TinyParamException();	if(first)		{		cout<<"We're on the road to nowhere"<<endl;		throw	MTHException("Entered unwritten code GetAbsValOfCoeffRelativeToMostSensParam" );		}	return c;}#define LARGEPARAMVAL  1000000double ParameterAlterationInfo::ExtremeValueOfCoeff(bool dir){	double maxc=0.0,temp;	for(int i=0;i<nMaximizedParams;i++)		if(fabs(currDirection[i])>SMALLDOUBLE)			{if((currDirection[i]>0.0 && dir) || (currDirection[i]<0.0 && !dir))				temp=fabs(LARGEPARAMVAL/currDirection[i]);			else				temp=fabs((parOrGroupPArray[i]->GetReparameterized())/currDirection[i]);			if(temp>maxc)	maxc=temp;			}	return maxc;}double *ParameterAlterationInfo::GetReparameterizedDirection(int d){	//reparameterizes direction[i] into reparmDirection, and returns it	vector<FreqParamGroup*> modifiedFPGs;	if(directions)		{for(int i=0;i<nMaximizedParams;i++)			{if(fabs(directions[d][i])>SMALLDOUBLE)				{if(parOrGroupPArray[i]->GetGroup())					{bool found=false;					for(int j=0;(j<modifiedFPGs.size() && !found);j++)						if(modifiedFPGs[j]==parOrGroupPArray[i]->GetGroup())							found=true;					if(!found)						modifiedFPGs.push_back(parOrGroupPArray[i]->GetGroup());					}				else	reparamDirection[i]=directions[d][i];				}			else reparamDirection[i]=0.0;			}		if(modifiedFPGs.size())			{for(int j=0;j<modifiedFPGs.size();j++)				{bool done=false;				for(int i=0;(!done &&i<nMaximizedParams);i++)					if(parOrGroupPArray[i]->GetGroup()==modifiedFPGs[j])						{done=true;						ReparameterizeThisFreqGroup(i,d,modifiedFPGs[j]->GetNParams());						}				}			}			}	else		{int overallindex=(vecOfRelatedParams[currVecIndex])[d];		for(int i=0;i<nMaximizedParams;i++)			{if(fabs(smallDir[d][i])>SMALLDOUBLE)				{if(parOrGroupPArray[i]->GetGroup())					{bool found=false;					for(int j=0;(j<modifiedFPGs.size() && !found);j++)						if(modifiedFPGs[j]==parOrGroupPArray[i]->GetGroup())							found=true;					if(!found)						modifiedFPGs.push_back(parOrGroupPArray[i]->GetGroup());					}				else	reparamDirection[i]=smallDir[d][i];				}			else					reparamDirection[i]=smallDir[d][i]=0.0;			}		if(modifiedFPGs.size())			{for(int j=0;j<modifiedFPGs.size();j++)				{bool done=false;				for(int i=0;(!done &&i<nMaximizedParams);i++)					if(parOrGroupPArray[i]->GetGroup()==modifiedFPGs[j])						{done=true;						ReparameterizeThisFreqGroup(i,d,modifiedFPGs[j]->GetNParams());						}				}			}			}	return reparamDirection;}void ParameterAlterationInfo::ReparameterizeThisFreqGroup(int firstmem,int dir,int n){	assert(n>1);	for(int i=0;i<n;i++)		reparamDirection[firstmem+i]=0.0;	for(int i=0;i<n;i++)		{double oneMinus=1.0-parOrGroupPArray[firstmem+i]->GetReparameterized();		if(directions)			{if(oneMinus<SMALLDOUBLE)				{for(int j=0;j<n;j++)					if(j==i)	reparamDirection[firstmem+j]+=(directions[dir][firstmem+i]);					else		reparamDirection[firstmem+j]-=(directions[dir][firstmem+i])/(n-1);				}			else				{for(int j=0;j<n;j++)					if(j==i)	reparamDirection[firstmem+j]+=(directions[dir][firstmem+i]);					else		reparamDirection[firstmem+j]-=(directions[dir][firstmem+i])*(parOrGroupPArray[firstmem+j]->GetReparameterized()/(oneMinus));				}			}		else			{if(oneMinus<SMALLDOUBLE)				{for(int j=0;j<n;j++)					if(j==i)	reparamDirection[firstmem+j]+=(smallDir[dir][firstmem+i]);					else		reparamDirection[firstmem+j]-=(smallDir[dir][firstmem+i])/(n-1);				}			else				{for(int j=0;j<n;j++)					if(j==i)	reparamDirection[firstmem+j]+=(smallDir[dir][firstmem+i]);					else		reparamDirection[firstmem+j]-=(smallDir[dir][firstmem+i])*(parOrGroupPArray[firstmem+j]->GetReparameterized()/(oneMinus));				}			}		}}void ParameterAlterationInfo::GeneralizeDirection(double *d){	vector<FreqParamGroup*> modifiedFPGs;	for(int i=0;i<nMaximizedParams;i++)		{if(fabs(d[i])>SMALLDOUBLE && parOrGroupPArray[i]->GetGroup())			{bool found=false;			for(int j=0;(j<modifiedFPGs.size() && !found);j++)				if(modifiedFPGs[j]==parOrGroupPArray[i]->GetGroup())					found=true;			if(!found)				modifiedFPGs.push_back(parOrGroupPArray[i]->GetGroup());			}		}	if(modifiedFPGs.size())		{for(int j=0;j<modifiedFPGs.size();j++)			{bool done=false;			for(int i=0;(!done &&i<nMaximizedParams);i++)				if(parOrGroupPArray[i]->GetGroup()==modifiedFPGs[j])					{done=true;					GeneralizeThisGroup(i,modifiedFPGs[j]->GetNParams(),(d+i));					}			}		}		double maxdist=0.0;	for(int i=0;i<nMaximizedParams;i++)		if(maxdist<fabs(d[i]))			maxdist=fabs(d[i]);	for(int i=0;i<nMaximizedParams;i++)		if(d[i]!=0.0)			d[i]/=maxdist;}void ParameterAlterationInfo::GeneralizeThisGroup(int firstmem,int n,double *dest){	assert(n>1);	for(int i=0;i<n;i++)		{double oneMinus=1.0-parOrGroupPArray[firstmem+i]->GetReparameterized();		if(oneMinus<SMALLDOUBLE)			{for(int j=0;j<n;j++)				if(j==i)	linearAlgWorkSpace[j][i]=1.0;				else		linearAlgWorkSpace[j][i]=1.0/(n-1);			}		else			{for(int j=0;j<n;j++)				if(j==i)	linearAlgWorkSpace[j][i]=1.0;				else		linearAlgWorkSpace[j][i]=(parOrGroupPArray[firstmem+j]->GetReparameterized()/(oneMinus));			}		linearAlgWorkSpace[n][i]=dest[i];		}	GaussJordanElimination(linearAlgWorkSpace,dest,n);}bool ParameterAlterationInfo::HasAtLeastOneNonZeroDir(double *d){	for(int i=0;i<nMaximizedParams;i++)		if(fabs(d[i])>SMALLDOUBLE)			return true;	return false;}bool ParameterAlterationInfo::HasAtLeastTwoNonZeroDir(double *d){	bool atleastOne=false;	for(int i=0;i<nMaximizedParams;i++)		if(fabs(d[i])>SMALLDOUBLE)			if(atleastOne)	return true;			else 			atleastOne=true;	return false;}bool ParameterAlterationInfo::DoesntReplicateACurrentDir(double *d){	assert(directions);	for(int i=0;i<nMaximizedParams;i++)		{bool stillReplicate=true,firstnonzero=true;		double ratio;		for(int j=0;(stillReplicate && j<nMaximizedParams);j++)			{if(fabs(directions[i][j])>SMALLDOUBLE)				{if(fabs(d[j])>SMALLDOUBLE)					{if(firstnonzero)						{firstnonzero=false;						ratio=directions[i][j]/d[j];						}					else						if(fabs(d[j]*ratio-directions[i][j])>SMALLDOUBLE)							stillReplicate=false;					}				else	stillReplicate=false;				}			else if(fabs(d[j])>SMALLDOUBLE)					stillReplicate=false;			}		if(stillReplicate)				return false;		}			return true;}/*bool ParameterAlterationInfo::PositiveCoefficientTowardMinimum(double d){	//This function tries to determine which whether to use positive or negative coefficients along the netDirection	//by looking at a point close to where the function already is (d is the original point)	if(CanMove(d,true))		{		try	{bool ret=true;			ret=ScoreImprovesInFirstPoint(d,true);			if(ret)	return true;			}		catch		double maxc=GetMaxLegalCoeff(d,true);		double startingc=GetTinyCoeff(d,true);		double multiplier=exp((log(maxc)-log(startingc))/100.0);//sets up a multiplier so the next loop can only go ten times		while(startingc<=(maxc*(1.0+SMALLDOUBLE))			{MoveBrentValsAlongLineFromPowellVals(startingc+d);			if(UpdateParams())				{double newlike = tree->LScoreDirtyParts();				if(fabs(newlike-initialLike)>FTOL)					{if(newlike<initialLike)	return true;//Likelihood getting better in positive direction					//likelihood gets worse in positive direction, makes sure that it gets better in the other direction					if(CanMove(d,false))						{						}					throw CantMove();					}				}			}		if(CanMove(d,false))			{			}		throw LikePlateau()		}	if(CanMove(d,false))		{		}	throw CantMove();	return false;	double initialLike=t->likelihood;		double maxvect=fabs(currDirection[0]);	for(int i=1;i<nMaximizedParams;i++)		if(fabs(currDirection[i])>maxvect)			maxvect=fabs(currDirection[i]);	//start with a positive small coefficient	double ax=.0001/maxvect;	bool done=false,divided=false,multiplied=false;	while(!done)		{MoveBrentValsAlongLineFromPowellVals(ax+d);		if(UpdateParams(t))			{double newlike = t->LScoreDirtyParts();			if(fabs(newlike-initialLike)<FTOL)				{if(divided)					if(ax<0)	throw CantMove();					else		ax*=2;				}			}		else	{ax/=1.1;				divided=true;				}		}	return false;}*//*bool ParameterAlterationInfo::ScoreImprovesInFirstPoint(double d,bool dir){	//this function assumes that a the parameters can move in the requested direction	double initialLike=tree->likelihood;	double maxc=GetMaxLegalCoeff(d,dir);	double startingc=GetTinyCoeff(d,dir);	double multiplier=exp((log(maxc)-log(startingc))/100.0);//sets up a multiplier so the next loop can only go ten times	while((dir && startingc<maxc) || (!dir && startingc>maxc))		{MoveBrentValsAlongLineFromPowellVals(startingc+d);		assert(UpdateParams();//should return true if GetMaxLegalCoeff is doing its job			{double newlike = tree->LScoreDirtyParts();			if(fabs(newlike-initialLike)>FTOL)				{if(newlike<initialLike)	return true;				return false;				}			}		startingc*=multiplier;		}	MoveBrentValsAlongLineFromPowellVals(maxc+d);	assert(UpdateParams());//if this trips then GetMaxLegalCoeff(d,dir); isn't working	double newlike = tree->LScoreDirtyParts();	if(fabs(newlike-initialLike)>FTOL)		{if(newlike<initialLike)	return true;		return false;		}	throw LikePlateau();	return false;}*/template <class T>bool vecContainSameElements(vector<T> *fir,vector<T> *sec)//not necessarily the same number of times, (if elements are repeated){	int fs=fir->size();	int ss=sec->size();	for(int i=0;i<fs;i++)		{bool found=false;		for(int j=0;!found && j<ss;j++)			if((*fir)[i]==(*sec)[j])				found=true;		if(!found)	return false;		}	for(int j=0;j<ss;j++)		{bool found=false;		for(int i=0;!found && i<fs;i++)			if((*fir)[i]==(*sec)[j])				found=true;		if(!found)	return false;		}			return true;}double GetReasonableStepSize(double maxDist,double stepSize,double pt){	assert(fabs(stepSize)>0.0);	int counter=0;	if((maxDist<0  && stepSize<0) || (maxDist>0  && stepSize>0))		{if(maxDist==0.0 || (!PointsAreFarEnoughApart(pt,pt+maxDist)))			throw CloseToMaxDistException();		while(!PointsAreFarEnoughApart(pt,pt+stepSize))			{counter++;			assert(counter<MAXSTEPSIZEBUMPS);			if(fabs(stepSize*2.0)<fabs(maxDist))				stepSize*=STEPSIZEMULTIPLIER;			else				{stepSize=maxDist;				counter=MAXSTEPSIZEBUMPS-1;				}			}		}	else		{while(!PointsAreFarEnoughApart(pt,pt+stepSize))			{stepSize*=STEPSIZEMULTIPLIER;			counter++;			assert(counter<MAXSTEPSIZEBUMPS);			}		}	return stepSize;}