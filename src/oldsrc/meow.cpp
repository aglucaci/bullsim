#include "bull.h"using namespace std; //introduces namespace std/** * @class      BULLCMDLINE * @file       BULLCMDLINE.h * @file       BULLCMDLINE.cpp * @author     Paul O. Lewis * @copyright  Copyright © 1999. All Rights Reserved. * @variable   command_maxlen [static int] maximum length of a command entered interactively by user * @variable   inf_open [bool] true iff inf is currently open * @variable   message [nxsstring] workspace for composing output strings * @variable   next_command [char*] workspace for processing next command entered interactively by user * @variable   logf [ofstream] the log file stream * @variable   logf_open [bool] true iff logf is currently open * @variable   quit_now [bool] set to false at beginning of Run and turns true only when QUIT command processed * @see        Nexus * @see        NexusBlock * @see        NexusReader * @see        NexusToken * @see        XNexus * * <pre> * +---- Remove these comments for an actual implementation --------------------------+ * |                                                                                  | * | BULLCMDLINE provides a template for creating a program that reads NEXUS data    | * | files and provides a basic command line.  After compiling BULLCMDLINE, you will | * | already have a program that understands the following commands, either typed in  | * | at the console or provided in a BULLCMDLINE block in a NEXUS data file          | * | (exception is the execute command, which can only be entered at the console).    | * | Keywords in the descriptions below are given in uppercase, however the           | * | commands themselves are case-insensitive.  Lower-case indicates a parameter      | * | supplied by the user (e.g., "filename" would be replaced by the actual           | * | name of the file). Square brackets indicate optional keywords or subcommands.    | * |                                                                                  | * | EXECUTE filename;                                                                | * |                                                                                  | * | LOG [options];                                                                   | * |                                                                                  | * |   Option         Action                                                          | * |   ------------------------------------------------------                         | * |   FILE=filename  specifies name of log file to start                             | * |   START          indicates logging is to be started                              | * |   STOP           indicates logging is to be stopped                              | * |   APPEND         append to log file if it already exists                         | * |   REPLACE        replace log file without asking                                 | * |                                                                                  | * | QUIT;                                                                            | * |                                                                                  | * | See the Read function for details and to add other commands.                     | * |                                                                                  | * | To change the name of the program (which is also the prompt name and the         | * | name of the program's private NEXUS block), replace all occurrences of           | * | BULLCMDLINE with the name of your program (also search for the string           | * | "BULLCMDLINE" and replace with an appropriate string at each occurrence).       | * |                                                                                  | * +----------------------------------------------------------------------------------+  * </pre> * * This class handles reading and storage for the Nexus block BULLCMDLINE. * It also serves as the main class for the program BULLCMDLINE, acting  * as a Nexus object (in order to be capable of parsing data files) * as well as a NexusBlock object (in order to be able to process * commands in a BULLCMDLINE block).  * * Acting as a NexusBlock. it overrides the member functions  * Read and Reset, which are abstract virtual functions in  * the base class NexusBlock. * * Acting as a Nexus object, it overrides the member functions * EnteringBlock, SkippingBlock, and NexusError. *//** * @constructor * * Initializes the id data member to "Bull" and calls the FactoryDefaults * member function to perform the remaining initializations. */Bull::Bull(){	id = "BULL";	LSettings=NULL;	FactoryDefaults();	}/** * @destructor * * Closes logf if it is open. */Bull::~Bull(){	delete LSettings;	delete paramAlterInfo;	if( logf_open )		logf.close();}/** * @method CharLabelToNumber [int:protected] * @param s [nxsstring] the character label to be translated to character number * * The code here is identical to the base class version (simply returns 0), * so the code here should either be modified or this derived version * eliminated altogether.  Under what circumstances would you need to * modify the default code, you ask?  This function should be modified * to something meaningful if this derived class needs to construct and * run a SetReader object to read a set involving characters.  The SetReader * object may need to use this function to look up a character label * encountered in the set.  A class that overrides this method should * return the character index in the range [1..nchar]; i.e., add one to the * 0-offset index. */int Bull::CharLabelToNumber( nxsstring /*s*/ ){   return 0;}/** * @method EnteringBlock [virtual void:public] * @param blockName [nxsstring] the name of the block just entered * * Called by the Nexus object when a block named blockName is entered. * Allows program to notify user of progress in parsing the NEXUS file. * Virtual function that overrides the pure virtual function in the * base class Nexus. */void Bull::EnteringBlock( nxsstring blockName ){	message = "Reading ";	message += blockName;	message += " block...";	PrintMessage();}/** * @method FactoryDefaults [void:protected] * * Sets all data members to their factory default settings: * <table> * <tr><th align="left">Variable <th> <th align="left"> Initial Value * <tr><td> inf_open          <td>= <td> false * <tr><td> logf_open         <td>= <td> false * <tr><td> quit_now          <td>= <td> false * <tr><td> message           <td>= <td> "" * <tr><td> next_command[0]   <td>= <td> '\0' * <tr><td> trees             <td>= <td> NULL * <tr><td> taxa              <td>= <td> NULL * <tr><td> assumptions       <td>= <td> NULL * <tr><td> characters        <td>= <td> NULL * </table> */void Bull::FactoryDefaults(){	inf_open = false;	logf_open = false;	quit_now = false;	purged=true;	message = "";	next_command[0] = '\0';		trees = NULL;	taxa = NULL;	assumptions = NULL;	characters = NULL;	data=NULL;	charordata=NULL;	ntrees = ntaxa = nchars = 0;	curmodel=0L;	partitions=NULL;	npartitions=0;	paramAlterInfo=NULL;}/** * @method FileExists [bool:protected] * @param fn [const char*] the name of the file to check * * Returns true if file named fn already exists,  * false otherwise. */bool Bull::FileExists( const char* fn ){	ifstream testst;	testst.open(fn);	if(testst.good())		{testst.close();		return true;		}	testst.close();	return false;}/** * @method HandleEndblock [nxsstring:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called whenever a file name needs to be read from either * the command line or a file.  Expects next token to be "=" * followed by the token representing the file name.  Call * this function after, say, the keyword "file" has been  * read in the following LOG command: * <pre> * log file=doofus.txt start replace; * </pre> * Note that this function will read only "=doofus.txt " * leaving "start replace;" in the stream for reading * at a later time. */nxsstring Bull::GetFileName( NexusToken& token ){	// Eat the equals sign	//	token.GetNextToken();		if( !token.Equals("=") ) {		errormsg = "Expecting an equals sign, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}		// Now get the filename itself	//	token.GetNextToken();		return token.GetToken();}/** * @method HandleEndblock [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called when the END or ENDBLOCK command needs to be parsed * from within the Bull block.  Basically just checks to make * sure the next token in  the data file is a semicolon. */void Bull::HandleEndblock( NexusToken& token ){	// get the semicolon following END or ENDBLOCK token   //	token.GetNextToken();		if( !token.Equals(";") ) {		errormsg = "Expecting ';' to terminate the END or ENDBLOCK command, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}}/** * @method HandleExecute [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Handles everything after the EXecute keyword and the terminating * semicolon.  Flushes all blocks before executing file specified, * and no warning is given of this */void Bull::HandleExecute( NexusToken& token ){	// Issuing the EXECUTE command from within a file is a no-no   //	if( inf_open ) {		errormsg = "Cannot issue execute command from within a Bull block";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}		// Get the file name to execute   //	token.GetNextToken();		nxsstring fn = token.GetToken();	// get the semicolon terminating the EXECUTE command   //	token.GetNextToken();		if( !token.Equals(";") ) {		errormsg = "Expecting ';' to terminate the EXECUTE command, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}	// Before going through with this, make sure we're not going to overwrite 	// any stored blocks	bool stuff_stored = !taxa->IsEmpty();	stuff_stored = ( stuff_stored || !trees->IsEmpty() );	stuff_stored = ( stuff_stored || !assumptions->IsEmpty() );	stuff_stored = ( stuff_stored || charordata );	if( stuff_stored && UserSaysOk( "Ok to delete?", "Data has already been read and stored" ) )		PurgeBlocks();	else if( stuff_stored ) {		message = "\nExecute command aborted.";		PrintMessage();		return;	}	cerr << endl;	cerr << "Opening " << token.GetToken() << "..." << endl;		ifstream inf( fn.c_str(), ios::binary );	inf_open = true;	NexusToken ftoken(inf);	try {		Execute( ftoken );	}	catch( XNexus x ) 	{		NexusError( errormsg, x.pos, x.line, x.col );      Reset();	}		if( inf_open )		inf.close();	inf_open = false;		if( !taxa->IsEmpty() ) {		cerr << "  TAXA block found" << endl;		if( logf_open )			taxa->Report(logf);		FinishTaxaBlock();		if(!trees->IsEmpty())			FinishTreesBlock();		if(!data->IsEmpty())			{if(!characters->IsEmpty()) throw XNexus("Can't have both a characters and data block", token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			charordata=data;			FinishCharactersBlock();			}		if(!characters->IsEmpty())			{if(!data->IsEmpty()) throw XNexus("Can't have both a characters and data block", token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			charordata=characters;			FinishCharactersBlock();			}	}	if( !trees->IsEmpty() ) {		cerr << "  TREES block found" << endl;		if( logf_open )			trees->Report(logf);	}	if( !assumptions->IsEmpty() ) {		cerr << "  ASSUMPTIONS block found" << endl;		if( logf_open )			assumptions->Report(logf);	}	if( !characters->IsEmpty() ) {		cerr << "  CHARACTERS block found" << endl;		if( logf_open )			characters->Report(logf);		charordata=characters;	}		if( !data->IsEmpty() ) {		if(!characters->IsEmpty() ) throw XNexus("Cannot define both a characters and a data block" );		cerr << "  DATA block found" << endl;		if( logf_open )			data->Report(logf);		charordata=data;	}}void Bull::FinishCharactersBlock()//called in handle execute and always called after FinishTaxaBlock(){	nchars=charordata->GetNChar();	CreateDataMap();	assert(!LSettings);	LSettings=new LikeSettings(0,nchars);	for(int i=0;i<ntaxa;i++)		LSettings->AddTaxon(taxa->GetTaxonLabel(i));/*	if(!trees->IsEmpty())		for(vector<Tree *>::iterator treit=treelist.begin();treit!=treelist.end();treit++)			(*treit)->AssignDataToTerm(taxa, rawData);				*/			}void Bull::FinishTaxaBlock(){	ntaxa=taxa->GetNumTaxonLabels();}void Bull::FinishTreesBlock(){	ntrees=trees->GetNumTrees();	for(int i=0;i<ntrees;i++){		Tree *temptree=new Tree(trees->GetTranslatedTreeDescription(i));		nxsstring s=trees->GetTreeName(i);		ToUpper(s);		temptree->SetName(s);		if(charordata)//either characters or data are read in			temptree->AssignDataToTerm(taxa, rawData);		treelist.push_back(temptree);		}}/** * @method HandleLog [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called when the LOG command needs to be parsed * from within the Bull block. */void Bull::HandleLog( NexusToken& token ){	bool starting = false;	bool stopping = false;	bool appending = false;	bool replacing = false;	bool name_provided = false;	nxsstring logfname;		// Retrieve all tokens for this command, stopping only in the event	// of a semicolon or an unrecognized keyword	//	for(;;)	{		token.GetNextToken();		if( token.Equals(";") ) {			break;		}		else if( token.Abbreviation("STOp") ) {			stopping = true;		}		else if( token.Abbreviation("STArt") ) {			starting = true;		}		else if( token.Abbreviation("Replace") ) {			replacing = true;		}		else if( token.Abbreviation("Append") ) {			appending = true;		}		else if( token.Abbreviation("File") ) {			logfname = GetFileName(token);			name_provided = true;		}		else {			errormsg = "Unexpected keyword (";	      errormsg += token.GetToken();	      errormsg += ") encountered reading LOG command";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}   }      // Check for incompatible combinations of keywords   //   if( stopping && ( starting || appending || replacing || name_provided ) ) {		errormsg = "Cannot specify STOP with any of the following START, APPEND, REPLACE, FILE";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }      if( appending && replacing ) {		errormsg = "Cannot specify APPEND and REPLACE at the same time";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }   if( logf_open && ( starting || name_provided || appending || replacing ) ) {		errormsg = "Cannot start log file since log file is already open";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }   // Is user closing an open log file?   //   if( stopping ) {		logf.close();		logf_open = false;				message = "\nLog file closed";		PrintMessage();				return;   }   	// If this far, must be attempting to open a log file	//	if( !name_provided ) {		errormsg = "Must provide a file name when opening a log file\n";		errormsg += "e.g., log file=doofus.txt start replace;";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}   		if( appending ) {		logf_open = true;		logf.open( logfname.c_str(), ios::out | ios::app );		message = "\nAppending to log file ";		message += logfname;		PrintMessage();	}	else if( replacing ) {		logf_open = true;		logf.open( logfname.c_str() );		message = "\nReplacing log file ";		message += logfname;		PrintMessage();	}	else  {		bool exists = FileExists( logfname.c_str() );		bool userok = true;		if( exists && !UserSaysOk( "Ok to replace?", "Log file specified already exists" ) )			userok = false;		if( userok ) {			logf_open = true;			logf.open( logfname.c_str() );		}		if( exists && userok ) {			message = "\nReplacing log file ";			message += logfname;		}		else if( userok ) {			message = "\nLog file ";			message += logfname;			message += " opened";		}		else {			message = "\nLog command aborted";		}		PrintMessage();	}}void Bull::HandleLscore(NexusToken& token ){	if(!LSettings)			{cout<< "You can't score under likelihood without an active data file"<<endl;		while(token.GetToken()!=";")	token.GetNextToken();		return;		}	token.GetNextToken();	assert(LSettings);	bool dontModifyBLens=false;	Tree *temptre;	vector<Tree *> toscoreT;	vector<nxsstring> toscoreN;	do	{		if(token.Abbreviation("CURREntbranchlengths") || token.Abbreviation("CURRBranchlengths"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")				{token.GetNextToken();				if(token.Abbreviation("No"))					LSettings->SetUseCurrentBrLen(false);				else 	if(token.Abbreviation("Yes"))							LSettings->SetUseCurrentBrLen(true);						else	{while(token.GetToken()!=";")	token.GetNextToken();								throw XNexus("Expecting YES or NO after CurrentBranchLengths = option to LSCORE command");								}				token.GetNextToken();				}			else	LSettings->SetUseCurrentBrLen(true);			}		if(token.IsInteger())			{long tn=token.GetLongEquivalent();			if(tn>ntrees || tn<1)				{while(token.GetToken()!=";")	token.GetNextToken();				}throw NoSuchTree();			temptre=treelist[tn-1];			}		else			temptre=FindTreeFromName(token.GetToken());		toscoreN.push_back(token.GetToken());//keeps track of what the user called the tree		toscoreT.push_back(temptre);		token.GetNextToken();		}	while(token.GetToken()!=";");	for(int i=0;i<toscoreT.size();i++)		{double x;		if(LSettings->AllStationaryModels())			x=LScore(toscoreT[i]);		else throw IncompleteModel("Non stationary models aren't implemented yet");					cout<< "Ln Likelihood score of "<<toscoreN[i]<<" is "<<x<<endl;		logf<< "Ln Likelihood score of "<<toscoreN[i]<<" is "<<x<<endl;		}}void Bull::HandleLset(NexusToken& token ){	if(!LSettings)			{cout<< "You can't specify likelihood settings without an active data file"<<endl;		while(token.GetToken()!=";")	token.GetNextToken();		return;		}	token.GetNextToken();	do	{		if(token.Abbreviation("CURREntbranchlengths") || token.Abbreviation("CURRBranchlengths"))//long abbreviations to avoid conflict with simple names			{token.GetNextToken();			if(token.GetToken()=="=")				{token.GetNextToken();				if(token.Abbreviation("No"))					LSettings->SetUseCurrentBrLen(false);				else 	if(token.Abbreviation("Yes"))							LSettings->SetUseCurrentBrLen(true);						else	{while(token.GetToken()!=";")	token.GetNextToken();								throw XNexus("Expecting YES or NO after CurrentBranchLengths = option to LSCORE command");								}				token.GetNextToken();				}			else	LSettings->SetUseCurrentBrLen(true);			}		token.GetNextToken();		}	while(token.GetToken()!=";");}/** * @method PreprocessNextCommand [void:public] * * Accepts a string in the form of a Bull block containing one command * and processes it just like a real Bull block in a NEXUS data file. */void Bull::HandleNextCommand(){	istrstream cmdin( next_command );	NexusToken token(cmdin);	try {		Read( token );	}	catch( XNexus x ) 	{		NexusError( errormsg, x.pos, x.line, x.col );      Reset();	}}/** * @method NexusError [virtual void:public] * @param msg [nxsstring&] the error message * @param pos [streampos] the point in the NEXUS file where the error occurred * @param line [long] the line in the NEXUS file where the error occurred * @param col [long] the column in the NEXUS file where the error occurred * * Called when an error is encountered in a NEXUS file. Allows program to * give user details of the error as well as the precise location of the * error. Virtual function that overrides the pure virtual function in the * base class Nexus. */void Bull::NexusError( nxsstring& msg, streampos /* pos */, long line, long col ){	message = "\n";	message += msg;	PrintMessage();		if( inf_open )	{		message = "Line:   ";		message += line;		PrintMessage();			message = "Column: ";		message += col;		PrintMessage();	}}/** * @method PreprocessNextCommand [void:public] * * Begins with the command just entered by the user, which is stored in * the data member next_command, adds a semicolon (if the user failed * to supply one), and then adds "end;" so the whole bundle looks * like a very short Bull block.  This is then passed to HandleNextCommand, * which processes it just like a real Bull block in a NEXUS data file. */void Bull::PreprocessNextCommand(){	// If user failed to add the terminating semicolon,	// we'll do it now. We will also remove the line feed	// at the end and add the command "end;" to the end	// of the line (see explanation below).	//	int len = strlen(next_command);	assert( len > 0 );	// Remove any whitespace characters from end of string entered by user	//	int i = len;	while( i > 0 && next_command[i-1] == ' ' || next_command[i-1] == '\t' || next_command[i-1] == '\n' )		i--;	// If character at position i-1 is a semicolon, put '\0' terminator at position i;	// otherwise, put a semicolon at position i and terminator at i+1	//	if( next_command[i-1] != ';' ) {		next_command[i] = ';';		i++;	}	assert( i <= COMMAND_MAXLEN );	next_command[i] = '\0';		// Now add a semicolon at the beginning and terminate with an "END;" command 	// so that we can pretend this is simply a very short private NEXUS block	// containing only one command.  This allows us to simply use the Read 	// function we inherited from the base class BstBase to process the command.	//	len = strlen(next_command);	assert( len < COMMAND_MAXLEN-2 );	nxsstring tmp = ";";	tmp += next_command;	tmp += "end;";	strcpy( next_command, tmp.c_str() );}/** * @method PrintMessage [void:public] * @param linefeed [bool] if true, places newline character after message * * All output handled here.  Writes string currently stored in message  * (a nxsstring data member) to the output file stream, if open, and also  * to the console via cerr. Places newline after string if linefeed is true. */void Bull::PrintMessage( bool linefeed /* = true */ ){	cerr << message;	if( linefeed )		cerr << endl;	if( logf_open ) {		logf << message;		if( linefeed )			logf << endl;	}}/** * @method PurgeBlocks [void:protected] * * Detaches all blocks, deletes them, creates new blocks, and  * finally adds the new blocks. */void Bull::PurgeBlocks(){	Detach( taxa );	Detach( trees );	Detach( assumptions );	Detach( characters );	Detach( data );		delete characters;	delete assumptions;	delete trees;	delete taxa;	delete data;	delete LSettings;	charordata=NULL;	LSettings=NULL;		for(vector<Tree *>::iterator treit=treelist.begin();treit!=treelist.end();treit++)		(*treit)->DestroyTreeNotData();	//for_each(treelist.begin(),treelist.end(),mem_fun(&Tree::DestroyTreeNotData));	treelist.erase(treelist.begin(),treelist.end());	for(map<nxsstring, EncodedChars *>::iterator dmit=rawData.begin();dmit!=rawData.end();dmit++)		delete (dmit->second);	rawData.erase(rawData.begin(),rawData.end());		taxa = new TaxaBlock();	trees = new TreesBlock(*taxa);	assumptions = new AssumptionsBlock( *taxa );	characters = new CharactersBlock( *taxa, *assumptions );	data = new DataBlock(*taxa, *assumptions );		charordata=NULL;	Add( taxa );	Add( trees );	Add( assumptions );	Add( characters );	Add( data );	purged=true;}/** * @method Read [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * This function provides the ability to read everything following * the block name (which is read by the Nexus object) to the end or * endblock statement. Characters are read from the input stream * in. Overrides the pure virtual function in the base class. */void Bull::Read( NexusToken& token ){  	   isEmpty = false;   // this should be the semicolon after the block name   //	token.GetNextToken();	if( !token.Equals(";") ) {		errormsg = "Expecting ';' after ";      errormsg += id;      errormsg += " block name, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}		//Get Info from other blocks if not already done	if(purged && !taxa->IsEmpty())		{		FinishTaxaBlock();		if(!trees->IsEmpty())			FinishTreesBlock();		if(!data->IsEmpty())			{if(!characters->IsEmpty()) throw XNexus("Can't have both a characters and data block", token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			charordata=data;			FinishCharactersBlock();			}		if(!characters->IsEmpty())			{if(!data->IsEmpty()) throw XNexus("Can't have both a characters and data block", token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );			charordata=characters;			FinishCharactersBlock();			}		}		for(;;)	{		token.GetNextToken();		if( token.Abbreviation("ENdblock") ) {			HandleEndblock( token );			break;		}		else if( token.Abbreviation("LOg") ) {			HandleLog( token );		}		else if( token.Abbreviation("EXecute") ) {			HandleExecute( token );			}		else if( token.Abbreviation("Quit") ) {			quit_now = true;						message = "\nBull says goodbye\n";			PrintMessage();						break;		}		else if( token.Abbreviation("LSCore") ) {			HandleLscore( token );		}		else if( token.Abbreviation("LSEt") ) {			HandleLset( token );		}		else      {			SkippingCommand( token.GetToken() );         do {            token.GetNextToken();         } while( !token.AtEOF() && !token.Equals(";") );         if( token.AtEOF() ) {				errormsg = "Unexpected end of file encountered";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );         }		}   }}/** * @method Reset [void:protected] * * Overrides the pure virtual function in the base class. */void Bull::Reset(){   isEmpty = true;	inf_open = false;	quit_now = false;	message = "";	next_command[0] = '\0';}/** * @method Report [virtual void:public] * @param out [ostream&] the output stream to which to write the report * * This function outputs a brief report of the contents of this Bull block. * Overrides the pure virtual function in the base class. */void Bull::Report( ostream& /* out */ ){	message = "";	PrintMessage();	message = id;	message += " block contains...";	PrintMessage();}/** * @method Run [void:public] * * Runs the command line interpreter, allowing Bull to interact with user. * Typically, this is the only function called in main after a Bull object * is created. */void Bull::Run(){	taxa = new TaxaBlock();	trees = new TreesBlock(*taxa);	assumptions = new AssumptionsBlock( *taxa );	characters = new CharactersBlock( *taxa, *assumptions );	data = new DataBlock( *taxa, *assumptions );		Add( taxa );	Add( trees );	Add( assumptions );	Add( characters );	Add( data );	Add( this );		HKY chky;	GTR cgtr;		quit_now = false;	while( !quit_now ) 	{		cerr << endl;		cerr << "Bull> ";		cin.getline( next_command, 256 );		PreprocessNextCommand();		HandleNextCommand();	}}/** * @method SkippingBlock [virtual void:public] * @param blockName [nxsstring] the unrecognized block name * * Called when program does not recognize a block name encountered in a  * NEXUS file.  Virtual function that overrides the pure virtual function  * in the base class Nexus. */void Bull::SkippingBlock( nxsstring blockName ){	message = "Skipping unknown block (";	message += blockName;	message += ")";	PrintMessage();}/** * @method SkippingCommand [virtual void:public] * @param commandName [nxsstring] the name of the command being skipped * * This function is called when an unknown command named commandName is * about to be skipped.  This version of the function (which is identical * to the base class version) does nothing (i.e., no warning is issued * that a command was unrecognized).  Modify this virtual function to * provide such warnings to the user (or eliminate it altogether since * the base class version already does what this does). */void Bull::SkippingCommand( nxsstring commandName ){	message = "Skipping unknown command (";	message += commandName;	message += ")";	PrintMessage();}/** * @method TaxonLabelToNumber [int:protected] * @param s [nxsstring] the taxon label to be translated to a taxon number * * The code here is identical to the base class version (simply returns 0), * so the code here should either be modified or this derived version * eliminated altogether.  Under what circumstances would you need to * modify the default code, you ask?  This function should be modified * to something meaningful if this derived class needs to construct and * run a SetReader object to read a set involving taxa.  The SetReader * object may need to use this function to look up a taxon label * encountered in the set.  A class that overrides this method should * return the taxon index in the range [1..ntax]; i.e., add one to the * 0-offset index. */int Bull::TaxonLabelToNumber( nxsstring /* s */ ){   return 0;}/** * @method TaxonLabelToNumber [virtual bool:public] * @param mb_message [nxsstring] the question posed to the user * @param mb_title [nxsstring] the title of the message box * * Asks user if "something" is ok, where "something" is expressed * in the title and message displayed.  This is a virtual function * so it can be overridden in a derived class to use a different * (perhaps graphical) means for displaying the message. * Note: mb_message should terminate with a quesiton mark; none * will be provided by this function. */bool Bull::UserSaysOk( nxsstring mb_message, nxsstring mb_title ){	cerr << endl;	cerr << mb_title << endl;	cerr << "  " << mb_message;	cerr << " (y/n) ";		cin.getline( next_command, COMMAND_MAXLEN );	bool yep  = ( next_command[0] == 'y' && next_command[1] == '\0' );	bool nope = ( next_command[0] == 'n' && next_command[1] == '\0' );		while( !yep && !nope )	{		cerr << endl;		cerr << "Must answer by typing either y or n and then pressing the Enter key" << endl;		cerr << endl;		cerr << mb_title << endl;		cerr << "  " << mb_message;		cerr << " (y/n) ";				cin.getline( next_command, COMMAND_MAXLEN );		yep  = ( next_command[0] == 'y' && next_command[1] == '\0' );		nope = ( next_command[0] == 'n' && next_command[1] == '\0' );	}		return yep;}void Bull::CreateDataMap(){		assert(charordata->GetDataType()==CharactersBlock::dna);	nxsstring curtax;	//assuming DNA e!	short int *curchar;	EncodedChars *curEC;	for(int i=0;i<ntaxa;i++){		curtax=taxa->GetTaxonLabel(i);		curchar=new short[nchars];		for(int j=0;j<nchars;j++){			short nstates=0, c;			c=0;			nstates=charordata->GetNumStates(i,j);			for(int k=0;k<nstates;k++) c=c|EncodeDNAChar(charordata->GetState(i,j,k));			*(curchar+j)=c;			}		curEC=new EncodedChars(nchars, curchar);		//rawData.insert(pair<const nxsstring, EncodedChars *>(curtax, curEC));		rawData[curtax]=curEC;			}}Tree* Bull::FindTreeFromName(nxsstring s){	ToUpper(s);	for(int i=0;i<treelist.size();i++)		if(s==treelist[i]->GetName())			return treelist[i];	throw NoSuchTree(s.c_str());}double Bull::LScore(Tree *t){	double prevlik=0.0,thislike;	GetTreeReadyToCalcLike(t);	thislike=t->LScoreAlreadyInitialized();		if(LSettings->maximize)		{int pass=0;		do	{prevlik=thislike;		//	thislike=LScoreOneMaxSmoothingPass(t);			pass++;			}		while((thislike-prevlik)<LSettings->delta && pass<LSettings->maxPasses);				}	return prevlik;}void Bull::GetTreeReadyToCalcLike(Tree *t){	if(NeedToPartition())			Partition();		RecursiveNodeList=t->GetRecursiveNodeList();	if(t->LikeAttributesAreDirty())		{if(t->GetLikeAttributes())			SetBrlensToNULLIfNotOwner(t);		Node **temp;		temp=RecursiveNodeList;		if(LSettings->userInputBrLen)			{while(temp)				{if((*temp)->IsTerm())					(*temp)->ReplaceSetOfLikeInfoButKeepBranchLen(CreateSetOfLikeAttrForANode((*temp)->GetName()));//Destroys old LikeAttr for the nodes (including brLens)				else					(*temp)->ReplaceSetOfLikeInfoButKeepBranchLen(CreateSetOfLikeAttrForANode());//Destroys old LikeAttr for the nodes (including brLens)				temp++;				}			}					else			{while(temp)				{if((*temp)->IsTerm())					(*temp)->ReplaceSetOfLikeInfo(CreateSetOfLikeAttrForANode((*temp)->GetName()));//Destroys old LikeAttr for the nodes(including brLens)				else					(*temp)->ReplaceSetOfLikeInfo(CreateSetOfLikeAttrForANode());//Destroys old LikeAttr for the nodes (including brLens)				temp++;				}			}		t->SetLikeAttributes(CreateSetOfLikeAttrForATree());//Destroys old LikeAttr for the tree (including brLen Modifiers)		}		CreateParameterAlterationInfo();	if(LSettings->useRSBranchLengths)	throw MTHException("Rogers Swofford starting branch lengths are not supported yet");	InstantiateBranchLengths(t);	InstantiateBranchLengthModifiers(t);	InitializeParameters();	t->GetLikeAttributes()->InitializeModelMixingParams();}bool Bull::NeedToPartition(){	if(!partitions)	return true;	if(partitions[0]->dirty)	return true;	return false;}void Bull::Partition(){	for(int i=0;i<npartitions;i++)		delete partitions[i];	delete [] partitions;	npartitions=LSettings->GetNDataPartitions();	partitions=new DataPartition *[npartitions];	for(int i=0;i<npartitions;i++)		partitions[i]=new DataPartition(LSettings, rawData,i);}SetOfLikeAttr *Bull::CreateSetOfLikeAttrForANode(void){	assert(!NeedToPartition());//returns Set for internal node	SetOfLikeAttr *temp;	temp=new SetOfLikeAttr(npartitions);	for(int i=0;i<npartitions;i++)		{int nmods=partitions[i]->GetNModels();		temp->SetNumModsInPart(i,nmods);		for(int j=0;j<nmods;j++)			temp->AddLikeAtt(i,j,(new InternalNodeLikeAttr(partitions[i]->GetNChar(j),partitions[i]->GetModel(j))));		}	return temp;}SetOfLikeAttr *Bull::CreateSetOfLikeAttrForANode(nxsstring termName){	assert(!NeedToPartition());//returns Set for terminal node	SetOfLikeAttr *temp;	temp=new SetOfLikeAttr(npartitions);	for(int i=0;i<npartitions;i++)		{int nmods=partitions[i]->GetNModels();		temp->SetNumModsInPart(i,nmods);		for(int j=0;j<nmods;j++)			temp->AddLikeAtt(i,j,(new TerminalNodeLikeAttr(partitions[i]->GetCharsInShorts(j,termName),partitions[i]->GetModel(j))));		}	return temp;}TreeSetOfLikeAttr *Bull::CreateSetOfLikeAttrForATree(void){	assert(!NeedToPartition());//returns Set for terminal node	TreeSetOfLikeAttr *temp;	temp=new TreeSetOfLikeAttr(npartitions);	for(int i=0;i<npartitions;i++)		{int nmods=partitions[i]->GetNModels();		temp->SetNumModsInPart(i,nmods);		if(nmods>1)			temp->SetModelMixingParam(i,partitions[i]->GetModelMixingParam());		for(int j=0;j<nmods;j++)			temp->AddLikeAtt(i,j,(new TreeLikeAttr(partitions[i]->GetNChar(j)				,partitions[i]->GetModel(j)				,partitions[i]->GetIsConstant(j)				,partitions[i]->GetNReps(j))));		temp->FinishedAddingModels(i,partitions[i]->GetPackingIndex(i));		}	return temp;}			void Bull::CreateParameterAlterationInfo(){	delete paramAlterInfo;	paramAlterInfo=new ParameterAlterationInfo(LSettings);}void Bull::InstantiateBranchLengths(Tree *t){	if(LSettings->userInputBrLen)	return;//assumes that the BrLens are already instantiated and in place;  This should be the only case in which the brlens are already instantiated	RecursiveNodeList=t->GetRecursiveNodeList();//probably unnecessary (already done)	int nsetsofblens=LSettings->GetNSetsOfBranchLengths();	Node **temp;	TreeSetOfLikeAttr *treesSetofLA=t->GetLikeAttributes();		int branchLenParameterSetting;	if(LSettings->useRSBranchLengths)		branchLenParameterSetting=par(APPRO)|par(MIN);	else		branchLenParameterSetting=par(DEF)|par(MIN);	PartModIndex owner;	for(int n=0;n<nsetsofblens;n++)//Allocate brlens for all part/models that "own them"		{		owner=LSettings->GetOwnerOfNthSetOfBrLengths(n);		treesSetofLA->SetOwnerOfBrLengths(owner,true);		temp=RecursiveNodeList;		while(temp)			{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);			assert(!((*temp)->likeInfo->GetBLenParameterPtr()));			Parameter *tempP;			tempP=new Parameter(DEFAULTSTARTINGBRLEN,0,0,branchLenParameterSetting,DEFAULTSTARTINGBRLEN,"");			(*temp)->likeInfo->SetBLenPtr(tempP);			temp++;			}		}	for(int p=0;p<LSettings->GetNDataPartitions();p++)		for(int m=0;m<LSettings->GetNModelsInPart(p);m++)			{owner.Set(p,m);			if(!(treesSetofLA->GetOwnerOfBrLengths(owner)))				{temp=RecursiveNodeList;				while(temp)					{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);					assert(!((*temp)->likeInfo->GetBLenParameterPtr()));					LikeAttr *tempLa; PartModIndex realOwner;					realOwner=LSettings->GetOwnerOfBrLens(p,m);					tempLa=(*temp)->GetLikeAtt(realOwner.partNum,realOwner.modNum);					(*temp)->likeInfo->SetBLenPtr(tempLa->GetBLenParameterPtr());					temp++;					}				}			}		}void Bull::InstantiateBranchLengthModifiers(Tree *t){	RecursiveNodeList=t->GetRecursiveNodeList();//probably unnecessary (already done)	int nsetsofblenmods=LSettings->GetNSetsOfBranchLengthModifiers();	Node **temp;	TreeSetOfLikeAttr *treesSetofLA=t->GetLikeAttributes();		int branchLenModParameterSetting=par(DEF)|par(MIN);//default value for rate modifiers is 1.0 right now	//Right now the branch length modifier is added to every Node in the tree (no starting relaxed clock values)		PartModIndex owner;	for(int n=0;n<nsetsofblenmods;n++)//Allocate brlens for all part/models that "own them"		{		owner=LSettings->GetOwnerOfNthSetOfBrLengthModifiers(n);		Parameter *tempP;		tempP=new Parameter(1.0,0,0,branchLenModParameterSetting,1.0,"");		treesSetofLA->AddBrLenMod(owner,tempP,true);		temp=RecursiveNodeList;		while(temp)			{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);			(*temp)->likeInfo->SetBLenModPtr(tempP);			temp++;			}		}	for(int p=0;p<LSettings->GetNDataPartitions();p++)		for(int m=0;m<LSettings->GetNModelsInPart(p);m++)			{owner.Set(p,m);			if(owner!=LSettings->GetOwnerOfBrLenModifiers(p,m)) //if this part/mod doesn't own its own blenMods				{				Parameter *tempP;				tempP=treesSetofLA->GetBrLenMod(LSettings->GetOwnerOfBrLenModifiers(p,m),0);//0 indicates the first brLenMod change it allowing different starting point for relaxed clock type stuff				treesSetofLA->AddBrLenMod(owner,tempP,false);				temp=RecursiveNodeList;				while(temp)					{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);					(*temp)->likeInfo->SetBLenModPtr(tempP);					temp++;					}				}			}}void Bull::SetBrlensToNULLIfNotOwner(Tree *t){	assert(!(LSettings->userInputBrLen));	RecursiveNodeList=t->GetRecursiveNodeList();//probably unnecessary (already done)	Node **temp;	TreeSetOfLikeAttr *treesSetofLA=t->GetLikeAttributes();	PartModIndex owner;	for(int p=0;p<LSettings->GetNDataPartitions();p++)		for(int m=0;m<LSettings->GetNModelsInPart(p);m++)			{owner.Set(p,m);			if(!(treesSetofLA->GetOwnerOfBrLengths(owner)))				{temp=RecursiveNodeList;				while(temp)					{(*temp)->SetLikeAtt(owner.partNum,owner.modNum);					(*temp)->likeInfo->SetBLenPtr(NULL);					temp++;					}				}			}		}void Bull::InitializeParameters(){	map<Model *,int > modmap;	for(int p=0;p<LSettings->GetNDataPartitions();p++)		for(int m=0;m<LSettings->GetNModelsInPart(p);m++)			{Model *temp;			temp=LSettings->GetModel(p,m);			if(modmap.end()==modmap.find(temp))				{modmap[temp]=1;				temp->InitializeParameters();				}			}}