#include "AdvancedBullDefs.h"#include "tree.h"#include <algorithm.h>#include <profiler.h>#define NUMBERNODESusing namespace std;int Tree::timesscored(0);Tree::Tree(){	root=0;	ntax=nchar=0;	memoryAllocation=0;	attributesDirty=true;	recursiveNodeList=NULL;	recursInternalNodeList=NULL;	lastScoredLikeAtt=NULL;	setOfLikeAtt=NULL;	lastScoredParsAtt=NULL;	setOfParsAtt=NULL;	branchLengthsFromFile=false;	tempOneBrentScored=0;	}	Tree::Tree(Node *rt){	assert(rt);	root=rt->GetRoot();	ntax=root->GetNtax();	root->WriteTermTax(&termTax);	nchar=(*(termTax.begin()))->GetNchar();	attributesDirty=true;	recursiveNodeList=NULL;	recursInternalNodeList=NULL;	lastScoredLikeAtt=NULL;	setOfLikeAtt=NULL;	lastScoredParsAtt=NULL;	setOfParsAtt=NULL;	branchLengthsFromFile=false;	tempOneBrentScored=0;	}	Tree::Tree(nxsstring tstring,bool readBrLens/*=true*/){	double y;	ntax=0;	nchar=0;	nxsstring::iterator c=tstring.begin();	assert(*c=='(');	root=new Node;	Node *tempnode=root;	branchLengthsFromFile=false;	while(c!=tstring.end()){		nxsstring tk;		tk=GetTreeToken(tstring,c);		/*  Paul's NCl trims the semicolon off the end		if(c==tstring.end())			{if(tk!=";")	throw TreeEncodingException("Expecting semicolon");			}		else 		*/		if(tk=="(") tempnode=tempnode->MakeDes();		else if(tk==")") tempnode=tempnode->GetAnc();		else if(tk== ",")			{			tempnode=tempnode->GetAnc();			tempnode=tempnode->MakeDes();			}		else if(tk==":"){			tk=GetTreeToken(tstring,c);			if(readBrLens)				{y=atof(tk.c_str());				branchLengthsFromFile=true;				tempnode->SetBranchLengthFromFile(y);				}			}		else{			UnderscoresToBlanks(tk);			tempnode->SetName(tk);			termTax.push_back(tempnode);			ntax++;			}		}	if(branchLengthsFromFile)		{if(!root->NoIllegalBranchLengths())			{cout<<"Setting all undefined or negative branches to 0.0"<<endl;			root->SetAllIllegalBranches(0.0);			}		root->CreateSetOfLikeAttrWithInputBrLensRecurs();		}		setOfLikeAtt=NULL;	attributesDirty=true;	recursiveNodeList=NULL;	recursInternalNodeList=NULL;	lastScoredLikeAtt=NULL;	lastScoredParsAtt=NULL;	setOfParsAtt=NULL;	tempOneBrentScored=0;#ifdef NUMBERNODES	//TEMPORARY	NameInternalNodes();#endif		}Tree::~Tree(){	termTax.erase(termTax.begin(),termTax.end());	delete root;	delete [] recursiveNodeList;	delete [] recursInternalNodeList;	delete setOfLikeAtt;	delete setOfParsAtt;	}		void Tree::AssignDataToTerm(TaxaBlock *taxa,map<nxsstring, EncodedChars *> dm){	for(int i=0;i<ntax;i++){		nxsstring tempname;		tempname=(termTax[i])->GetName();		taxa->FindTaxon(tempname);//verify that name is in the taxon block  throws nosuchtaxon		(termTax[i])->SetChars(dm[tempname]);		}		}void Tree::DestroyTreeNotData(void){	for_each(termTax.begin(),termTax.end(),mem_fun(&Node::DetachData));	delete this;}void Tree::SetName(nxsstring n){ 	name=n;}nxsstring Tree::GetName(){	return name;}Node **Tree::GetRecursiveNodeList(){	assert(root && ntax>1);	if(!recursiveNodeList)		{recursiveNodeList=new Node *[2*ntax+1];		for(int i=0;i<2*ntax;i++)			recursiveNodeList[i]=NULL;		root->FillRecursiveNodeList(recursiveNodeList);		}	if(!recursInternalNodeList)		{recursInternalNodeList=new Node *[ntax+1];		for(int i=0;i<ntax;i++)			recursInternalNodeList[i]=NULL;		root->FillRecursiveInternalNodeList(recursInternalNodeList);		}	return recursiveNodeList;}void Tree::NotifyModelOfChangedParameter(PartModIndex pmi,FreqParamGroup *f){	try	{setOfLikeAtt->likeAttribs[pmi.partNum][pmi.modNum]->NotifyModelOfChangedParameter(f);		}	catch (NeedToRecodeException x)		{RecodeTerminalsAndLikeAttr(pmi.partNum,pmi.modNum);		}}void Tree::NotifyModelsThatFreqParamChangesAreDone(PartModIndex pmi,FreqParamGroup *f){	try	{setOfLikeAtt->likeAttribs[pmi.partNum][pmi.modNum]->NotifyModelsThatFreqParamChangesAreDone(f);		}	catch (NeedToRecodeException x)		{RecodeTerminalsAndLikeAttr(pmi.partNum,pmi.modNum);		}}void Tree::NotifyModelOfChangedParameter(PartModIndex pmi,Parameter *p){	try	{setOfLikeAtt->likeAttribs[pmi.partNum][pmi.modNum]->NotifyModelOfChangedParameter(p);		}	catch (NeedToRecodeException x)		{RecodeTerminalsAndLikeAttr(pmi.partNum,pmi.modNum);		}}	void Tree::RecodeTerminalsAndLikeAttr(int p,int m){	for(vector<Node *>::iterator ttIt= termTax.begin();ttIt!=termTax.end();ttIt++)		(*ttIt)->setOfLikeInfo->GetLikeAtt(p,m)->RecodeDueToModelSizeChange();	TreeLikeAttr *tempTLA;	tempTLA=setOfLikeAtt->GetLikeAtt(p,m);	tempTLA->nStates=tempTLA->model->GetNStates();}		bool	gNotInfinity;#include <time.h>double Tree::LScoreAlreadyInitialized(){// It is fair to assume that the like attributes are present, but they may not have any real info	likelihood = 0.0;	//int problempartitions[]={301,304,313};	time_t beft;	time(&beft);	//cout<<"About to Profile"<<endl;	//if(!ProfilerInit(collectDetailed,PPCTimeBase,30,10))		//{		for(int partn=0;partn<setOfLikeAtt->GetNParts();partn++)			likelihood+=LScoreAlreadyInitialized(partn,false);				//ProfilerDump("\pBullprof");		//ProfilerTerm();		//}	ofstream optimizationLog;	optimizationLog.open("OptimizationLog",ios::app);	cout<<"\nLikelihood of "<<likelihood<<"\nThat took "<<difftime(time(NULL),beft)<<" seconds.\n";	optimizationLog<<"Likelihood of "<<likelihood<<"\tThat took "<<difftime(time(NULL),beft)<<" seconds.\n";	optimizationLog.close();		if(likelihood >MAXDOUBLE /*|| likelihood<	0.0*/)		throw LikeUnderFlow();	return likelihood;}double aaron[]={12.28487,29.87760,21.78659,25.86699,29.52709,11.37185,25.20272};double Tree::LScoreAlreadyInitialized(int partnum,bool OnlyScoreDirty){	double x=0.0;	double y=0.0;	bool printstuff=false;#ifdef CODONHACK	//modified so it is only called when needed (don't need to test ONLYScoreDirty		cout<<partnum<<" ";		if(lastScoredLikeAtt!=setOfLikeAtt->likeAttribs[partnum][0])	//this stuff only needs to be done if the model/partition is different from the last time the likelihood was calculated			PrepareLikeAttrAndAllNodes(partnum,0);		else	PrepareLikeAttrForCalcuation(partnum,0,NULL);//in case model is the same but it has changed size		LikelihoodSweepOverAPartitionModel(recursInternalNodeList);		printstuff=true;		int rcount=0;		y=setOfLikeAtt->GetLikelihoodFromCondLike(root->setOfLikeInfo,partnum,OnlyScoreDirty);		while(!(y<log(MAXDOUBLE) && y>(-1.0*log(MAXDOUBLE))))			{if(rcount==10)				assert(0);				//throw MTHException("Too many Overflow corrections");			cout<<"For site "<<partnum<<" changing the multiplier from "<<LikeAttr::Multiplier;			if(y<(-1.0*log(MAXDOUBLE)))				lastScoredLikeAtt->model->SetMultiplier(1.2+lastScoredLikeAtt->GetMultiplier());			else				lastScoredLikeAtt->model->SetMultiplier(lastScoredLikeAtt->GetMultiplier()-1.2);			LikeAttr::Multiplier=lastScoredLikeAtt->GetMultiplier();			cout<<" to "<<LikeAttr::Multiplier<<"\n likelihood was "<<y<<endl;			LikelihoodSweepOverAPartitionModel(recursInternalNodeList);			y=setOfLikeAtt->GetLikelihoodFromCondLike(root->setOfLikeInfo,partnum,OnlyScoreDirty);			cout<<"Now it is "<<y<<endl;			rcount++;			}		x=setOfLikeAtt->thisLMult[partnum]=y+ntax*log(LikeAttr::Multiplier)		;			cout<<x<<"\t";						return x;		#else	bool atLeastOneModelChanged=false;	int numMods=setOfLikeAtt->GetNModels(partnum);	#ifdef CHARBYCHAR		assert(numMods==1);//Still need to rewrite this loop so that the character loop is on the outside so that the likelihood for the partition is the weighted sum		LikeAttr::currCharIndex=0;		for(int charIndex=0;charIndex<LikeAttr::currNChar;charIndex++)			{	#endif			for(int modn=0;modn<numMods;modn++)				{if(!OnlyScoreDirty || setOfLikeAtt->likeAttribs[partnum][modn]->needsToBeRescored)					{	#ifdef DEBUGGING		#ifdef CHARBYCHAR					//if(LikeAttr::currCharIndex==0)		#endif						//{setOfLikeAtt->GetModel(partnum,modn)->PrintPAUPLsetCommand();						//setOfLikeAtt->GetModel(partnum,modn)->PrintBullLsettingsCommand();						//}	#endif					atLeastOneModelChanged=true;					if(lastScoredLikeAtt!=setOfLikeAtt->likeAttribs[partnum][modn])	//this stuff only needs to be done if the model/partition is different from the last time the likelihood was calculated						PrepareLikeAttrAndAllNodes(partnum,modn);					LikelihoodSweepOverAPartitionModel(recursInternalNodeList);					}				}	#ifdef CHARBYCHAR				x+=setOfLikeAtt->GetLikelihoodFromCondLike(root->setOfLikeInfo,partnum,OnlyScoreDirty);			LikeAttr::currCharIndex++;			cout<<partnum<<"\t"<<x<<endl;						}	#else		if(!OnlyScoreDirty || atLeastOneModelChanged )			x=setOfLikeAtt->GetLikelihoodFromCondLike(root->setOfLikeInfo,partnum,OnlyScoreDirty);	#endif			if(!OnlyScoreDirty || atLeastOneModelChanged )			{			Tree::timesscored++;	#ifdef DEBUGGING			//cout<<Tree::timesscored<<"\t"<<"lscore; ["<<x<<"]"<<endl;	#endif			return x;			}		return setOfLikeAtt->thisL[partnum];#endif}void Tree::PrepareLikeAttrAndAllNodes(int partnum,int modn){	setOfLikeAtt->InitializeLikeAttrStatics(partnum,modn);	Node **temprnl;	temprnl=recursiveNodeList;	while(*temprnl)		(*temprnl++)->SetLikeAtt(partnum,modn);	lastScoredLikeAtt=setOfLikeAtt->GetLikeAtt(partnum,modn);#ifdef CODONHACK	lastScoredLikeAtt->AlertSharedMemory();	LikeAttr::Multiplier=lastScoredLikeAtt->GetMultiplier();#endif}void Tree::PrepareLikeAttrForCalcuation(int partnum,int modn,Node *tempno){	setOfLikeAtt->InitializeLikeAttrStatics(partnum,modn);	if(tempno)		tempno->SetLikeAtt(partnum,modn);	lastScoredLikeAtt=setOfLikeAtt->GetLikeAtt(partnum,modn);#ifdef CODONHACK	lastScoredLikeAtt->AlertSharedMemory();	LikeAttr::Multiplier=lastScoredLikeAtt->GetMultiplier();#endif}void Tree::LikelihoodSweepOverAPartitionModel(Node **temprnl){	//If you send this a Null terminated array of nodes that are in recursive order, this function will sweep down the tree calculating conditional likelihoods	//It assumes that everything is set up to run one Partition/Model	while(*temprnl)		{Node *tempno;double *cl;		tempno=(*temprnl)->ldes;		cl=(*temprnl)->likeInfo->GetCondLikeArray();		tempno->likeInfo->SetArgToCondLikeOfThisSubTree(cl);		tempno=tempno->next;				while(tempno)			{tempno->likeInfo->MultArgByCondLikeOfThisSubTree(cl);			tempno=tempno->next;			}		bool under=true;		for(int ns=0;ns<LikeAttr::currNStates;ns++)			{if(*cl>OVERFLOWCHECK)				throw MTHException("OverFlow");			if(*cl>UNDERFLOWCHECK)				under=false;			*cl++;			}		if(under)			throw MTHException("UnderFlow");		temprnl++;		}	}	void Tree::CalcLikeBelow(Node *nod,Node **localRecNodList){		assert(nod->anc);	double *cl;	cl=nod->anc->likeInfo->GetCondLikeArray();	Node *tempno;		if(nod->anc->anc)			{CalcLikeBelow(nod->anc,localRecNodList);		nod->anc->likeInfo->SetThisCondLikeBasedOnAncArg(nod->anc->anc->likeInfo->GetCondLikeArray());		}	else			nod->anc->likeInfo->SetThisCondLikeToLikeBelowBasedOnArg(lastScoredLikeAtt->freq);		tempno=nod->anc->ldes;	while(tempno)		{if(tempno!=nod)			{*localRecNodList=NULL;			tempno->FillRecursiveInternalNodeList(localRecNodList);			if(*localRecNodList)				LikelihoodSweepOverAPartitionModel(localRecNodList);			tempno->likeInfo->MultArgByCondLikeOfThisSubTree(cl);			}		tempno=tempno->next;		}}double Tree::LScoreDirtyParts(){	time_t beft;	time(&beft);		likelihood = 0.0;	for(int partn=0;partn<setOfLikeAtt->GetNParts();partn++)#ifdef CODONHACK		if(setOfLikeAtt->likeAttribs[partn][0]->needsToBeRescored)			likelihood+=LScoreAlreadyInitialized(partn,true);		else	likelihood+=setOfLikeAtt->thisLMult[partn];#else				likelihood+=LScoreAlreadyInitialized(partn,true);#endif	//ofstream optimizationLog;	//optimizationLog.open("OptimizationLog",ios::app);	//cout<<"\nLikelihood of "<<likelihood<<"\nThat took "<<difftime(time(NULL),beft)<<" seconds.\n";	//optimizationLog<<"Likelihood of "<<likelihood<<"\tThat took "<<difftime(time(NULL),beft)<<" seconds.\n";	//optimizationLog.close();	if(likelihood >MAXDOUBLE /* || likelihood<	0.0*/)		throw LikeUnderFlow();	return likelihood;}vector<int> affParts;	int Tree::GetNumBranches(){	int nb=root->GetNumBranchesAbove();	if(root->ldes->next==root->rdes)		nb--;	return nb;}double Tree::BranchLengthSmoothingPass(PartModIndex owner,vector<PartModIndex>* affected,double maxPasses,double delta,int &NumBranchesAlreadyOptimized){	#ifdef CODONHACK	//numTempArrsNeeded=2+ GetDepthTimesNSib();//double check	int totNumNodes=root->GetNumBranchesAbove();	int totHeight=root->GetHeightAbove(0);	numTempArrsNeeded=(2*totHeight)+5+totNumNodes;	LikeWorkArray **workArrays;	workArrays=new LikeWorkArray *[numTempArrsNeeded];		int numSitesInProtein=setOfLikeAtt->GetNParts();	int *nStatesInThisSite;	Model **modArrays;	nStatesInThisSite=new int[numSitesInProtein];	modArrays=new Model *[numSitesInProtein];		int totSizeOfArrays=0;	for(int i=0;i<numSitesInProtein;i++)		{modArrays[i]=setOfLikeAtt->GetModel(i,0);		totSizeOfArrays+=nStatesInThisSite[i]=modArrays[i]->GetNStates();		}	for(int i=0;i<numTempArrsNeeded;i++)		workArrays[i]=new LikeWorkArray(totSizeOfArrays);				double *cl=workArrays[numTempArrsNeeded-1]->condLikes;	for(int i=0;i<numSitesInProtein;i++)		{double **stFreqs;		stFreqs=setOfLikeAtt->GetModel(i,0)->GetStateFreqs();		for(int j=0;j<nStatesInThisSite[i];j++)			*cl++=*(stFreqs[j]);		}		workArrays[numTempArrsNeeded-1]->owner=root;	workArrays[numTempArrsNeeded-1]->description=LikeWorkArray::BelowTop;	workArrays[numTempArrsNeeded-1]->priority=1;	//root->SetSubCladeBrLenOptField(0);	double improv=RecursiveBranchLengthSmoothingPass(workArrays,nStatesInThisSite,modArrays,workArrays[numTempArrsNeeded-1],totSizeOfArrays,maxPasses,delta,NumBranchesAlreadyOptimized,numSitesInProtein);	delete [] nStatesInThisSite;	delete [] modArrays;	for(int i=0;i<numTempArrsNeeded;i++)		delete  workArrays[i];	delete [] workArrays;	return improv;#else	assert(affected);	Node **nodeBeingMutated;		/*char c;		cin>>c;		if(c=='S')			throw	MTHException("Entered unwritten code Tree::BranchLengthSmoothingPass" );*/		affParts.erase(affParts.begin(),affParts.end());		double *temparray,*tempcl;		for(vector<PartModIndex>::iterator affPMIIt=affected->begin();affPMIIt!=affected->end();affPMIIt++)			{	//make sure that each partition has only 1 model in it . eventually this function should be generalized to allow multiple models per partition, 	//now the likelihoods wouldn't be correctly mixed.  Need to add a vector to store the models for each affected partition			assert(setOfLikeAtt->GetNModels((*affPMIIt).partNum)==1);			affParts.push_back((*affPMIIt).partNum);			}		int numberOfAffectedPartitions=affParts.size();					if(root->ldes->next==root->rdes)//root is a node of degree 2			{//assumes time reversibility			double *rx,*lx;			lx=root->ldes->GetLikeAtt(owner.partNum,owner.modNum)->GetBLenPtr();			rx=root->rdes->GetLikeAtt(owner.partNum,owner.modNum)->GetBLenPtr();			*lx+=*rx;			root->rdes->GetLikeAtt(owner.partNum,owner.modNum)->SetBLen(0.0);			}		nodeBeingMutated=GetRecursiveNodeList();				Node **localRecursNodeList;		localRecursNodeList=new Node *[2*ntax];		int modindex=0;		while(*nodeBeingMutated)			{			for(int partIter=0;partIter<numberOfAffectedPartitions;partIter++)				{	//			for(int modindex=0;modindex<nmods;modindex++)  //when adding more models examine all of the wayes the part/models are called below  when just doing one model affParts and affected are the same size and in the same order	//				{					PrepareLikeAttrAndAllNodes(affParts[partIter],0);					temparray=setOfLikeAtt->GetLikeAboveArray((*affected)[partIter]);	#ifdef CHARBYCHAR					int stepsize=LikeAttr::currNStates*LikeAttr::currNRateCats;					if((*nodeBeingMutated)->ldes)						{*localRecursNodeList=NULL;						(*nodeBeingMutated)->FillRecursiveInternalNodeList(localRecursNodeList);						tempcl=(*nodeBeingMutated)->likeInfo->GetCondLikeArray();						for(LikeAttr::currCharIndex=0; LikeAttr::currCharIndex<LikeAttr::currNChar;LikeAttr::currCharIndex++)							{LikelihoodSweepOverAPartitionModel(localRecursNodeList);							for(int i=0;i<stepsize;i++)								*temparray++=*tempcl++;							tempcl-=stepsize;							}						}					else						(*nodeBeingMutated)->likeInfo->FillDoubleArrayWithCondLikeOfChars(temparray);	#else					int stepsize=LikeAttr::currNStates*LikeAttr::currNRateCats;					if((*nodeBeingMutated)->ldes)						{*localRecursNodeList=NULL;						(*nodeBeingMutated)->FillRecursiveInternalNodeList(localRecursNodeList);						tempcl=(*nodeBeingMutated)->likeInfo->GetCondLikeArray();						LikelihoodSweepOverAPartitionModel(localRecursNodeList);						for(int i=0; i<LikeAttr::currNChar;i++)							{for(int j=0;j<stepsize;j++)								*temparray++=*tempcl++;							}						}					else						(*nodeBeingMutated)->likeInfo->FillDoubleArrayWithCondLikeOfChars(temparray);	#endif								temparray=setOfLikeAtt->GetLikeBelowArray((*affected)[partIter]);	#ifdef CHARBYCHAR					tempcl=(*nodeBeingMutated)->anc->likeInfo->GetCondLikeArray();					for(LikeAttr::currCharIndex=0; LikeAttr::currCharIndex<LikeAttr::currNChar;LikeAttr::currCharIndex++)						{CalcLikeBelow(*nodeBeingMutated,localRecursNodeList);						for(int i=0;i<stepsize;i++)							*temparray++=*tempcl++;						tempcl-=stepsize;						}	#else					tempcl=(*nodeBeingMutated)->anc->likeInfo->GetCondLikeArray();					CalcLikeBelow(*nodeBeingMutated,localRecursNodeList);					for(int i=0; i<LikeAttr::currNChar;i++)						{for(int j=0;j<stepsize;j++)							*temparray++=*tempcl++;						}	#endif				//				}				}			OneBranchLinearBrent(*nodeBeingMutated,(*nodeBeingMutated)->GetLikeAtt(owner.partNum,owner.modNum)->GetBLenParameterPtr(),maxPasses, delta);			nodeBeingMutated++;			if((*nodeBeingMutated) == root->rdes && (root->ldes->next==root->rdes)) 				nodeBeingMutated++;			if(*nodeBeingMutated==root)	 				nodeBeingMutated++;			}		 delete [] localRecursNodeList;		 likelihood=ScoreAffectedBranch(NULL,NULL);#endif}void Tree::OneBranchLinearBrent(Node *nod,PositiveParameter *blen,double maxPasses,double delta){		tempOneBrentScored++;	if(tempOneBrentScored==114)		{int i=0;		i++;		}	double a,b,c,ascore,bscore,cscore;	b=blen->val;	//double initialLike=bscore=ScoreAffectedBranch(nod,NULL); //Use this if the current likelihoods are known to be updated	double initialLike=bscore=ScoreAffectedBranch(nod,blen);	try {		GetSecondPoint(nod,blen,&b,&a,&bscore,&ascore,false);		BracketBranchLen(nod,blen,&a,&b,&c,&ascore,&bscore,&cscore);		}	catch(...)	{return;}	//sort the three values and scores	double temp;	if(a>b)	{temp=ascore;ascore=bscore;bscore=temp;temp=a;a=b;b=temp;}	if(a>c)	{temp=ascore;ascore=cscore;cscore=temp;temp=a;a=c;c=temp;}	if(b>c)	{temp=bscore;bscore=cscore;cscore=temp;temp=b;b=c;c=temp;}		if(!(bscore<ascore && bscore<cscore))		assert(bscore<ascore && bscore<cscore);//requirement of  brent's method		double x=b,w=b,v=b,xscore=bscore,wscore=bscore,vscore=bscore,xm,u,uscore;		int iter=0;	double tolOne,tolTwo,e=0.0,d;	bool firstrep=true;	do	{xm=(a+c)/2.0;		tolTwo=2.0*(tolOne=FTOL*fabs(x)+ZEPS);		if(fabs(x-xm)<=tolTwo*(c-a)/2.0 && !firstrep)				{blen->val=x;			return ;			}		if(fabs(e)>FTOL)//make parabolic fit			{double r,p,q,etemp;			r=(x-w)*(xscore-vscore);			q=(x-v)*(xscore-wscore);			p=(x-v)*q-(x-w)*r;			q=2.0*(q-r);			if(q>0.0)	p=-p;			else		q=-q;			etemp=e;			e=d;			if(fabs(p)>=fabs(q*etemp*0.5) || p<= q*(a-x) || p>=q*(c-x))					d=CGOLDEN*(e=(x>xm ? a-x : c-x));			else	{d=p/q;					 u=x+d;					 if(u-a <tolTwo || c-u <tolTwo)					 	d = ((xm-x)<0.0 ? -tolOne : tolOne);					 }			}		else			d=CGOLDEN*(e=(x>=xm ?a-x : c-x));		u=(fabs(d) >=tolOne ? x+d : x + (d<0.0 ? -tolOne :tolOne));		blen->val=u;		uscore=ScoreAffectedBranch(nod,blen);		firstrep=false;		if(uscore<=xscore)			{if(u>=x)	a=x;			else		c=x;			v=w;w=x;x=u;			vscore=wscore;wscore=xscore;xscore=uscore;			}		else			{if(u<x)	a=u;			else		c=u;			if(uscore<=wscore || w==x)				{v=w;w=u;				vscore=wscore;wscore=uscore;				}			else				if(uscore<=vscore || v==x || v==w)					{v=u;					vscore=uscore;					}			}		iter++;		}	while(iter<maxPasses && (wscore-xscore)>delta);	blen->val=x;}void Tree::OneBranchLinearBrent(double *condLikesBelow,Node *,double maxPasses,double delta){}#define BLENSTEPSIZE 2.0void Tree::BracketBranchLen(Node *nod,PositiveParameter *blen,double *a,double *b,double *c,double *ascore,double *bscore,double *cscore){//mnbrak of the numerical recipes	if(*bscore>*ascore)		{double temp=*bscore; *bscore=*ascore; *ascore=temp; temp=*b; *b=*a; *a=temp;		}	*c=*b;	*cscore=*bscore;	while(fabs(*bscore-*cscore)<SMALLDOUBLE)		{blen->val=*c=*c+BLENSTEPSIZE*(*c-*a);		if(*c<MINBRLEN)				{			GetBracketNearMin(nod,blen,a,b,c,ascore,bscore,cscore);			return;			}		if(*c>MAXBRLEN)			{			GetBracketNearMax(nod,blen,a,b,c,ascore,bscore,cscore);			return;			}		*cscore=ScoreAffectedBranch(nod,blen);		}	if(*cscore<*bscore)		{*a=*b;		*b=*c;		*ascore=*bscore;		*bscore=*cscore;		BracketBranchLen(nod,blen,a,b,c,ascore,bscore,cscore);		}}void Tree::GetSecondPoint(Node *nod,PositiveParameter *blen,double *firPt,double *secPt,double *firSc,double *secSc,bool OnlyDecrease){	*secPt=*firPt;	*secSc=*firSc;	double multiplier=1.1;	while(fabs((*secSc-*firSc)/(*secSc))<SMALLDOUBLE && *secPt>(MINBRLEN-SMALLDOUBLE) && *secPt<=MAXBRLEN)		{if(*firPt<MINBRLEN*2.0)					(*secPt)*=2.0;		else	if(*firPt>MAXBRLEN*.9  || OnlyDecrease)					(*secPt)/=multiplier;				else					(*secPt)*=multiplier;		if(*secPt>(MINBRLEN-SMALLDOUBLE) && *secPt<=MAXBRLEN)			{blen->val=*secPt;			*secSc=ScoreAffectedBranch(nod,blen);			}		multiplier*=1.1;		}	if(*secPt<MINBRLEN-SMALLDOUBLE)		{assert(*firPt>MAXBRLEN*.9 || OnlyDecrease);		*secPt=MINBRLEN;		blen->val=*secPt;		*secSc=ScoreAffectedBranch(nod,blen);		if(fabs((*secSc-*firSc)/(*secSc))<SMALLDOUBLE)			{blen->val=*firPt;			AtPeakLike();			}		}	if(*secPt>MAXBRLEN)		{assert(*firPt<MAXBRLEN*.9);		if(*firPt<MINBRLEN*2.0)			{*secPt=MINBRLEN;			blen->val=*secPt;			*secSc=ScoreAffectedBranch(nod,blen);			if(fabs((*secSc-*firSc)/(*secSc))<SMALLDOUBLE)				{blen->val=*firPt;				AtPeakLike();				}			}		else			GetSecondPoint(nod,blen,firPt,secPt,firSc,secSc,true);		}}void Tree::GetBracketNearMin(Node *nod,PositiveParameter *blen,double *a,double *b,double *c,double *ascore,double *bscore,double *cscore){	blen->val=*c=MINBRLEN;	if(fabs(1-*b/(*c))<FTOL)		{*cscore=*bscore;		if(*a<(MINBRLEN*(1.0+FTOL))*(1.0+FTOL))			{blen->val=*b;			throw AtPeakLike();			}		*b=*c;		*bscore=*cscore;		while(fabs(*bscore-*cscore)<SMALLDOUBLE)			{blen->val=*b=*b+MINBRLEN;			*bscore=ScoreAffectedBranch(nod,blen);			if(*bscore-*cscore>SMALLDOUBLE)				{blen->val=*c;				throw AtPeakLike();				}			else				if(*cscore-*bscore>SMALLDOUBLE)					return;			}		}	*cscore=ScoreAffectedBranch(nod,blen);	if(*cscore<*bscore)		{if(*b<MINBRLEN*(1.0+FTOL)*(1.0+FTOL))			{blen->val=*c;			throw AtPeakLike();			}		*a=*b;		*ascore=*bscore;		*b=*c;		*bscore=*cscore;		while(fabs(*bscore-*cscore)<SMALLDOUBLE)			{blen->val=*b=*b+MINBRLEN;			*bscore=ScoreAffectedBranch(nod,blen);			if(*bscore-*cscore>SMALLDOUBLE)				{blen->val=*c;				throw AtPeakLike();				}			else				if(*cscore-*bscore>SMALLDOUBLE)					return;			}		}}void Tree::GetBracketNearMax(Node *nod,PositiveParameter *blen,double *a,double *b,double *c,double *ascore,double *bscore,double *cscore){	blen->val=*c=MAXBRLEN;	if(fabs(1-*b/(*c))<FTOL)		{*cscore=*bscore;		if(*a>(MAXBRLEN*(1.0-FTOL))*(1.0-FTOL))			{blen->val=*b;			throw AtPeakLike();			}		*b=MAXBRLEN;		while(fabs((*bscore-*cscore)/(*bscore))<SMALLDOUBLE)			{blen->val=*b=(*b+*a)/2.0;			*bscore=ScoreAffectedBranch(nod,blen);			if((*bscore-*cscore)/(fabs(*bscore))>SMALLDOUBLE  || (*bscore-*ascore)/(fabs(*bscore))>SMALLDOUBLE || fabs(1-*a/(*b))<FTOL)				{blen->val=*c;				throw AtPeakLike();				}			else if((*cscore-*bscore)/(fabs(*bscore))>SMALLDOUBLE)				return;			}		}	*cscore=ScoreAffectedBranch(nod,blen);	if(*cscore<*bscore)		{if(*b>(MAXBRLEN*(1.0-FTOL))*(1.0-FTOL))			{blen->val=*c;			throw AtPeakLike();			}		*a=*b;		*ascore=*bscore;		*b=MAXBRLEN;		*bscore=*cscore;		while(fabs((*bscore-*cscore)/(*bscore))<SMALLDOUBLE)			{blen->val=*b=(*b+*a)/2.0;			*bscore=ScoreAffectedBranch(nod,blen);			if((*bscore-*cscore)/(fabs(*bscore))>SMALLDOUBLE  || (*bscore-*ascore)/(fabs(*bscore))>SMALLDOUBLE || fabs(1-*a/(*b))<FTOL)				{blen->val=*c;				throw AtPeakLike();				}			else if((*cscore-*bscore)/(fabs(*bscore))>SMALLDOUBLE)				return;			}		}}double Tree::ScoreAffectedBranch(Node *nod,PositiveParameter *blen){	//Right now this is just coded for one model PARTITIONS	int numberOfAffectedPartitions=affParts.size();		double totlike=0.0;	if(blen)		{cout<<nod->name<<"\t"<<blen->val<<"\t";		for(int partIter=0;partIter<numberOfAffectedPartitions;partIter++)			//if allowing blen modifiers, put them here and pass to GetOneBranchLike nod->likeInfo->			{setOfLikeAtt->InitializeLikeAttrStatics(affParts[partIter],0);#ifdef		DZRATES			totlike+=setOfLikeAtt->GetLikeAtt(affParts[partIter],0)->GetOneBranchLike(setOfLikeAtt->GetRateSets(), blen,nod->GetLikeAtt(affParts[partIter],0)->GetBLenModPtr());#else			totlike+=setOfLikeAtt->GetLikeAtt(affParts[partIter],0)->GetOneBranchLike(blen,nod->GetLikeAtt(affParts[partIter],0)->GetBLenModPtr());#endif			}		}	else		for(int partIter=0;partIter<numberOfAffectedPartitions;partIter++)			totlike+=setOfLikeAtt->GetLikeAtt(affParts[partIter],0)->currentLikelihood;	cout<<totlike<<endl;	return totlike;}void Tree::Print(ostream &usrstream,bool withBrLen,bool tabbing/*=false*/){	usrstream<<"TREE "<<name<<"= [&U] ";	if(tabbing)	usrstream<<"\n";	if(root)		root->Print(usrstream,withBrLen,0,tabbing);	usrstream<<";"<<endl;}void Tree::PrintModel(ostream &usrstream){	setOfLikeAtt->PrintModel(usrstream);}void Tree::PrepareParsAttrForCalcuation(int partnum){	setOfParsAtt->InitializeParsAttrStatics(partnum);	Node **temprnl;	temprnl=recursiveNodeList;	while(*temprnl)		(*temprnl++)->SetParsAtt(partnum);	lastScoredParsAtt=setOfParsAtt->GetParsAtt(partnum);}int Tree::FirstPass(int charact)// a character by character parsimony down pass returning the score for the tree for this character (bifurcating trees, unordered characters only){	Node **temprnl=recursInternalNodeList;	//assumes that PrepareParsAttrForCalculation(int) has been called for this partition and that the tree is binary	int sc=0;	short *rsh,*lsh,*dest;	bool intersec=false;	while(*temprnl)		{Node *tempno;		dest=(*temprnl)->parsInfo->GetDownPass(charact);		tempno=(*temprnl)->ldes;		if(tempno->next==(*temprnl)->rdes)//bifurcating			{lsh=tempno->parsInfo->GetDownPass(charact);			tempno=tempno->next;			rsh=tempno->parsInfo->GetDownPass(charact);			intersec=false;			for(int i=0;i<ParsAttr::currShortPerChar;i++)				{*(dest+i)=*(lsh+i)&(*(rsh+i));				if(*(dest+i))					intersec=true;				}			if(!intersec)					{sc++;				for(int i=0;i<ParsAttr::currShortPerChar;i++)					*(dest+i)=*(lsh+i)|(*(rsh+i));				}			}		else			{//really slow way of dealing with polytomies			lsh=tempno->parsInfo->GetDownPass(charact);			for(int i=0;i<ParsAttr::currShortPerChar;i++)				*(dest+i)=*(lsh+i);			Node *secTemp;			secTemp=tempno->next;			while(secTemp) //see if there is an intersection of all states first				{lsh=secTemp->parsInfo->GetDownPass(charact);				for(int i=0;i<ParsAttr::currShortPerChar;i++)					*(dest+i)&=*(lsh+i);				secTemp=secTemp->next;				}			bool intersec=false;			for(int i=0;(!intersec &&i<ParsAttr::currShortPerChar);i++)				if(*(dest+i))					intersec=true;			if(!intersec)//if there is no shared state find the most parsimonious				{assert(sizeof(short)==2);				int *nWithThis;				nWithThis=new int[ParsAttr::currNStates];				for(int k=0;k<ParsAttr::currNStates;k++)						nWithThis[k]=0;				int maxnwt=0,statesch,shortcount;				short temp;				int ndes=0;				while(tempno)					{ndes++;					lsh=tempno->parsInfo->GetDownPass(charact);					statesch=0;					shortcount=0;					temp=*lsh;					while(statesch<ParsAttr::currNStates)						{if(temp&1)							{nWithThis[statesch]++;							if(nWithThis[statesch]>maxnwt)								maxnwt=nWithThis[statesch];							}						temp>>=1;						statesch++;						if(shortcount<15)							shortcount++;						else	{shortcount=0;								lsh++;								temp=*lsh;								}						}					tempno=tempno->next;					}				statesch=0;				shortcount=0;				*dest=0;				temp=1;				while(statesch<ParsAttr::currNStates)//put every state with that has nWithThis=maxnwt into dest loop 					{if(nWithThis[statesch]==maxnwt)						*dest|=temp;					statesch++;					if(shortcount<15)						{temp<<=1;						shortcount++;						}					else	{shortcount=0;							dest++;							*dest=0;							temp=1;							}					}				sc+=ndes-maxnwt;				delete [] nWithThis;				}			}		temprnl++;		}	//cout<<charact<<"\t"<<sc<<endl;	return sc;}void Tree::SecondPass(int charact){	Node **temprnl=recursiveNodeList;	Node **begrnl=recursiveNodeList;	while(*temprnl)	temprnl++;	temprnl--;		bool	done=false;	short *ancsh,*thisDown,*rsh,*lsh,*dest;	bool intersec=false;	//make root's down pass set it's final set	assert(!((*temprnl)->anc));	dest=(*temprnl)->parsInfo->GetUpPass(charact);	ancsh=(*temprnl)->parsInfo->GetDownPass(charact);	for(int i=0;i<ParsAttr::currShortPerChar;i++)		*(dest+i)=*(ancsh+i);	temprnl--;		while(!done)		{Node *tempno;		ancsh=(*temprnl)->anc->parsInfo->GetUpPass(charact);		thisDown=(*temprnl)->parsInfo->GetDownPass(charact);		dest=(*temprnl)->parsInfo->GetUpPass(charact);		if((*temprnl)->ldes)			{bool contain=true;			for(int i=0;(contain && i<ParsAttr::currShortPerChar);i++)//Fitch I				{*(dest+i)=(*(ancsh+i))&(*(thisDown+i));				if(*(dest+i)!=*(ancsh+i))					contain=false;				}			if(!contain)				{bool fromUnion=true;				tempno=(*temprnl)->ldes;				if((tempno->next==(*temprnl)->rdes))					{lsh=tempno->parsInfo->GetDownPass(charact);					tempno=tempno->next;					rsh=tempno->parsInfo->GetDownPass(charact);					for(int i=0;(fromUnion && i<ParsAttr::currShortPerChar);i++) //Fitch III						if((*(lsh+i))&(*(rsh+i)))							fromUnion=false;					if(fromUnion)						for(int i=0;i<ParsAttr::currShortPerChar;i++) //Fitch IV							*(dest+i)=(*(ancsh+i))|(*(thisDown+i));					else						for(int i=0;i<ParsAttr::currShortPerChar;i++) //Fitch IV							*(dest+i)=(*(thisDown+i))|((*(ancsh+i))&(*(rsh+i)))|((*(lsh+i))&(*(ancsh+i)));					}				else					{//slow way of dealing with polytomies					//Test if the down pass came from a union 					short *interSecOfDes;					interSecOfDes=new short[ParsAttr::currShortPerChar];					lsh=tempno->parsInfo->GetDownPass(charact);					for(int i=0;i<ParsAttr::currShortPerChar;i++)						*(interSecOfDes+i)=*(lsh+i);					Node *secTemp;					secTemp=tempno->next;					while(secTemp) //see if there is an intersection of all states first						{lsh=secTemp->parsInfo->GetDownPass(charact);						for(int i=0;i<ParsAttr::currShortPerChar;i++)							*(interSecOfDes+i)&=*(lsh+i);						secTemp=secTemp->next;						}					for(int i=0;(fromUnion &&i<ParsAttr::currShortPerChar);i++)						if(*(interSecOfDes+i))							fromUnion=false;					if(fromUnion)						for(int i=0;i<ParsAttr::currShortPerChar;i++) //Fitch IV same as for bifurcating trees (?)							*(dest+i)=(*(ancsh+i))|(*(thisDown+i));					else						{//Fitch V add any state that is present in anc's uppass and ndes-1 descendants downpass						assert(sizeof(short)==2);						int *nWithThis;						nWithThis=new int[ParsAttr::currNStates];						for(int k=0;k<ParsAttr::currNStates;k++)								nWithThis[k]=0;						int statesch,shortcount;						short temp;						int ndes=0;						while(tempno)							{ndes++;							lsh=tempno->parsInfo->GetDownPass(charact);							statesch=0;							shortcount=0;							temp=*lsh;							while(statesch<ParsAttr::currNStates)								{if(temp&1)									nWithThis[statesch]++;								temp>>=1;								statesch++;								if(shortcount<15)									shortcount++;								else	{shortcount=0;										lsh++;										temp=*lsh;										}								}							tempno=tempno->next;							}						statesch=0;						shortcount=0;						*dest=0;						temp=1;						while(statesch<ParsAttr::currNStates)//put every state with that has nWithThis=ndes-1 and is in the ancinto dest loop 							{if(nWithThis[statesch]==ndes-1 && temp&(*ancsh))								*dest|=temp;							statesch++;							if(shortcount<15)								{temp<<=1;								shortcount++;								}							else	{shortcount=0;									dest++;									ancsh++;									*dest=0;									temp=1;									}							}						delete [] nWithThis;						}								}				}			}		else			{bool intersec=false;			for(int i=0;i<ParsAttr::currShortPerChar;i++)				if(*(dest+i)=(*(ancsh+i))&(*(thisDown+i)))//assignment and test					intersec=true;			if(!intersec)				for(int i=0;i<ParsAttr::currShortPerChar;i++) 					*(dest+i)=*(thisDown+i);			}		if(temprnl==begrnl)	done=true;		else	temprnl--;		}}double Tree::GetPStateFreq(int charact,int state,int mode)//0 is maximize the character state, 1 is minimize it this is a temporary approximation{	assert(mode==0 || mode==1);	Node **temprnl=recursiveNodeList;	Node **begrnl=recursiveNodeList;	while(*temprnl)	temprnl++;	temprnl--;	temprnl--;	short *codedState;	codedState=new short[ParsAttr::currShortPerChar];	short cmask;	if(mode==0)		for(int st=0;st<ParsAttr::currShortPerChar;st++)			{if(state>15 || state<0)				codedState[st]=0;			else	{cmask=1;					if(state)							cmask<<=state;					codedState[st]=cmask;					}			state-=16;			}	else		{assert(mode==1);		for(int st=0;st<ParsAttr::currShortPerChar;st++)			{if(state>15 || state<0)				codedState[st]=~0;			else	{cmask=1;					if(state)							cmask<<=state;					codedState[st]=~cmask;					}			state-=16;			}		}	double totbranch=0.0;	short *finalRecon;	bool done=false;	while(!done)		{finalRecon=(*temprnl)->parsInfo->GetUpPass(charact);		bool intersec=false;		for(int i=0;(!intersec && i<ParsAttr::currShortPerChar);i++) 			if(finalRecon[i]&codedState[i])				intersec=true;		if((intersec && !mode) || (!intersec && mode))			{double *blenptr;			blenptr=(*temprnl)->GetLikeAtt(0,0)->GetBLenPtr();			assert(blenptr);			totbranch+=*blenptr;			}		if(temprnl==begrnl)	done=true;		else	temprnl--;		}	delete []codedState;	return totbranch;}void Tree::NameInternalNodes(){	assert(root);	assert(ntax);	root->NameSelfAndInternalDescendants(ntax);}void Tree::ShowTree(int windowWidth,int displayMode/*=branchDisplay(allNames)*/,int optArg/*=0*/){	vector<horizLine> hlines;	vector<vertLine> vlines;	try		{root->AddLinesToBeDisplayed(windowWidth-1,0,0,0,&hlines,&vlines);		for(int i=0;i<2*ntax;i++)			{for(int j=0;j<windowWidth-SPACES_FOR_TAXNAME;j++)				{for(vector<horizLine>::iterator hIt=hlines.begin();hIt!=hlines.end();hIt++)					while(hIt->IsInLine(i,j))						{if(displayMode==branchDisplay(ParsUpPass))							hIt->Display(&i,&j,windowWidth,displayMode,optArg,lastScoredParsAtt->encodingType);						else	hIt->Display(&i,&j,windowWidth,displayMode);						hIt=hlines.begin();						}				bool inALine=false;				for(vector<vertLine>::iterator vIt=vlines.begin();(!inALine && vIt!=vlines.end());vIt++)					if(vIt->IsInLine(i,j))						{inALine=true;						if(vIt->IsTopOfLine(i,j)) cout<<'/';						else if(vIt->IsBotOfLine(i,j))	cout<<"\\";						else	cout<<"|";						}				if(!inALine)						cout<<" ";				}			cout<<endl;				}		}	catch (ImproperLine x)		{cout<<"The window is too small to display this tree,\nand there is nothing you can do about it\n(if you can't recompile it)"<<endl;		}					}double Tree::RecursiveBranchLengthSmoothingPass(LikeWorkArray **workArrays,int *nStatesInThisSite,Model **modArrays,LikeWorkArray *below,int totSizeOfArrays,double maxPasses,double delta,int &NumBranchesAlreadyOptimized,int numSitesInProtein){	try		{int numTempArrsLeft=numTempArrsNeeded;		bool done=false;		double y;		if(root->ldes->next==root->rdes)//unrooted, but not a polytomy at the root			{root->ldes->GetLikeAtt(0,0)->SetBLen(*(root->ldes->GetLikeAtt(0,0)->GetBLenPtr())+*(root->ldes->GetLikeAtt(0,0)->GetBLenPtr()));			root->rdes->GetLikeAtt(0,0)->SetBLen(0);			}		//if(NumBranchesAlreadyOptimized<1) //need to write to disk all of the condlikes			y=SweepOverTreeStoringCondLikeAboveBottom(workArrays,numTempArrsNeeded);		Node::NumBranchesOptimized=NumBranchesAlreadyOptimized;		//assert(fabs(y-likelihood)<0.1);		//root->ResetLWAs();		Node::currPrioritySetting=2;//resets number to keep track of which array should be the next to be taken		Node::TreesCurrentLikelihood=0.0;		for(int i=0;i<numSitesInProtein;i++)			Node::TreesCurrentLikelihood+=setOfLikeAtt->thisL[i];		double beflike=Node::TreesCurrentLikelihood;		root->OptimizeDescendantsBranches(workArrays,nStatesInThisSite,modArrays,below,totSizeOfArrays,maxPasses,delta,NumBranchesAlreadyOptimized,numTempArrsNeeded,numSitesInProtein);				//update the tree set of like attr  this iterates nStatesInThisSite and modArrays off the END		assert(root->lwa->owner==root && root->lwa->description==LikeWorkArray::AboveTop);		double *cl=root->lwa->condLikes;		double *stf=below->condLikes;		likelihood=0.0;		double afterLike=0.0;		for(int i=0;i<numSitesInProtein;i++)			{TreeLikeAttr *tempTLA=setOfLikeAtt->GetLikeAtt(i,0);			double templ=0.0;			for(int j=0;j<*nStatesInThisSite;j++)				templ+=*cl++**stf++;			afterLike+=setOfLikeAtt->thisL[i]=-log(templ);			likelihood+=setOfLikeAtt->thisLMult[i]=setOfLikeAtt->thisL[i]+(ntax*log((*modArrays++)->GetMultiplier()));			tempTLA->currentLikelihood=setOfLikeAtt->thisL[i];			tempTLA->needsToBeRescored=false;			nStatesInThisSite++;			}				root->ResetLWAs();		/*while(!done)			{root->FillNumBranchesAbove();			root->FillNumTermBranchesAbove();			root->FillNumArraysNeededToOptBranches(1);			int x=0;			Node *tempno=root->GetRootOfNextSubCladeToOptimize(numTempArrsLeft,x,root);			if(tempno==root)				done=true;			RecursiveBranchLengthSmoothingPassOnSubTree(tempno,workArrays,nStatesInThisSite,below,totSizeOfArrays,maxPasses,delta);			numTempArrsLeft--;			}*/		return (beflike-afterLike);		}	catch (NoFreeWorkArrayException x)		{cout<<"an Insufficient amount number of likeWorkArrays were created"<<endl;		assert(0);		}	catch (RequestedWorkArrayNotFoundException x)		{cout<<"A necessary likeWorkArrays wasn't found"<<endl;		assert(0);		}	//OLD WAY optimize branch on left des, it's next, etc to rdes	/*try		{if(thisNode->anc)			{if(!thisNode->ldes)	return;//nothing to do at terminals			//Step 1 get condlike aboveBot condlike's for all sisters			Node* tempno=thisNode->ldes->next;			LikeWorkArray *templwa;			LikeWorkArray *belowThis;			belowThis=RequestFreeLikeWorkArray(workArrays,numTempArrsNeeded);			belowThis->description=LikeWorkArray::BelowBott;			belowThis->owner=thisNode->ldes;						double *tempDest=belowThis->condLikes;			double *tempSource=below->condLikes;			for(int i=0;i<totSizeOfArrays;i++)				*tempDest++=*tempSource++;						while(tempno)				{templwa=RequestFreeLikeWorkArray(workArrays,numTempArrsNeeded);				templwa->description=LikeWorkArray::AboveBott;				templwa->owner=tempno;				SetArrayToAboveBottOfNode(templwa->condLikes,tempno,nStatesInThisSite);								tempDest=belowThis->condLikes;//multiply this condlike array to the belowThis array 				tempSource=templwa->condLikes;				for(int i=0;i<totSizeOfArrays;i++)					*tempDest++*=*tempSource++;				tempno=tempno->next;				}			OneBranchLinearBrent(belowThis->condLikes,thisNode->ldes,maxPasses,delta);						}		else			{assert(thisNode->ldes);			}		}	catch (NoFreeWorkArrayException x)		{cout<<"an Insufficient amount number of likeWorkArrays were created"<<endl;		assert(0);		}	catch (RequestedWorkArrayNotFoundException x)		{cout<<"A necessary likeWorkArrays wasn't found"<<endl;		assert(0);		}*/	return 0;}/*void Tree::RecursiveBranchLengthSmoothingPassOnSubTree(Node *thisNode,LikeWorkArray **workArrays,int *nStatesInThisSite,LikeWorkArray *below,int totSizeOfArrays,double maxPasses,double delta){	thisNode->brLenOptSetting=(BLOSPSEUDTERM|BLOSFINISHED);	Node *tempno=thisNode->anc;	while(tempno)		{tempno->brLenOptSetting|=BLOSBELOWSUBTREE;		tempno=tempno->anc;		}	}*/LikeWorkArray* RequestFreeLikeWorkArray(LikeWorkArray **workArrays,int maxNum){	for(int i=0;i<maxNum;i++)		if(!(workArrays[i]->owner))			return workArrays[i];	throw NoFreeWorkArrayException();}LikeWorkArray* RequestSpecificLikeWorkArray(LikeWorkArray **workArrays,int maxNum,Node *reqNo,int reqDesc){	for(int i=0;i<maxNum;i++)		if(workArrays[i]->owner==reqNo && workArrays[i]->description==reqDesc)			return workArrays[i];	throw RequestedWorkArrayNotFoundException();}void Tree::SetArrayToAboveBottOfNode(double *cl,Node *tempno,int *nStatesInThisSite){	int totNParts=setOfLikeAtt->GetNParts();	for(int partn=0;partn<totNParts;partn++)		{PrepareLikeAttrForCalcuation(partn,0,tempno);		tempno->likeInfo->SetArgToCondLikeOfThisSubTree(cl);		cl+=*nStatesInThisSite++;		}}void Tree::ReRoot(Node *futldes){	assert(root);cout<<"using temporary reroot, that doesn't deal with like attr, only directly owned node data members"<<endl;	if(futldes->anc)		{if(root->ldes->next==root->rdes)//tree is binary at the root			{Node* tempro;			tempro=root->CopyToShare();			root->ldes=futldes;			root->rdes=futldes->anc;			futldes->anc->DirectToNewAnc(futldes);			}		else			{Node* tempro;			tempro=root->Copy();//root isn't binary so it won't be disconnected			root->ldes=futldes;			root->rdes=futldes->anc;			futldes->anc->DirectToNewAnc(futldes);			}					}	else		assert(futldes==root);}double Tree::SweepOverTreeStoringCondLikeAboveBottom(LikeWorkArray **workArrays,int numArrays){	#ifdef CODONHACK		bool printstuff=false;	double tempcl[64];	double y = 0.0;	int placeInCondLikeArr=0;	for(int partn=0;partn<setOfLikeAtt->GetNParts();partn++)		{bool printstuff=false;		if(partn==312)			bool stophere=true;		cout<<partn<<" ";			if(lastScoredLikeAtt!=setOfLikeAtt->likeAttribs[partn][0])	//this stuff only needs to be done if the model/partition is different from the last time the likelihood was calculated				PrepareLikeAttrAndAllNodes(partn,0);			else	PrepareLikeAttrForCalcuation(partn,0,NULL);//in case model is the same but it has changed size			if(partn)				root->CalculateCondLikeAboveBottomAndStore(tempcl,placeInCondLikeArr,workArrays,numArrays);			else				root->CalculateCondLikeAboveBottomAndStore(tempcl,placeInCondLikeArr,workArrays,numArrays,false);			printstuff=true;		int rcount=0;		setOfLikeAtt->GetLikelihoodFromCondLike(root->setOfLikeInfo,partn,false);		y+=setOfLikeAtt->thisLMult[partn]=ntax*log(LikeAttr::Multiplier)+setOfLikeAtt->thisL[partn];				while(!(setOfLikeAtt->thisL[partn]<log(MAXDOUBLE) && setOfLikeAtt->thisL[partn]>(-1.0*log(MAXDOUBLE))))			{y-=setOfLikeAtt->thisL[partn];			if(rcount==10)				assert(0);				//throw MTHException("Too many Overflow corrections");			cout<<"For site "<<partn<<" changing the multiplier from "<<LikeAttr::Multiplier;			if(setOfLikeAtt->thisL[partn]<(-1.0*log(MAXDOUBLE)))				lastScoredLikeAtt->model->SetMultiplier(1.2+lastScoredLikeAtt->GetMultiplier());			else				lastScoredLikeAtt->model->SetMultiplier(lastScoredLikeAtt->GetMultiplier()-1.2);			LikeAttr::Multiplier=lastScoredLikeAtt->GetMultiplier();			cout<<" to "<<LikeAttr::Multiplier<<"\n likelihood was "<<y<<endl;			if(partn)				root->CalculateCondLikeAboveBottomAndStore(tempcl,placeInCondLikeArr,workArrays,numArrays);			else				root->CalculateCondLikeAboveBottomAndStore(tempcl,placeInCondLikeArr,workArrays,numArrays,false);			setOfLikeAtt->GetLikelihoodFromCondLike(root->setOfLikeInfo,partn,false);			y+=setOfLikeAtt->thisLMult[partn]=ntax*log(LikeAttr::Multiplier)+setOfLikeAtt->thisL[partn];			cout<<"Now it is "<<setOfLikeAtt->thisLMult[partn]<<endl;			rcount++;			}				cout<<setOfLikeAtt->thisLMult[partn]<<"\t";		placeInCondLikeArr+=LikeAttr::currNStates;		}	if(y >MAXDOUBLE /*|| likelihood<	0.0*/)		throw LikeUnderFlow();	return y;#else	assert(0);#endif}