#include "basicbulldefs.h"#include "charencoding.h"/*int GetNumLongsNeededByCoding(int i)	{	switch(i) {	case EncodingType(DNANoGap) :	return 1;	default	:	return 1;	}}*/bool LessPackable(int i,int j)	{	if( i != EncodingType(DNANoGap) && i!= EncodingType(MitoCodons) && i!= EncodingType(AminoAcid) )	throw UnknownEncoding("Not DNANogap Or Codons or AminoAcid encoding");	if( j != EncodingType(DNANoGap) && j!= EncodingType(MitoCodons) && i!= EncodingType(AminoAcid) )	throw UnknownEncoding("Not DNANogap Or Codons or AminoAcid encoding");	//ADD CODE AS ENCODING TYPES ARE ADDED		if(i==EncodingType(MitoCodons) && (j==EncodingType(DNANoGap) || j==EncodingType(AminoAcid)))		return true;	if(i==EncodingType(AminoAcid) && j==EncodingType(DNANoGap))		return true;	return false;}bool CanTreatGapsAsFifthBase(int i){	if(i==EncodingType(DNANoGap) || i==EncodingType(MitoCodons) || i==EncodingType(AminoAcid))		return false;	return true;}int NumColumnsPerCharacter(int i)	{	if(i==EncodingType(DNANoGap) || i==EncodingType(AminoAcid))	return 1;	if(i==EncodingType(MitoCodons) || i==EncodingType(SubModMitoCodons) || i==EncodingType(SubModNucCodons))	return 3;	throw UnknownEncoding("Not DNANogap Or Codons Or Amino Acid encoding");	return 0;}int NumShortsPerCharacter(int i)	{	if(i==EncodingType(DNANoGap) )	return 1;	assert(sizeof(short)==2);	if(i==EncodingType(AminoAcid) )	return 2;	if(i==EncodingType(MitoCodons) )	return 4;	throw UnknownEncoding("Not DNANogap Or Codons Or Amino Acid encoding");	return 0;}int NumStates(int i)	{	if(i==EncodingType(DNANoGap) )	return 4;	if(i==EncodingType(MitoCodons) )	return 64;	if(i==EncodingType(AminoAcid) )	return 21;	throw UnknownEncoding("Not DNANogap Or Codons Or Amino Acid encoding");	return 0;}int NumStatesInLastShort(int i)	{	if(i==EncodingType(DNANoGap) )	return 4;	assert(sizeof(short)==2);	if(i==EncodingType(MitoCodons) )	return 16;	if(i==EncodingType(AminoAcid) )	return 5;	throw UnknownEncoding("Not DNANogap Or Codons Or Amino Acid encoding");	return 0;}short EncodeDNAChar(short c,bool keepGap/*=false*/){		switch(c)	{  case 'A' : return 1;               case 'C' : return 2;               case 'G' : return 4;               case 'T' : return 8;               case 'N' : return 15;               case '-' :	if(keepGap) return 16;               							return 15;               case 'R' : return 5;               case 'Y' : return 10;               case 'M' : return 3;               case 'S' : return 6;               case 'V' : return 7;               case 'W' : return 9;               case 'H' : return 11;               case 'K' : return 12;               case 'D' : return 13;               case 'B' : return 14;               case '?' : if(keepGap)	return 31;               			 // else falls through and throws an exception               default  : throw MTHException("Incorrect DNA Character");			}        return(0);}char GetNameOfIthDNAState(int c){		switch(c)	{  case 0 : return 'A';	           case 1 : return 'C';               case 2 : return 'G';               case 3 : return 'T';               case 4 : return '-';               			               default  : throw MTHException("Incorrect DNA Character");			}        return(0);}int DecodeDNACharInOneChar(short c,bool keepGap/*=false*/){	switch(c)	{  case 1 : return 'A';               case 2 : return 'C';               case 4 : return 'G';               case 8 : return 'T';               case 15 : return 'N';               case 16 :  if(keepGap)	return '-';               			  else 			throw MTHException("Incorrect DNA Character");               case 5 :   return 'R';               case 10 :   return 'Y';               case 3 :   return 'M';               case 6 :   return 'S';               case 7 :   return 'V';               case 9 :   return 'W';               case 11 :   return 'H';               case 12 :   return 'K';               case 13 :   return 'D';               case 14 :   return 'B';               case 31 :   if(keepGap)	return '-';               				//else falls through to throw exception               default : throw MTHException("Incorrect DNA Character");			}    return(0);}nxsstring DecodeDNACharAsStr(short c,bool keepGap/*=false*/){	nxsstring retstr;	retstr=(char)  DecodeDNACharInOneChar(c,keepGap);	return retstr;}void EncodeProteinChar(short *dest,short c,bool keepGap/*=false*/){	switch(c)	{  case 'A' : dest[0]=1; dest[1]=0; break;               case 'C' : dest[0]=2; dest[1]=0; break;               case 'D' : dest[0]=4; dest[1]=0; break;               case 'E' : dest[0]=8; dest[1]=0; break;               case 'F' : dest[0]=16; dest[1]=0; break;               case 'G' : dest[0]=32; dest[1]=0; break;               case 'H' : dest[0]=64; dest[1]=0; break;               case 'I' : dest[0]=128; dest[1]=0; break;               case 'K' : dest[0]=256; dest[1]=0; break;               case 'L' : dest[0]=512; dest[1]=0; break;               case 'M' : dest[0]=1024; dest[1]=0; break;               case 'N' : dest[0]=2048; dest[1]=0;; break;               case 'P' : dest[0]=4096; dest[1]=0; break;               case 'Q' : dest[0]=8192; dest[1]=0; break;               case 'R' : dest[0]=16384; dest[1]=0; break;               case 'S' : dest[0]=16384; dest[0]<<=1;	dest[1]=0; break;               case 'T' : dest[0]=0; dest[1]=1; break;               case 'V' : dest[0]=0; dest[1]=2; break;               case 'W' : dest[0]=0; dest[1]=4; break;               case 'Y' : dest[0]=0; dest[1]=8; break;               case '*' : dest[0]=0; dest[1]=16; break;               case 'X' : dest[0]=~0; dest[1]=31; break;               case '-' : if(keepGap)	{dest[0]=0; dest[1]=32;}               			  else 			{dest[0]=~0; dest[1]=31;}               			  break;               case 'B' : dest[0]=2052; dest[1]=0; break;               case 'Z' : dest[0]=8200; dest[1]=0; break;               case '?' : if(keepGap)	               					{dest[0]=~0; dest[1]=63;               					}              			  else throw MTHException("Incorrect Protein Character");              			 break;               default  : throw MTHException("Incorrect Protein Character");               					}}char GetNameOfIthProteinState(int i){	switch(i )	{  case 0 : return 'A';               case  1 : return 'C' ;               case 2 : return 'D' ;               case 3 : return 'E' ;               case 4 : return 'F' ;               case 5 : return 'G' ;               case 6 : return 'H' ;               case 7 : return 'I' ;               case 8 : return 'K' ;               case 9 : return 'L' ;               case 10 : return 'M' ;               case 11 : return 'N' ;               case 12 : return 'P' ;               case 13 : return 'Q' ;               case 14 : return 'R' ;               case 15 : return 'S' ;               case 16 : return 'T' ;               case 17 : return 'V' ;               case 18 : return 'W' ;               case 19 : return 'Y' ;               case 20 : return '*' ;               case 21 : return '-' ;               default  : throw MTHException("Incorrect Protein Character"); 					}}nxsstring DecodeProteinCharAsStr(short *c,bool keepGap/*=false*/){	try {return DecodeProteinCharInOneChar(c,keepGap);		}	catch (MTHException){}//not just one character or a standard one character ambiguity code	short smask=1,temp[2];	temp[1]=0;	nxsstring retstr="(";	for(int i=0;i<16;i++)		{if(*c&smask)			{temp[0]=smask;			retstr+=(char) DecodeProteinCharInOneChar(temp,keepGap);			}		smask<<=1;		}	smask=1;	c++;	temp[0]=0;	for(int i=0;i<6;i++)		{if(*c&smask)			{temp[1]=smask;			retstr+=(char) DecodeProteinCharInOneChar(temp,keepGap);			}		smask<<=1;		}	retstr+=")";	return retstr;}int DecodeProteinCharInOneChar(short *c,bool keepGap/*=false*/){	short maxs=16384;	maxs<<=1;//maxs== 1000 0000 0000 0000	if(c[1]==0)		switch(*c)	{case 1 :	return 'A';             		case 2 :	return 'C'; 	            	case 4 :	return 'D';	               	case 8 :	return 'E' ;	               	case 16 :	return 'F' ;	               	case 32 :	return 'G' ;	               	case 64 :	return 'H' ;	               	case 128 :	return 'I' ;	               	case 256 :	return 'K' ;	               	case 512 :	return 'L' ;	               	case 1024 :	return 'M' ;	               	case 2048 :	return 'N' ;	               	case 4096 :	return 'P';	               	case 8192 :	return 'Q';	               	case 16384 :	return 'R' ;	               	default :	               				if(*c==maxs)		               					return 'S';	               			 	throw MTHException("Incorrect Protein Character");	               	}	if((*c)==0)        switch(c[1])          		{case 1 :	return 'T';               	case 2 :	return 'V';               	case 4 :	return 'W';                	case 8 :	return 'Y';               	case 16 :	return '*';               	case 32 : if(keepGap)	return '-';              			 //else is the fall through exception                default : throw MTHException("Incorrect Protein Character");                }                 if(c[0]==~0)   			{if(keepGap && c[1]==31)	return 'X';   			if(!keepGap && c[1]==63)	return '?';   			throw MTHException("Incorrect Protein Character");   			}   if(c[0]==2052 && c[1]==0) return 'B';   if(c[0]==8200 && c[1]==0) return 'Z';	throw MTHException("Incorrect Protein Character");}void EncodeCodon(short *dest,short *raw,bool keepGap)	{		//assumes that a codon code will take up 4 shorts;	assert(sizeof(short)==2);	assert(!keepGap);//if not codon will have to take up 5 shorts	if(*raw==16)	*raw=15;	if(raw[1]==16)	raw[1]=15;	if(raw[2]==16)	raw[2]=15;	short smask=~0; 		//bit pattern 1111 1111 1111 1111 First base of the codon in its own short	short sbase=1;	for(int i=0;i<4;i++)		{if(*raw&sbase)				*(dest+i)=smask;		else	*(dest+i)=0;		sbase<<=1;		}	smask=15;			 	//bit pattern 0000 000 0000 1111  Second base	sbase=1;	for(int i=0;i<4;i++)		{if(!(*(raw+1)&sbase))			{*dest&=(~smask);			*(dest+1)&=(~smask);			*(dest+2)&=(~smask);			*(dest+3)&=(~smask);			}		sbase<<=1;		smask<<=4;		}	smask=4369;			   //bit pattern 0001 0001 0001 0001 Third base	sbase=1;	for(int i=0;i<4;i++)		{if(!(*(raw+2)&sbase))			{*dest&=(~smask);			*(dest+1)&=(~smask);			*(dest+2)&=(~smask);			*(dest+3)&=(~smask);			}		sbase<<=1;		smask<<=1;		}}int DecodeACodonInOneInt(short *inp){	//aaa=1 aac=2 ... ttt=64 any ambiguity=65	if(inp[0]=inp[1]=inp[2]=inp[3]=~0)		return 65;//65 is the one int version of  'X'	bool first=true;	int codNum=1,retval=0;	short smask;	for(int i=0;i<4;i++)		{smask=1;		for(int j=0;j<16;j++)			{if(inp[i]&smask)				{if(!first)	return 65;//65 is the one int version of  'X'\				first=false;				retval=codNum;				}			codNum++;			}		}	return retval;}void CopyArray(short *dest,short *raw,int sizeofRaw)	{	for(int i=0;i<sizeofRaw;i++)			*dest++=*raw++;}nxsstring DecodeState(short *inp,int datatype){	if(datatype==EncodingType(AminoAcid))		return DecodeProteinCharAsStr(inp,true);	else	if(datatype==EncodingType(DNANoGap))	return DecodeDNACharAsStr(*inp,true);	throw	MTHException("Entered unwritten code DecodeState" );}bool IsGap(short *inp,int datatype){	try	{if(datatype==EncodingType(AminoAcid))		return ('-'==DecodeProteinCharInOneChar(inp,true));		else	if(datatype==EncodingType(DNANoGap))	return ('-'==DecodeDNACharInOneChar(*inp,true));		else 	if(datatype==EncodingType(MitoCodons))	return false;/*(DecodeACodonInOneInt(inp)==65 );*/ //TEMPORARY needs to change if treating gaps other than N's		}	catch(MTHException m)		{return false;}}void EncodeACharacter(short *dest,short inp,int datatype,bool keepGap/*=false*/){	if(datatype==EncodingType(AminoAcid))		EncodeProteinChar(dest,inp,keepGap);	else	if(datatype==EncodingType(DNANoGap))	*dest=EncodeDNAChar(inp,keepGap);	else throw	MTHException("Entered unwritten code EncodeACharacter" );}void EncodeACharacter(short *dest,short *inp,int datatype,bool keepGap/*=false*/){	if(datatype==EncodingType(MitoCodons))		EncodeCodon(dest,inp,keepGap);	else 	throw	MTHException("Entered unwritten code EncodeACharacter" );}char GetNameOfIthState(int i,int datatype, bool * isChar){	*isChar=true;	if(datatype==EncodingType(AminoAcid))		return GetNameOfIthProteinState(i);	else	if(datatype==EncodingType(DNANoGap))	return GetNameOfIthDNAState(i);	else 	if(datatype==EncodingType(MitoCodons))	{*isChar=false;	return i;}	else throw	MTHException("Entered unwritten code GetNameOfIthState" );}