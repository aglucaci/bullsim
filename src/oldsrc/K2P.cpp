#include "K2P.h"double K2P::defKappa(2);K2P::K2P()	: Model(4){	nparams=1;	nfreeparams=1;	nfreqParamGroups=0;		param=new Parameter *[nparams];	param[K2P::kappa]=new PositiveParameter(K2P::defKappa,par(MIN)|par(DEF),K2P::defKappa);	double f[4]={.25,.25,.25,.25};	stateFreqs=new FreqParamGroup(4,f,par(CUR)|par(FIX));	CalculateBeta();}K2P::K2P(double k)	: Model(4){	nparams=1;	nfreeparams=1;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[K2P::kappa]=new PositiveParameter(k,par(MIN)|par(CUR),K2P::defKappa);	double f[4]={.25,.25,.25,.25};	stateFreqs=new FreqParamGroup(4,f,par(CUR)|par(FIX));	CalculateBeta();}K2P::K2P(double k,double pinv)	: Model(4,pinv){	nparams=1;	nfreeparams=1;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[K2P::kappa]=new PositiveParameter(k,par(MIN)|par(CUR),K2P::defKappa);	double f[4]={.25,.25,.25,.25};	stateFreqs=new FreqParamGroup(4,f,par(CUR)|par(FIX));	CalculateBeta();}K2P::K2P(double k,int ncat,double gams)	: Model(4,ncat,gams){	nparams=1;	nfreeparams=1;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[K2P::kappa]=new PositiveParameter(k,par(MIN)|par(CUR),K2P::defKappa);	double f[4]={.25,.25,.25,.25};	stateFreqs=new FreqParamGroup(4,f,par(CUR)|par(FIX));	CalculateBeta();}K2P::K2P(double k,double pinv,int ncat,double gams)	: Model(4,pinv,ncat,gams){	nparams=1;	nfreeparams=1;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[K2P::kappa]=new PositiveParameter(k,par(MIN)|par(CUR),K2P::defKappa);	double f[4]={.25,.25,.25,.25};	stateFreqs=new FreqParamGroup(4,f,par(CUR)|par(FIX));	CalculateBeta();}K2P::~K2P(){	for(int i=0;i<nparams;i++)		delete param[i];	delete [] param;}void K2P::UpdatePMatrix(double **pmats,double blen){	double emut=exp(-blen*beta);	double emutti=exp(-blen*beta*(1.0+.5*(param[K2P::kappa]->val-1.0)));	double same=.25+.25*emut+(.5)*emutti;	double tv=(1.0-emut)/4.0;	double ti=.25+.25*emut-(.5)*emutti;	double *temp;	temp=*pmats;	*temp++=same;	//AA	*temp++=tv;										//AC	*temp++=ti;	//AG	*temp++=tv;										//AT		*temp++=tv;										//CA	*temp++=same;	//CC	*temp++=tv;										//CG	*temp++=ti;	//CT		*temp++=ti;	//GA	*temp++=tv;										//GC	*temp++=same;	//GG	*temp++=tv;										//GT		*temp++=tv;										//TA	*temp++=ti;	//TC	*temp++=tv;										//TG	*temp=same;		//TT}/*void K2P::UpdatePmatGamma(double blen){		double *temp;	temp=**pmats;	for(int i=0;i<ngamcat;i++)	{double emut=exp(-blen*beta**(rates+i));	double emutti=exp(-blen*beta**(rates+i)*(1.0+.5*(param[K2P::kappa]->val-1.0)));	double same=.25+.25*emut+(.5)*emutti;	double tv=(1.0-emut)/4.0;	double ti=.25+.25*emut-(.5)*emutti;	*temp++=same;	//AA	*temp++=tv;										//AC	*temp++=ti;	//AG	*temp++=tv;										//AT		*temp++=tv;										//CA	*temp++=same;	//CC	*temp++=tv;										//CG	*temp++=ti;	//CT		*temp++=ti;	//GA	*temp++=tv;										//GC	*temp++=same;	//GG	*temp++=tv;										//GT		*temp++=tv;										//TA	*temp++=ti;	//TC	*temp++=tv;										//TG	*temp++=same;		//TT	}}*/	void K2P::CalculateBeta()//Should be called whenever kappa or the base freqs are changed//Beta is a factor that is multiplied to the branchlength to make the eqns in //Molecular Systematics work.  This the constraint that Sum qii * freq(i) = -1 this ensures that the branches are in length//that are expected numbers of changes  //For GTR the rate params are scaled down to maintain their same ratio, but make beta=1.0{	beta=4.0/(2.0 + param[K2P::kappa]->val);}void K2P::InitializeParameters(){	RateManager::InitializeParameters();	for(int i=0;i<nparams;i++)		{if(param[i]->StartWithCurrent()) ;		else	if(param[i]->StartWithRandom())				throw IncompleteModel("Random Function to initialize parameters isn't available yet");				//param[i]->val=SomeRandomNumberFunction();		else	if(param[i]->StartWithApproximation())					throw IncompleteModel("Initial approximation of parameters isn't available yet");		else	if(param[i]->StartWithDefault())					param[i]->SetToDefault();		else	throw BadSettings("No starting value of a parameter has been defined");		}}