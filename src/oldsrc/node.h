#ifndef _NODE_#define _NODE_#include "encodedchars.h"#include "nxsstring.h"#include "likeattributes.h"#include "parsattributes.h"#include "displayLines.h"#include "AdvancedBullDefs.h"#include "basicfuncs.h"#ifdef CODONHACK#define BLOSPSEUDTERM 4#define BLOSFINISHED 1#define BLOSBELOWSUBTREE 2class NoFreeWorkArrayException {};class RequestedWorkArrayNotFoundException {};class Node;struct LikeWorkArray{enum {BelowTop,AboveTop,AboveBott,BelowBott};Node *owner;double *condLikes;int description;int priority;LikeWorkArray(int n)		{priority=0;	condLikes=new double[n]; 	owner=NULL;}~LikeWorkArray()	{	delete [] condLikes;}};LikeWorkArray *GetFreeWorkArray(LikeWorkArray **storage,int sizeofStorage);void MakeFirstArrayProduct(double *p,double *f,double *s,int lenOfArray);void SetFirstArrayEqualToSec(double *f,double *s,int lenOfArray);			#endifclass Node{	friend class Tree;	//friend class Bull;	protected :	EncodedChars *characters;	nxsstring name;	double *blen;	SetOfLikeAttr *setOfLikeInfo;	SetOfParsAttr *setOfParsInfo;	Node *ldes;	Node *rdes;	Node *next;	Node *anc;		public:	LikeAttr *likeInfo;	ParsAttr *parsInfo;		Node();	~Node();	Node *CopyToShare();	Node *Copy();	bool IsTerm()	{return !ldes;}	Node *GetAnc();	int GetNchar();	void WriteTermTax(vector<Node *> *);	void WriteIfTerm(vector<Node *> *);	Node *GetRoot();	int GetNtax();	int GetNtax(int);	Node *MakeDes();	void SetBranchLengthFromFile(double);//used in reading the branches from a file (they are stored in the node's blen temporarily as opposed to a like attr	void SetName(nxsstring);	nxsstring GetName();	void SetChars(EncodedChars *ec);	void DetachData() {characters=0L;}	void SetAllIllegalBranches(double len);	bool NoIllegalBranchLengths();	void CalcVariableCondLikelihoodTopDown();	void CondLikeArrayMultPrChanges(double *cl);	double GetLogLikelihood();	Node **FillRecursiveNodeList(Node **);	Node **FillRecursiveInternalNodeList(Node **rnl);	void ReplaceSetOfLikeInfo(SetOfLikeAttr *LI)	{delete setOfLikeInfo; setOfLikeInfo=LI;}	void ReplaceSetOfParsInfo(SetOfParsAttr *ParsI)	{delete setOfParsInfo; setOfParsInfo=ParsI;}	void ReplaceSetOfLikeInfoButKeepBranchLen(SetOfLikeAttr *LI);	void SetLikeAtt(int part,int mod)	{ 		likeInfo=setOfLikeInfo->GetLikeAtt(part,mod); 		//TEMP		blen=likeInfo->GetBLenPtr();		}	LikeAttr *GetLikeAtt()	{ return likeInfo; }	LikeAttr *GetLikeAtt(int part,int mod)	{ return setOfLikeInfo->GetLikeAtt(part,mod); }	void SetParsAtt(int part)	{ parsInfo=setOfParsInfo->GetParsAtt(part);  }	ParsAttr *GetParsAtt()	{ return parsInfo; }	ParsAttr *GetParsAtt(int part)	{ return setOfParsInfo->GetParsAtt(part); }	void CreateSetOfLikeAttrWithInputBrLensRecurs();	bool IsGood(void);	Node *GetNextNodeToOptBranchOn();	void Print(ostream &usrstream,bool withBrLen,int level=0,bool tabbing=false);	int NameSelfAndInternalDescendants(int n);	void ShowNode(int windowWidth,vector<int> prevVert);	int GetNumDes(int n,bool termOnly);	void AddLinesToBeDisplayed(int windoWidth,int midrow,int fircol,int firrow,vector<horizLine> *hlines,vector<vertLine> *vlines);	int MaxNumInternalNodesToTip();	bool MustBeAChangeOnBranchUppass(int);	int GetDepthTimesNSib();	void DirectToNewAnc(Node* newAnc);	void SwapBranchLengths(Node *sourc);	void AddBranchLengths(Node *sourc);	int GetNumBranchesAbove();	int GetHeightAbove(int height);#ifdef CODONHACK	/*int brLenOptSetting;	int numTermBranchesAbove,numBranchesAbove,numTempArraysNeeded;		void SetSubCladeBrLenOptField(int setting);	int FillNumBranchesAbove();	int FillNumTermBranchesAbove();	void FillNumArraysNeededToOptBranches(int x);	Node *GetRootOfNextSubCladeToOptimize(int maxN,int &bestYet,Node *bestNo);*/	void OptimizeDescendantsBranches(LikeWorkArray **workArrays,int *nStatesInThisSite,Model **modArrays,LikeWorkArray *below,int totSizeOfArrays,		double maxPasses,double delta,int &NumBranchesAlreadyOptimized,int numArrays,int numSitesInProtein);			LikeWorkArray *lwa,*belowlwa;	void ResetLWAs();	LikeWorkArray *GetCondLikeAboveBottom(LikeWorkArray **workArrays,int numArrays,bool mustBeFilled=true);	void FreeCondLikeAboveBottom();	static int currPrioritySetting;	static int NumBranchesOptimized;	static int branchLengthOptLogNum;	static double TreesCurrentLikelihood;#endif	void CalculateCondLikeAboveBottomAndStore(double *destCL,int placeInCondLike,LikeWorkArray **workArrays,int numArrays,bool appendToFile=true);	int UpdateBranchesInRecursiveOrder(double *optBranchLengths, int nBranchesToUpdate);	};	#ifdef CODONHACK		double BranchLengthLinearBrent(double *branchLength,double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,double maxPasses,double delta,int numSitesInProtein);		double ScoreBranchLength(double origBranch,double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein);		double ScoreZeroBranchLength(double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein);		void MakeBelowTopFromBelowBottom(double bLen,double *top,double *bottom,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein);		void GetBranchLengthBracket(int numPtsToTrust,double *a,double *b, double *c, double *ascore, double *bscore,double *cscore,double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein);	 	void GetMiddleBranchLength(double *a,double *b, double *c, double *ascore, double *bscore,double *cscore,double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein);	 	void WriteBrLenLike(double *below,double *above,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein,int nOfBranch);	#endif#endif