#ifndef PARSATTRIBUTES#define PARSATTRIBUTES#define BITSPERSHORT 16#include "basicbulldefs.h"#include "basicfuncs.h"#include "matrices.h"#include "encodedchars.h"#include "charencoding.h"#include <map>#include "nxsstring.h"#include "MTHException.h"#include "parameter.h"#include "tools.h"/* Pars attributes are owned by a node and store the information to calculate likelihoods	for that node.  all pointer variable are pointers to pointers to allow for multiple model/partitoins	*/struct VirtualParsAttExcep: public MTHException{public: VirtualParsAttExcep(const char *p) : MTHException(p) {}};class   ParsAttr	{	protected:	//int memoryMode;	public :		static int currNChar,currNStates,currShortPerChar,currNStatesInLastShort;#ifdef CHARBYCHAR	static int currCharIndex;#endif	static bool currModelDirty;			/*	//Virtuals that should be called by InternalNodeParsAttr Only	virtual double *GetCondParsArray() 		{throw VirtualParsAttExcep("Calling virtual GetCondParsArray"); return NULL;} //Should be called by InternalNodeParsAttr only	virtual void SetThisCondParsBasedOnAncArg(double *) {throw VirtualParsAttExcep("Calling virtual SetThisCondParsToParsBelowBasedOnArg(double *)");} //Should be called by one of the InternalParsAttr	virtual void SetThisCondParsToParsBelowBasedOnArg(double **){throw VirtualParsAttExcep("Calling virtual SetThisCondParsToParsBelowBasedOnArg(double **)");} //Should be called by one of the InternalParsAttr	//Virtuals that should be called by TerminalNodeParsAttr Only	virtual void FillDoubleArrayWithCondParsOfChars(double *cl) {throw VirtualParsAttExcep("Calling virtual FillDoubleArrayWithCondParsOfChars");}		//Virtuals that should be called by a NodeParsAttrs Only	virtual void SetArgToCondParsOfThisSubTree(double *) {throw VirtualParsAttExcep("Calling virtual SetArgToCondParsOfThisSubTree");} //Should be called by one of the NodeParsAttr	virtual void MultArgByCondParsOfThisSubTree(double *) {throw VirtualParsAttExcep("Calling virtual MultArgByCondParsOfThisSubTree");} //Should be called by one of the NodeParsAttr	*/	virtual short *GetDownPass(int ch=0) {throw VirtualParsAttExcep("Calling virtual GetDownPass");}//should be over ridden by both types of ParsAttr	virtual short *GetUpPass(int ch=0) {throw VirtualParsAttExcep("Calling virtual GetUpPass");}//should be over ridden by both types of ParsAttr	virtual short *GetFinalPass(int ch=0) {throw VirtualParsAttExcep("Calling virtual GetFinalPass");}//should be over ridden by both types of ParsAttr};class InternalNodeParsAttr : public ParsAttr {	long sizeofArray;		public:		short *downPass,*finalPass,*upPass;		InternalNodeParsAttr(int n,int encodTy);//Constructor for internal node's attributes	void Reset();	~InternalNodeParsAttr();	short *GetDownPass(int ch=0);	short *GetUpPass(int ch=0);	short *GetFinalPass(int ch=0);	};class TerminalNodeParsAttr : public ParsAttr {	long sizeofArray;	int encodingType;	public:		short *CharsInShorts,*finalPass,*upPass;		TerminalNodeParsAttr(short *,int,int);//Constructor for internal node's attributes	~TerminalNodeParsAttr();	short *GetDownPass(int ch=0);	short *GetUpPass(int ch=0);	short *GetFinalPass(int ch=0);	};class TreeParsAttr 	{	public:	int encodingType;	int currentLength;	int *isConstant;	bool ownsBrLens,needsToBeRescored;	int nChar,nStates,nColPerChar;	short *nTimesThisPatternOccurs;/*these are owned at the Tree level because they are probably shared by all on the nodes in a tree (the use is most likely different rates for different characters, the exception to this isin a relaxed clock version in which there could be several bLenModifiers.Note that bLenModifiers may be shared by more than one Partition/Model so there is a vector of ownership flagsthis prevents double deleting, BUT DOES NOT assure that all other partition/models that use this TreeParsAtt's bLenModifiersare notified that the modifiers are being deleted.*/	TreeParsAttr(int n,int *isConst,short *nReps,int encodTy);			int GetNChar() {return nChar;}	int GetNStates() {return nStates;}	int GetNShortsPerChar() {return NumShortsPerCharacter(encodingType);}	int GetNStatesInLastShort() {return NumStatesInLastShort(encodingType);}	bool GetOwnsBrLen() {return ownsBrLens;} //Should be called by TreeParsAttr	int *GetIsConstant()	{return isConstant;}	short *GetNReps()	{return nTimesThisPatternOccurs;}};class SetOfParsAttr 	{	protected:	int nparts;//number of partiotions+models, and number of partitions	ParsAttr** parsAttribs;		public:		SetOfParsAttr(int i);		~SetOfParsAttr();		void AddParsAtt(int p,ParsAttr *);	int GetNParts()	{return nparts;}	ParsAttr *GetParsAtt(int p)	{return parsAttribs[p];}		};class SetOfTreeParsAttr  	{	friend class Tree;	int nparts;//number of partiotions+models, and number of partitions	TreeParsAttr** parsAttribs;		int *nChar,*nStates,*nRateCats,*packingType,*packingIndex;		public:		SetOfTreeParsAttr(int i);	~SetOfTreeParsAttr();		void AddParsAtt(int p,TreeParsAttr *);	int GetNParts()	{return nparts;}	TreeParsAttr *GetParsAtt(int p)	{return parsAttribs[p];}	void InitializeParsAttrStatics(int partnum);	int GetNChar(int p) {return parsAttribs[p]->GetNChar();}	int GetNStates(int p) {return parsAttribs[p]->GetNStates();}	int GetNShortsPerChar(int p) {return parsAttribs[p]->GetNShortsPerChar();}	int GetNStatesInLastShort(int p) {return parsAttribs[p]->GetNStatesInLastShort();}	};#endif