#include "settings.h"#include <algorithm>ModSettings::ModSettings(Model *m){	useCurrentBrLen=true;	stationaryModel=true;	startingBrLen=DEFAULTSTARTINGBRLEN;		mod=m;	blenModSetting=blenSetting=par(DEF)|par(MIN);	hasBrLenMod=false;	numBrLenMod=0;}void ModSettings::SetUseCurrentBrLen(bool i){	useCurrentBrLen=i;}Model *ModSettings::GetModel(){	return mod;}bool ModSettings::StationaryModel(){	return stationaryModel;}	PartSettings::PartSettings(int s,int e){	AligningSeqs=false;	assert(s<=e);	segmentsInPartition.push_back(make_pair(s,e));	}int PartSettings::GetRawDataSize(){	int s=0;	pair<int,int> seg;	for(int i=0;i<segmentsInPartition.size();i++)		{seg=segmentsInPartition[i];		s+=seg.second-seg.first; 		}	return s;}int PartSettings::GetNSegments(){	return segmentsInPartition.size();}pair<int,int> PartSettings::GetSegment(int i){	return segmentsInPartition[i];}bool PartSettings::DoingAlignment()	{	return AligningSeqs;}#ifdef DEBUGGINGLikePartSettings::LikePartSettings(PartSettings* ps)//in debugging version I add JC, because I haven't written the LSet command handler yet{	sharedPartSettings=ps;	nmodels=1;	ModelMixingStartingVals=NULL;	ModelMixingSetting=par(CUR);	//Model * mod = new GTR(0.276390,0.288800,0.165845,2,3,4,5,6,0.237696,4,0.335219);	//Model * mod = new GTR(0.276390,0.288800,0.165845,2,3,4,5,6,0.237696);	//Model * mod = new GTR(0.212329 , 0.273019 , 0.275763 , 1.69887 , 2.3204 , 1.3685 , 1.43009,  2.71438 , 4 , 2.2793);	//Model * mod = new GTR(0.25 , 0.25 , 0.25 , 1 , 2 , 1 , 1,  2, .1 , 4 , .5);	//Model * mod = new GTR(0.20819345 , 0.27625946 , 0.28402847 , 1.6867985 , 2.3122962 , 1.43943 , 1.3327206,  2.7877558 , 0.036223237 , 4 , 2.7049082);	//Model * mod = new HKY(26.2,.122,.430363,.057495);	Model * mod=new HKY(2.0,.25,.25,.25,4,.5);	/*double gtrP[8],**aminoAcids;	aminoAcids=new double *[380];	for(int i=0;i<380;i++)		aminoAcids[i]=new double[21];	CreateSetOfSSRFCodons(380,gtrP,aminoAcids);*/	modSettings.push_back(new ModSettings(mod));}#elseLikePartSettings::LikePartSettings(PartSettings* ps){	sharedPartSettings=ps;	nmodels=0;	ModelMixingStartingVals=NULL;	ModelMixingSetting=par(CUR);}#endifLikePartSettings::~LikePartSettings(){	for(vector<ModSettings*>::iterator msit=modSettings.begin();msit!=modSettings.end();msit++)		delete (*msit);//doesn't destroy model	delete ModelMixingStartingVals;}void LikePartSettings::SetUseCurrentBrLen(bool i){	for(int j=0;j<nmodels;j++)		modSettings[j]->SetUseCurrentBrLen(i);}int LikePartSettings::GetNModels(){	return nmodels;}Model *LikePartSettings::GetModel(int i){	return modSettings[i]->GetModel();}void LikePartSettings::SetModel(Model *m,int n){	return modSettings[n]->SetModel(m);}bool LikePartSettings::AllStationaryModels(){	for(int i=0;i<nmodels;i++)			if(!(modSettings[i]->StationaryModel()))			return false;	return true;}	double LikePartSettings::GetStartingFreqnOfThisModel(int j) {	if(nmodels<2)	return 1.0;	assert(j<nmodels);	if(ModelMixingStartingVals)		return ModelMixingStartingVals->GetParameter(j)->val;	return (1.0/nmodels);}ParsPartSettings::ParsPartSettings(PartSettings *ps,int ec,bool ucbr,bool ord)	{	sharedPartSettings=ps; 	useCurrentBrLen=ucbr; 	ordered=ord;	encodingType=ec;}	DataSettings::DataSettings(int f,int l){	packingData=true;#ifdef	CYTBMODEL	packingData=false;#endif#ifdef DZRATES	packingData=false;#endif	nDataPartitions=1;#ifdef DEBUGGING	userInputBrLen=true;#else	userInputBrLen=false;#endif		dataPartSettings.push_back(new PartSettings(f,l));}int DataSettings::GetNDataPartitions(){	return nDataPartitions;}int DataSettings::SeparateIntoCharPartititonsOfLengthN(int ninpart){	int oldndatparts=nDataPartitions;	nDataPartitions=0;	vector<PartSettings *> olddataPartSettings;	for(int i=0;i<oldndatparts;i++)		olddataPartSettings.push_back(dataPartSettings[i]);	dataPartSettings.erase(dataPartSettings.begin(),dataPartSettings.end());	for(vector<PartSettings *>::iterator odps=olddataPartSettings.begin();odps!=olddataPartSettings.end();odps++)		{int ns=(*odps)->GetNSegments();		for(int nseg=0;nseg<ns;nseg++)			{int begseg,endseg;			begseg=((*odps)->GetSegment(nseg)).first;			endseg=((*odps)->GetSegment(nseg)).second;			if((endseg-begseg)%ninpart!=0)	throw MTHException("Can't split data into requested Partitions");			for(int i=begseg;i+ninpart-1<=endseg;i+=ninpart)				{nDataPartitions++;				PartSettings *tps=new PartSettings(i,i+ninpart);				tps->AligningSeqs=(*odps)->AligningSeqs;				dataPartSettings.push_back(tps);				}			}		}	for(vector<PartSettings *>::iterator odps=olddataPartSettings.begin();odps!=olddataPartSettings.end();odps++)		delete (*odps);	olddataPartSettings.erase(olddataPartSettings.begin(),olddataPartSettings.end());	return nDataPartitions;			}int DataSettings::GetRawDataSize(int partnum){	return dataPartSettings[partnum]->GetRawDataSize();}void DataSettings::CopyAndEncodeAPartitionsRawData(short *destination,map<nxsstring,EncodedChars *>&rawData,int partnum,int taxnum,int shortsPerChar,int rawColPerChar,int dtype,bool keepGap/*=false*/){	short *rd;	rd=rawData[IncludedTaxa[taxnum]]->GetDataPtr();	pair<int,int> seg;	if(rawColPerChar==1 && keepGap)		for(int i=0;i<dataPartSettings[partnum]->GetNSegments();i++)			{seg=dataPartSettings[partnum]->GetSegment(i);			short *temp;			temp=rd+seg.first;			for(int j=seg.first;j<seg.second;j++)				for(int k=0;k<shortsPerChar;k++)					*destination++=*temp++;			}	else 			for(int i=0;i<dataPartSettings[partnum]->GetNSegments();i++)			{seg=dataPartSettings[partnum]->GetSegment(i);			short *temp;			temp=rd+seg.first;			for(int j=seg.first;j<seg.second;j+=rawColPerChar)				{EncodeACharacter(destination,temp,dtype,keepGap);				temp+=rawColPerChar;				destination+=shortsPerChar;				}							}}	void DataSettings::CopyAndEncodeAPartitionsRawData(Model *mod,short *destination,map<nxsstring,EncodedChars *>&rawData,int partnum,int taxnum,int shortsPerChar,int rawColPerChar,int dtype,bool keepGap/*=false*/){	//should only be used by SSRFCodonSubMod because of it's odd coding of characters	short *rd;	rd=rawData[IncludedTaxa[taxnum]]->GetDataPtr();	pair<int,int> seg;	assert(rawColPerChar==3);	for(int i=0;i<dataPartSettings[partnum]->GetNSegments();i++)		{seg=dataPartSettings[partnum]->GetSegment(i);		short *temp;		temp=rd+seg.first;		for(int j=seg.first;j<seg.second;j+=rawColPerChar)			{mod->EncodeACharacter(destination,temp,dtype,keepGap);			temp+=rawColPerChar;			destination+=shortsPerChar;			}					}}	bool DataSettings::MaintainCharacterInputOrder(){		if(!packingData)	return true;	return DoingAlignment();}bool DataSettings::DoingAlignment()	{	bool a=false;	for(int i=0;i<nDataPartitions;i++)		a|=dataPartSettings[i]->DoingAlignment();	return a;}bool DataSettings::DoingAlignment(int i)	{	return dataPartSettings[i]->DoingAlignment();}struct CharNotInPartitions{};int DataSettings::FindPartition(int rawNum)	//CHECK{	pair<int,int> seg;	for(int i=0;i<nDataPartitions;i++)		for(int j=0;j<dataPartSettings[i]->GetNSegments();j++)			{seg=dataPartSettings[i]->GetSegment(j);			if(rawNum>=seg.first && rawNum<=seg.second)				return i;			}	throw CharNotInPartitions();	return -1;}	int DataSettings::FindCharNumInPartition(int partNum,int rawNum)	//CHECK{	int ninpart=0;	pair<int,int> seg;	for(int j=0;j<dataPartSettings[partNum]->GetNSegments();j++)		{seg=dataPartSettings[partNum]->GetSegment(j);		if(rawNum>=seg.first && rawNum<=seg.second)			{ninpart+=rawNum-seg.first;			return ninpart;			}		else ninpart+=seg.second-seg.first;		}	throw CharNotInPartitions();	return -1;}//TEMPORARY LikeSettings::LikeSettings(DataSettings *ds){	sharedDataSettings=ds;	optimizingBrLens=true;	maximize=true;	maxPasses= DEFAULTMAXPASSES;	delta = DEFAULTDELTA;	useRSBranchLengths=false;	sumOverAncStates=true;	summingOverAllAncStates=true;	partSettings.push_back(new LikePartSettings(ds->dataPartSettings[0]));}void LikeSettings::RefreshPartitions(){	assert(sharedDataSettings);	for(vector<LikePartSettings *>::iterator lps=partSettings.begin();lps!=partSettings.end();lps++)		delete (*lps);	partSettings.erase(partSettings.begin(),partSettings.end());	for(int i=0;i<sharedDataSettings->nDataPartitions;i++)		partSettings.push_back(new LikePartSettings(sharedDataSettings->dataPartSettings[i]));}void LikeSettings::ReplaceModels(int n,Model **mods){	assert(n==partSettings.size());	for(vector<Model *>::iterator lps=allModels.begin();lps!=allModels.end();lps++)		delete (*lps);	allModels.erase(allModels.begin(),allModels.end());	for(int i=0;i<n;i++)		{allModels.push_back(mods[i]);		partSettings[i]->SetModel(mods[i],0);		}}void LikeSettings::SetUseCurrentBrLen(bool i){	for(int j=0;j<sharedDataSettings->nDataPartitions;j++)		partSettings[j]->SetUseCurrentBrLen(i);}int LikeSettings::GetNModelsInPart(int i){	return (partSettings[i]->GetNModels());}Model *LikeSettings::GetModel(int i,int j){	return (partSettings[i]->GetModel(j));}bool LikeSettings::SummingOverAllAncStates(){	return summingOverAllAncStates;}bool LikeSettings::AllStationaryModels(){	for(int i=0;i<sharedDataSettings->nDataPartitions;i++)			if(!(partSettings[i]->AllStationaryModels()))			return false;	return true;}	int LikeSettings::GetNSetsOfBranchLengths(){	map<PartModIndex,int> brlens;	for(int i=0;i<sharedDataSettings->nDataPartitions;i++)		for(int j=0; j<partSettings[i]->GetNModels();j++)			if(brlens.find(partSettings[i]->GetBrLenOwner(j))==brlens.end())				brlens[partSettings[i]->GetBrLenOwner(j)]=1;	return brlens.size();}int LikeSettings::GetNSetsOfBranchLengthModifiers(){	map<PartModIndex,int> brlens;	for(int i=0;i<sharedDataSettings->nDataPartitions;i++)		for(int j=0; j<partSettings[i]->GetNModels();j++)			if(partSettings[i]->HasBrLenMod(j))				if(brlens.find(partSettings[i]->GetBrLenModOwner(j))==brlens.end())					brlens[partSettings[i]->GetBrLenModOwner(j)]=1;	return brlens.size();}PartModIndex LikeSettings::GetOwnerOfNthSetOfBrLengths(int ownint){	//extremely ugly and slow, but should be called very often	map<PartModIndex,int> brlens;	for(int i=0;i<sharedDataSettings->nDataPartitions;i++)		for(int j=0;j<partSettings[i]->GetNModels();j++)			if(brlens.find(partSettings[i]->GetBrLenOwner(j))==brlens.end())				{brlens[partSettings[i]->GetBrLenOwner(j)]=1;				if(brlens.size()==1+ownint)					return partSettings[i]->GetBrLenOwner(j);				}	throw 	LikeSettingException("Requesting too many sets of branch lengths ");}PartModIndex LikeSettings::GetOwnerOfNthSetOfBrLengthModifiers(int ownint){	//extremely ugly and slow, but should be called very often	map<PartModIndex,int> brlens;	for(int i=0;i<sharedDataSettings->nDataPartitions;i++)		for(int j=0;j<partSettings[i]->GetNModels();j++)			if(partSettings[i]->HasBrLenMod(j))				if(brlens.find(partSettings[i]->GetBrLenModOwner(j))==brlens.end())					{brlens[partSettings[i]->GetBrLenModOwner(j)]=1;					if(brlens.size()==1+ownint)						return partSettings[i]->GetBrLenModOwner(j);					}	throw 	LikeSettingException("Requesting too many sets of branch lengths ");}PartModIndex LikeSettings::GetOwnerOfBrLens(int p,int  m){	return partSettings[p]->GetBrLenOwner(m);}PartModIndex LikeSettings::GetOwnerOfBrLenModifiers(int p,int  m){	assert(partSettings[p]->HasBrLenMod(m));	return partSettings[p]->GetBrLenModOwner(m);}ParsSettings::ParsSettings(DataSettings *ds,int dataType){		sharedDataSettings=ds;	vector<PartSettings *>::iterator posIt=ds->dataPartSettings.begin();	for(;posIt!=ds->dataPartSettings.end();posIt++)		partSettings.push_back(new ParsPartSettings(*posIt,dataType));}void ParsSettings::SetUseCurrentBrLen(bool i){	for(int j=0;j<sharedDataSettings->nDataPartitions;j++)		partSettings[j]->SetUseCurrentBrLen(i);}ParsSettings::~ParsSettings(){	vector<ParsPartSettings *>::iterator vIt=partSettings.begin();	for(;vIt!=partSettings.end();vIt++)		delete (*vIt);}void ParsSettings::RefreshPartitions(){	assert(sharedDataSettings);	int ec;bool ucbr, ord;	ucbr=(*partSettings.begin())->useCurrentBrLen;	ord=(*partSettings.begin())->ordered;	ec=(*partSettings.begin())->encodingType;		for(vector<ParsPartSettings *>::iterator lps=partSettings.begin();lps!=partSettings.end();lps++)		delete (*lps);	partSettings.erase(partSettings.begin(),partSettings.end());	for(int i=0;i<sharedDataSettings->nDataPartitions;i++)		partSettings.push_back(new ParsPartSettings(sharedDataSettings->dataPartSettings[i],ec,ucbr,ord));}