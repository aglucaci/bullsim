#include "HKY.h"double HKY::defKappa(2);double HKY::defFreqA(.25);double HKY::defFreqC(.25);double HKY::defFreqG(.25);HKY::HKY()	: Model(4){	nparams=5;	nfreeparams=4;	nfreqParamGroups=1;		param=new Parameter *[nparams];	param[HKY::kappa]=new PositiveParameter(HKY::defKappa,par(MIN)|par(DEF),HKY::defKappa);	param[HKY::freqA]=new FullParameter(HKY::defFreqA,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(DEF),HKY::defFreqA,"freqA");	param[HKY::freqC]=new FullParameter(HKY::defFreqC,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(DEF),HKY::defFreqC,"freqC");	param[HKY::freqG]=new FullParameter(HKY::defFreqG,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(DEF),HKY::defFreqG,"freqG");	param[HKY::freqT]=new FullParameter(1.0-HKY::defFreqA-HKY::defFreqC-HKY::defFreqG,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(DEF),1.0-HKY::defFreqA-HKY::defFreqC-HKY::defFreqG,"freqT");	stateFreqs=new FreqParamGroup(4,(param+HKY::freqA));	CalculatePiSums();	CalculateBeta();}void HKY::CalculatePiSums(){piCT=param[HKY::freqC]->val+param[HKY::freqT]->val;piAG=param[HKY::freqA]->val+param[HKY::freqG]->val;}	HKY::HKY(double k,double a,double c, double g)	: Model(4){	nparams=5;	nfreeparams=4;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[HKY::kappa]=new PositiveParameter(k,par(MIN)|par(CUR),HKY::defKappa);	param[HKY::freqA]=new FullParameter(a,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqA,"freqA");	param[HKY::freqC]=new FullParameter(c,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqC,"freqC");	param[HKY::freqG]=new FullParameter(g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqG,"freqG");	param[HKY::freqT]=new FullParameter(1.0-a-c-g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-HKY::defFreqA-HKY::defFreqC-HKY::defFreqG,"freqT");	CalculatePiSums();	stateFreqs=new FreqParamGroup(4,(param+HKY::freqA));	CalculateBeta();}HKY::HKY(double k,double a,double c, double g, double pinv)	: Model(4, pinv){	nparams=5;	nfreeparams=4;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[HKY::kappa]=new PositiveParameter(k,par(MIN)|par(CUR),HKY::defKappa);	param[HKY::freqA]=new FullParameter(a,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqA,"freqA");	param[HKY::freqC]=new FullParameter(c,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqC,"freqC");	param[HKY::freqG]=new FullParameter(g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqG,"freqG");	param[HKY::freqT]=new FullParameter(1.0-a-c-g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-HKY::defFreqA-HKY::defFreqC-HKY::defFreqG,"freqT");	CalculatePiSums();	stateFreqs=new FreqParamGroup(4,(param+HKY::freqA));	CalculateBeta();}HKY::HKY(double k,double a,double c, double g,int ncats,double gammaAlpha)	: Model(4,ncats,gammaAlpha){	nparams=5;	nfreeparams=4;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[HKY::kappa]=new PositiveParameter(k,par(MIN)|par(CUR),HKY::defKappa);	param[HKY::freqA]=new FullParameter(a,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqA,"freqA");	param[HKY::freqC]=new FullParameter(c,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqC,"freqC");	param[HKY::freqG]=new FullParameter(g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqG,"freqG");	param[HKY::freqT]=new FullParameter(1.0-a-c-g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-HKY::defFreqA-HKY::defFreqC-HKY::defFreqG,"freqT");	CalculatePiSums();	stateFreqs=new FreqParamGroup(4,(param+HKY::freqA));	CalculateBeta();}HKY::HKY(double k,double a,double c, double g, double pinv,int ncats,double gammaAlpha)	: Model(4,pinv,ncats,gammaAlpha){	nparams=5;	nfreeparams=4;	nfreqParamGroups=1;	param=new Parameter *[nparams];	param[HKY::kappa]=new PositiveParameter(k,par(MIN)|par(CUR),HKY::defKappa);	param[HKY::freqA]=new FullParameter(a,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqA,"freqA");	param[HKY::freqC]=new FullParameter(c,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqC,"freqC");	param[HKY::freqG]=new FullParameter(g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),HKY::defFreqG,"freqG");	param[HKY::freqT]=new FullParameter(1.0-a-c-g,SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-HKY::defFreqA-HKY::defFreqC-HKY::defFreqG,"freqT");	CalculatePiSums();	stateFreqs=new FreqParamGroup(4,(param+HKY::freqA));	CalculateBeta();}HKY::~HKY(){	for(int i=0;i<nparams;i++)		delete param[i];	delete [] param;}void HKY::UpdatePMatrix(double **pmats,double blen){	//CalculatePiSums();	//CalculateBeta();	double emut=exp(-blen*beta);	double oneminemut=1.0-emut;	double coemutAG=(-1.0+(1.0/piAG))*emut;	double coemutCT=(-1.0+(1.0/piCT))*emut;	double emutAG=exp(-blen*beta*(1.0+piAG*(param[HKY::kappa]->val-1.0)));	double emutCT=exp(-blen*beta*(1.0+piCT*(param[HKY::kappa]->val-1.0)));		double *temp;	temp=*pmats;	*temp++=param[HKY::freqA]->val+param[HKY::freqA]->val*coemutAG+(param[HKY::freqG]->val/piAG)*emutAG;	//AA	*temp++=param[HKY::freqC]->val*oneminemut;										//AC	*temp++=param[HKY::freqG]->val+param[HKY::freqG]->val*coemutAG-(param[HKY::freqG]->val/piAG)*emutAG;	//AG	*temp++=param[HKY::freqT]->val*oneminemut;										//AT		*temp++=param[HKY::freqA]->val*oneminemut;										//CA	*temp++=param[HKY::freqC]->val+param[HKY::freqC]->val*coemutCT+(param[HKY::freqT]->val/piCT)*emutCT;	//CC	*temp++=param[HKY::freqG]->val*oneminemut;										//CG	*temp++=param[HKY::freqT]->val+param[HKY::freqT]->val*coemutCT-(param[HKY::freqT]->val/piCT)*emutCT;	//CT		*temp++=param[HKY::freqA]->val+param[HKY::freqA]->val*coemutAG-(param[HKY::freqA]->val/piAG)*emutAG;	//GA	*temp++=param[HKY::freqC]->val*oneminemut;										//GC	*temp++=param[HKY::freqG]->val+param[HKY::freqG]->val*coemutAG+(param[HKY::freqA]->val/piAG)*emutAG;	//GG	*temp++=param[HKY::freqT]->val*oneminemut;										//GT		*temp++=param[HKY::freqA]->val*oneminemut;										//TA	*temp++=param[HKY::freqC]->val+param[HKY::freqC]->val*coemutCT-(param[HKY::freqC]->val/piCT)*emutCT;	//TC	*temp++=param[HKY::freqG]->val*oneminemut;										//TG	*temp=param[HKY::freqT]->val+param[HKY::freqT]->val*coemutCT+(param[HKY::freqC]->val/piCT)*emutCT;		//TT}/*void HKY::UpdatePmatGamma(double blen){		double *temp;	temp=**pmats;	for(int i=0;i<ngamcat;i++)	{double emut=exp(-blen*beta**(rates+i));	double oneminemut=1.0-emut;	double coemutAG=(-1.0+(1.0/piAG))*emut;	double coemutCT=(-1.0+(1.0/piCT))*emut;	double emutAG=exp(-blen*beta**(rates+i)*(1.0+piAG*(param[HKY::kappa]->val-1.0)));	double emutCT=exp(-blen*beta**(rates+i)*(1.0+piCT*(param[HKY::kappa]->val-1.0)));		*temp++=param[HKY::freqA]->val+param[HKY::freqA]->val*coemutAG+(param[HKY::freqG]->val/piAG)*emutAG;	//AA	*temp++=param[HKY::freqC]->val*oneminemut;										//AC	*temp++=param[HKY::freqG]->val+param[HKY::freqG]->val*coemutAG-(param[HKY::freqG]->val/piAG)*emutAG;	//AG	*temp++=param[HKY::freqT]->val*oneminemut;										//AT		*temp++=param[HKY::freqA]->val*oneminemut;										//CA	*temp++=param[HKY::freqC]->val+param[HKY::freqC]->val*coemutCT+(param[HKY::freqT]->val/piCT)*emutCT;	//CC	*temp++=param[HKY::freqG]->val*oneminemut;										//CG	*temp++=param[HKY::freqT]->val+param[HKY::freqT]->val*coemutCT-(param[HKY::freqT]->val/piCT)*emutCT;	//CT		*temp++=param[HKY::freqA]->val+param[HKY::freqA]->val*coemutAG-(param[HKY::freqA]->val/piAG)*emutAG;	//GA	*temp++=param[HKY::freqC]->val*oneminemut;										//GC	*temp++=param[HKY::freqG]->val+param[HKY::freqG]->val*coemutAG+(param[HKY::freqA]->val/piAG)*emutAG;	//GG	*temp++=param[HKY::freqT]->val*oneminemut;										//GT		*temp++=param[HKY::freqA]->val*oneminemut;										//TA	*temp++=param[HKY::freqC]->val+param[HKY::freqC]->val*coemutCT-(param[HKY::freqC]->val/piCT)*emutCT;	//TC	*temp++=param[HKY::freqG]->val*oneminemut;										//TG	*temp++=param[HKY::freqT]->val+param[HKY::freqT]->val*coemutCT+(param[HKY::freqC]->val/piCT)*emutCT;		//TT	}}*/	void HKY::CalculateBeta()//Should be called whenever kappa or the base freqs are changed//Beta is a factor that is multiplied to the branchlength to make the eqns in //Molecular Systematics work.  This the constraint that Sum qii * freq(i) = -1 this ensures that the branches are in length//that are expected numbers of changes  //For GTR the rate params are scaled down to maintain their same ratio, but make beta=1.0{	double x;	x=(param[HKY::freqA]->val*param[HKY::freqG]->val) + (param[HKY::freqC]->val*param[HKY::freqT]->val);	x=x*param[HKY::kappa]->val + piCT*piAG;	beta=1.0/(2.0 * x);}void HKY::InitializeParameters(){	RateManager::InitializeParameters();	for(int i=0;i<nparams;i++)		{if(param[i]->StartWithCurrent()) ;		else	if(param[i]->StartWithRandom())				throw IncompleteModel("Random Function to initialize parameters isn't available yet");				//param[i]->val=SomeRandomNumberFunction();		else	if(param[i]->StartWithApproximation())					throw IncompleteModel("Initial approximation of parameters isn't available yet");		else	if(param[i]->StartWithDefault())					param[i]->SetToDefault();		else	throw BadSettings("No starting value of a parameter has been defined");		}}void HKY::PrintPAUPLsetCommand(){	Model::PrintPAUPLsetCommand();	cout<<"nst=2 tratio="<<CalculateTiTvRate()<<" basefreq = (";	cout<<param[HKY::freqA]->val<<" ";	cout<<param[HKY::freqC]->val<<" ";	cout<<param[HKY::freqG]->val<<");"<<endl;}double HKY::CalculateTiTvRate(){	double ti,tv;	tv=(param[HKY::freqA]->val+param[HKY::freqG]->val)*(param[HKY::freqC]->val+param[HKY::freqT]->val);	ti=param[HKY::kappa]->val*(param[HKY::freqA]->val*param[HKY::freqG]->val+param[HKY::freqC]->val*param[HKY::freqT]->val);	return (ti/tv);	}