#include "node.h"#include <map>#include <algorithm>#include "mynexus.h"#ifndef _TREE_#define _TREE_#include "models.h"#include "likeattributes.h"class IllegalBranchLength : public MTHException { public :	IllegalBranchLength() : MTHException() {}	IllegalBranchLength(const char *c) :MTHException(c) { }	};	class TreeEncodingException : public MTHException { public :	TreeEncodingException() : MTHException() {}	TreeEncodingException(const char *c) :MTHException(c) { }	};class Tree  {	Node *root;	Node **recursiveNodeList;	Node **recursInternalNodeList;	int ntax, nchar;	vector<Node *> termTax;	nxsstring name;	int memoryAllocation;	bool likeAttributesDirty,branchLengthsFromFile;		TreeLikeAttr *lastScoredLikeAtt;	TreeSetOfLikeAttr *setOfLikeAtt;			public:	double likelihood;	Tree();	Tree(Node *);	Tree(nxsstring tstring);	~Tree();		void AssignDataToTerm(TaxaBlock *,map<nxsstring, EncodedChars *>);	void DestroyTreeNotData(void);		void SetName(nxsstring);	nxsstring GetName();	bool LikeAttributesAreDirty()	{return likeAttributesDirty;}	Node **GetRecursiveNodeList();	void SetLikeAttributes(TreeSetOfLikeAttr *l)	{		delete setOfLikeAtt;		setOfLikeAtt=l;		}	TreeSetOfLikeAttr *GetLikeAttributes()	{		return setOfLikeAtt;		}	double LScoreAlreadyInitialized();	double LScoreAlreadyInitialized(int partnum);	bool IsGood()	{if(root)	return root->IsGood();					return false;					}	void BranchLengthSmoothingPass(PartModIndex owner,vector<PartModIndex>* affected)			{assert(1==0);		}	double LScoreDirtyParts();	void NotifyModelOfChangedParameter(PartModIndex pmi,Parameter *p)		{setOfLikeAtt->likeAttribs[pmi.partNum][pmi.modNum]->NotifyModelOfChangedParameter(p);}	void NotifyModelOfChangedParameter(PartModIndex pmi,FreqParamGroup *f)	{setOfLikeAtt->likeAttribs[pmi.partNum][pmi.modNum]->NotifyModelOfChangedParameter(f);}	};#endif