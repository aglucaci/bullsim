#include "parameter.h"Parameter::Parameter()	{	val=defaultv=0.0;	setting=0;}Parameter::Parameter(double v,int st,double def){	val=v;	setting=st;	defaultv=def;}Parameter::Parameter(double v)	{	val=defaultv=v;	setting=0;}Parameter::Parameter(double v,int st)	{	val=defaultv=v;	setting=st;}void Parameter::SetFixed(double m)	{ val=m;setting= setting|=par(FIX);}	void Parameter::SetFixed(bool i)	{ 	if(i)	SetFixed(val);	else	setting&=(~par(FIX));}int Parameter::StartWithCurrent()	{return setting&par(CUR);}void Parameter::SetStartWithCurrent(bool i)	{if(i)	{		setting&=(~par(ALLSTART));		setting|=par(CUR);		}else	setting&=(~par(CUR));}int Parameter::StartWithRandom()	{return setting&par(RAN);}void Parameter::SetStartWithRandom(bool i)	{if(i)	{setting&=(~par(ALLSTART));		setting|=par(RAN);		}else	setting&=(~par(RAN));}int Parameter::StartWithApproximation()	{return setting&par(APPRO) ;}void Parameter::SetStartWithApproximation(bool i)	{if(i)	{setting&=(~par(ALLSTART));		setting|=par(APPRO);		}else	setting&=(~par(APPRO));}int Parameter::Fixed()	{return setting&par(FIX);}int Parameter::StartWithDefault()	{return setting&par(DEF);}void Parameter::SetToDefault()	{	val=defaultv;}void Parameter::SetDefault(double m)	{ 	defaultv=m; }void Parameter::SetStartWithDefault(bool i)	{	if(i)	{setting&=(~par(ALLSTART));			setting|=par(DEF);			}	else	setting&=(~par(DEF));}BoundedParameter::BoundedParameter()	: Parameter(){maxv=minv=upbound=lowbound=0.0;}BoundedParameter::BoundedParameter(double v,double mn,double mx, int st,double def)	: Parameter(v, st,def){	maxv=upbound=mx;	minv=lowbound=mn;}PositiveParameter::PositiveParameter()	: BoundedParameter(0.0,SMALLDOUBLE,0.0,par(MIN),0.0){}PositiveParameter::PositiveParameter(double v)	: BoundedParameter(v,SMALLDOUBLE,0.0,par(MIN),v){	assert(v>=0.0);}PositiveParameter::PositiveParameter(double v,int st,double def)	: BoundedParameter(v,SMALLDOUBLE,0.0,st|par(MIN),def){		assert(!(setting&par(MAX))); 	assert(v>=0.0 && def>=0.0);}PositiveParameter::PositiveParameter(double v,int st)	: BoundedParameter(v,SMALLDOUBLE,0.0,st|par(MIN),v){		assert(!(setting&par(MAX)));	assert(v>=0.0);}NonNegativeParameter::NonNegativeParameter()	: BoundedParameter(0.0,0.0,0.0,par(MIN),0.0){}NonNegativeParameter::NonNegativeParameter(double v)	: BoundedParameter(v,0.0,0.0,par(MIN),v){	assert(v>=0.0);}NonNegativeParameter::NonNegativeParameter(double v,int st,double def)	: BoundedParameter(v,0.0,0.0,st|par(MIN),def){		assert(!(setting&par(MAX))); 	assert(v>=0.0 && def>=0.0);}NonNegativeParameter::NonNegativeParameter(double v,int st)	: BoundedParameter(v,0.0,0.0,st|par(MIN),v){		assert(!(setting&par(MAX)));	assert(v>=0.0);}FullParameter::FullParameter(double v,double mn,double mx, int st,double def,nxsstring n)	: BoundedParameter(v,mn,mx,st,def){name=n;if(setting&1 && defaultv<minv)	throw ParamExcep(name,"'s default set below its minimum");if(setting&2 && defaultv>maxv)	throw ParamExcep(name,"'s default set above its maximum");}int BoundedParameter::HasMin()	{ return setting&par(MIN);}void BoundedParameter::SetMin(double m)	{ minv=m; if(minv>lowbound)	lowbound=minv;setting |=par(MIN);}int BoundedParameter::HasMax()	{ return setting&par(MAX);}void BoundedParameter::SetMax(double m)	{ maxv=m; if(maxv<upbound)	upbound=maxv;setting |=par(MAX);}int BoundedParameter::HasUpperBound()	{return setting&par(UBOUN);}void BoundedParameter::SetUpperBound(double m)	{ 	upbound=m;	if(val>upbound)	val=upbound;	setting= setting|=par(UBOUN);	if(setting&par(MIN) && upbound<minv)	throw ParamExcep("Upper bound set below its minimum");	if(setting&par(MAX) && upbound>maxv)	throw ParamExcep("Upper bound above its maximum");}void BoundedParameter::SetUpperBound(bool i)	{ 	assert(!i);	setting&=(~par(UBOUN));}int BoundedParameter::HasLowerBound()	{return setting&par(LBOUN);}void BoundedParameter::SetLowerBound(double m)	{ 	lowbound=m;	if(val<lowbound)	val=lowbound;	setting= setting|=par(LBOUN);	if(setting&par(MIN) && lowbound<minv)	throw ParamExcep("Lower bound set below its minimum");	if(setting&par(MAX) && lowbound>maxv)	throw ParamExcep("Lower bound above its maximum");}void BoundedParameter::SetLowerBound(bool i)	{ 	assert(!i);	setting&=(~par(LBOUN));}bool BoundedParameter::Constrained()	{ return setting&par(CONSTR); }void BoundedParameter::SetConstrained(bool i)	{	if(i)	{setting|=par(CONSTR);			}	else	setting&=(~par(CONSTR));}void BoundedParameter::SetCurrent(double m)	{ 	if((setting&par(MIN) && m<minv) || (setting&par(MAX) && m>maxv))		if(setting&par(MIN) && m<minv)			if(m<(minv-SMALLDOUBLE))				throw ParamOutOfRangeExcep();			else				m=minv;		else			if(m>maxv+SMALLDOUBLE)				throw ParamOutOfRangeExcep();			else				m=maxv;	val=m; }void BoundedParameter::SetDefault(double m)	{ defaultv=m; if(setting&par(MIN) && defaultv<minv)	throw ParamExcep("Default set below its minimum");if(setting&par(MAX) && defaultv>maxv)	throw ParamExcep("Default set above its maximum");}double BoundedParameter::GetLowerOfMaxOrUbound()	{ 	if(par(UBOUN)&setting)	return upbound;	assert(par(MAX));	return maxv;}	 double BoundedParameter::GetHigherOfMinOrLbound()	{	if(par(LBOUN)&setting)	return lowbound;	assert(par(MIN));	return minv;}FreqParamGroup::FreqParamGroup(int n,double *l,int settings)	{	nparams=n;	owns=true;	statefreqs=new double *[n];	param=new Parameter *[n];	sum=0.0;	for(int i=0;i<n;i++)		{sum+=*(l+i);		if(settings&par(CUR))				param[i]=new BoundedParameter(*(l+i),0.0,1.0,settings,1.0/((double)n));		else	param[i]=new BoundedParameter(1.0/((double)n),0.0,1.0,settings,1.0/((double)n));		statefreqs[i]=&(param[i]->val);		}	}FreqParamGroup::FreqParamGroup(int n,Parameter **p)	{	owns=false;	statefreqs=new double *[n];	param=new Parameter *[n];	nparams=n;	sum=1.0;	for(int i=0;i<n;i++)		{statefreqs[i]=&((*p)->val);		param[i]=*p++;		}}	FreqParamGroup::~FreqParamGroup()	{	if(owns)	for(int i=0;i<nparams;i++)	delete param[i];	delete []param;	delete []statefreqs;}	double **FreqParamGroup::GetStateFreqs()	{return statefreqs;}Parameter *FreqParamGroup::GetParameter(int i)	{return param[i];}void FreqParamGroup::Initialize() 	{	if((*param)->StartWithCurrent()) ;	else	if((*param)->StartWithRandom())				throw ParamExcep("Random Function to initialize parameters isn't available yet");			//DirichletDistribution	else	if((*param)->StartWithApproximation())				throw ParamExcep("Initial approximation of parameters isn't available yet");	else	if((*param)->StartWithDefault())				for(int i=0;i<nparams;i++)					param[i]->SetToDefault();	else	throw ParamExcep("No starting value of a parameter has been defined");}bool FreqParamGroup::IsAMember(Parameter *inp)	{	Parameter **temp;	temp=param;	for(int i=0;i<nparams;i++)		if(*temp++==inp)			return true;	return false;	}int FreqParamGroup::Fixed()	{ 	Parameter **temp;	temp=param;	for(int i=0;i<nparams;i++)		if(!(*temp++)->Fixed())			return false;	return true;	}int FreqParamGroup::GetSetting()	{int ret=0;	Parameter **temp;	temp=param;	for(int i=0;i<nparams;i++)		ret|=(*temp++)->GetSetting();	return ret;}double FreqParamGroup::GetReparameterized(int n){	assert(n<nparams);/* First Reparameterization	double s=sum;	for(int i=0;i<n;i++)		s-=param[i]->val;	return (param[n]->val/s);*/		return param[n]->val/sum;}void FreqParamGroup::SetReparameterized(int n,double v){	/* First Reparameterization	if(v<0.0 || v>1.0)	throw ParamOutOfRangeExcep();	double prev=GetReparameterized(n);	if(prev<SMALLDOUBLE)			{double s=sum;			for(int i=0;i<n;i++)				s-=param[i]->val;			(param[n]->val)=v*s;			}	else	(param[n]->val)*=v/prev;	double invratio;	if((1-prev)<SMALLDOUBLE)		{assert(n<nparams-1);		invratio=((param[n]->val)/v)/(nparams-n-1);		for(int i=n+1;i<nparams;i++)			param[i]->val=invratio;		}	else		{invratio=(1-v)/(1-prev);		for(int i=n+1;i<nparams;i++)			(param[i]->val)*=invratio;		}			//Second version of reparam	if(v<0.0 || v>1.0)	throw ParamOutOfRangeExcep();	double prev=param[n]->val;	(param[n]->val)=v*sum;	if(prev>(1.0-SMALLDOUBLE))		{double newv=(1.0-param[n]->val)/(nparams-1);		for(int i=0;i<nparams-1;i++)			if(i!=n)				param[i]->val=newv;		}	else		{double mult=(1.0-param[n]->val)/(1.0-prev);		for(int i=0;i<nparams-1;i++)			if(i!=n)				param[i]->val*=mult;		}	if(n==nparams-1)		{double su=1.0-param[n]->val;		int j;		for(j=0;j<nparams-2;j++)			su-=param[j]->val;		assert(su>=0.0);		param[j]->val=su;		}	else		{double su=1.0;		int j;		for(j=0;j<nparams-1;j++)			su-=param[j]->val;		assert(su>=0.0);		param[j]->val=su;		}*///Third version	if(n==nparams-1)//this check only works if the only time you use this function for the last parameter, 	//all of the other parameters in the group have been updated		{double newv=sum;		for(int i=0;i<nparams-1;i++)			newv-=param[i]->val;		if(fabs(newv-v)>5*SMALLDOUBLE)			throw ParamOutOfRangeExcep();		if(newv-SMALLDOUBLE>param[n]->GetLowerOfMaxOrUbound())			throw ParamOutOfRangeExcep();		if(newv<param[n]->GetHigherOfMinOrLbound())			if(newv+SMALLDOUBLE<param[n]->GetHigherOfMinOrLbound())				throw ParamOutOfRangeExcep();			else	newv=param[n]->GetHigherOfMinOrLbound();		param[n]->val=newv;		}	else		{if(v>param[n]->GetLowerOfMaxOrUbound())			if(v-SMALLDOUBLE>param[n]->GetLowerOfMaxOrUbound())				throw ParamOutOfRangeExcep();			else	v=param[n]->GetLowerOfMaxOrUbound();		if(v<param[n]->GetHigherOfMinOrLbound())			if(v+SMALLDOUBLE<param[n]->GetHigherOfMinOrLbound())				throw ParamOutOfRangeExcep();			else	v=param[n]->GetHigherOfMinOrLbound();		param[n]->val=v;		}}double FreqParamGroup::GetReparameterizedMax(int n){	/*First Try	assert(n<nparams);	double prev=GetReparameterized(n);	double prevVal=param[n]->val;	double sliceOfThePie=param[n]->val/prev;	double maxv=1.0;	for(int i=n+1;i<nparams;i++)		maxv-=(param[i]->GetHigherOfMinOrLbound()/sliceOfThePie);	if(maxv*sliceOfThePie>param[n]->GetLowerOfMaxOrUbound())		maxv=param[n]->GetLowerOfMaxOrUbound()/sliceOfThePie;	return maxv;	//second type of reparameterization	assert(n<nparams);	double maxv=param[n]->GetLowerOfMaxOrUbound();	for(int i=0;i<nparams;i++)		if(i!=n)			{double tempm;			if(param[i]->val>0.0)			tempm=1.0-(param[i]->GetHigherOfMinOrLbound()*(1.0-param[n]->val)/param[i]->val);			if(tempm<maxv)	maxv=tempm;			}	return maxv;*/	//Third Try	assert(n<nparams);	return param[n]->GetLowerOfMaxOrUbound();}double FreqParamGroup::GetReparameterizedMin(int n){	/*First Try	assert(n<nparams);	double prev=GetReparameterized(n);	double prevVal=param[n]->val;	double sliceOfThePie=param[n]->val/prev;	return (param[n]->GetHigherOfMinOrLbound()/sliceOfThePie);	//Second Try	assert(n<nparams);	double minv=0.0;	for(int i=0;i<nparams;i++)		if(i!=n)			{double tempm;			if(param[i]->val>0.0)				tempm=1.0-(param[i]->GetLowerOfMaxOrUbound()*(1.0-param[n]->val)/param[i]->val);			if(tempm>minv)	minv=tempm;			}	return minv;*/	//Third Try	assert(n<nparams);	return param[n]->GetHigherOfMinOrLbound();}void FreqParamGroup::SetToMinimum(Parameter *inp)	{	Parameter **temp;	temp=param;	for(int i=0;i<nparams;i++)		if(*temp++==inp)			{SetReparameterized(i,0.0);			param[i]->val=0.0;//to deal with any rounding error, shouldn't be necessary			return;			}	assert(0);	}void FreqParamGroup::ForceToSumToOne(double minnonzero){	Parameter **temp;	temp=param;	sum=0.0;	for(int i=0;i<nparams;i++)		{if(param[i]->val>minnonzero)			sum+=param[i]->val;		else			param[i]->val=0.0;		}	assert(sum>.999 && sum<1.001);	for(int i=0;i<nparams;i++)		if(param[i]->val>minnonzero)			param[i]->val/=sum;	}	