#include "parsattributes.h"int ParsAttr::currNChar(1);int ParsAttr::currNStates(4);int ParsAttr::currShortPerChar(1);int ParsAttr::currNStatesInLastShort(1);bool ParsAttr::currModelDirty(true);#ifdef CHARBYCHARint ParsAttr::currCharIndex(0);#endif	InternalNodeParsAttr::InternalNodeParsAttr(int n,int encodTy)	: ParsAttr(){	#ifdef CHARBYCHAR	sizeofArray=NumShortsPerCharacter(encodTy);#else	sizeofArray=NumShortsPerCharacter(encodTy)*n;#endif	downPass=new short[sizeofArray];	finalPass=new short[sizeofArray];	upPass=new short[sizeofArray];}void InternalNodeParsAttr::Reset(){		for(long i=0;i<sizeofArray;i++)		{downPass[i]=0;		finalPass[i]=0;		upPass[i]=0;		}}InternalNodeParsAttr::~InternalNodeParsAttr(){	delete []downPass;	delete []finalPass;	delete []upPass;}short *InternalNodeParsAttr::GetDownPass(int ch){	assert(downPass);	assert(ch>=0);#ifdef CHARBYCHAR	return downPass;#else	return (downPass+ch*ParsAttr::currShortPerChar);#endif}short *InternalNodeParsAttr::GetUpPass(int ch){	assert(upPass);	assert(ch>=0);#ifdef CHARBYCHAR	return upPass;#else	return (upPass+ch*ParsAttr::currShortPerChar);#endif}short *InternalNodeParsAttr::GetFinalPass(int ch){	assert(finalPass);	assert(ch>=0);#ifdef CHARBYCHAR	return finalPass;#else	return (finalPass+ch*ParsAttr::currShortPerChar);#endif}TerminalNodeParsAttr::TerminalNodeParsAttr(short *c,int n,int encodTy)	: ParsAttr(){	CharsInShorts=c;#ifdef CHARBYCHAR	sizeofArray=NumShortsPerCharacter(encodTy);#else	sizeofArray=NumShortsPerCharacter(encodTy)*n;#endif	upPass=new short[sizeofArray];	finalPass=new short[sizeofArray];}TerminalNodeParsAttr::~TerminalNodeParsAttr(){	delete []upPass;	delete []finalPass;}short *TerminalNodeParsAttr::GetDownPass(int ch){	assert(CharsInShorts);	assert(ch>=0);	return (CharsInShorts+ch*ParsAttr::currShortPerChar);}short *TerminalNodeParsAttr::GetUpPass(int ch){	assert(upPass);	assert(ch>=0);#ifdef CHARBYCHAR	return upPass;#else	return (upPass+ch*ParsAttr::currShortPerChar);#endif}short *TerminalNodeParsAttr::GetFinalPass(int ch){	assert(finalPass);	assert(ch>=0);#ifdef CHARBYCHAR	return finalPass;#else	return (finalPass+ch*ParsAttr::currShortPerChar);#endif}TreeParsAttr::TreeParsAttr(int n,int *isC,short *nR,int encodTy){	nChar=n;	encodingType=encodTy;	isConstant=isC;	nTimesThisPatternOccurs=nR;	ownsBrLens=false;	needsToBeRescored=true;	nStates=NumStates(encodTy);	nColPerChar=NumColumnsPerCharacter(encodTy);	currentLength=-1;}SetOfParsAttr::SetOfParsAttr(int i){	assert(i>0);	nparts=i;	parsAttribs=new ParsAttr*[nparts];	for(int j=0;j<nparts;j++)		parsAttribs[j]=NULL;}SetOfParsAttr::~SetOfParsAttr(){	assert(nparts && parsAttribs);	for(int i=0;i<nparts;i++)		{assert(parsAttribs[i]);		delete parsAttribs[i];		}	delete	[] parsAttribs;}void SetOfParsAttr::AddParsAtt(int p,ParsAttr *pa){	assert(p<nparts);	delete parsAttribs[p];	parsAttribs[p]=pa;}	SetOfTreeParsAttr::SetOfTreeParsAttr(int i)//	: SetOfParsAttr(i){	assert(i>0);	nparts=i;	parsAttribs=new TreeParsAttr*[nparts];	for(int j=0;j<nparts;j++)		parsAttribs[j]=NULL;	nChar=new int[i];	nStates=new int[i];	packingType=new int[i];	packingIndex=new int[i];}	void SetOfTreeParsAttr::InitializeParsAttrStatics(int partnum){	ParsAttr::currNChar=GetNChar(partnum);	ParsAttr::currNStates=GetNStates(partnum);	ParsAttr::currShortPerChar=GetNShortsPerChar(partnum);	ParsAttr::currNStatesInLastShort=GetNStatesInLastShort(partnum);	ParsAttr::currModelDirty=true;//TEMPORARY}			SetOfTreeParsAttr::~SetOfTreeParsAttr(){	delete [] nChar;	delete [] nStates;	delete [] packingIndex;	delete [] packingType;	assert(nparts && parsAttribs);	for(int i=0;i<nparts;i++)		{assert(parsAttribs[i]);		delete parsAttribs[i];		}	delete	[] parsAttribs;}void SetOfTreeParsAttr::AddParsAtt(int p,TreeParsAttr *pa){	assert(p<nparts);	delete parsAttribs[p];	parsAttribs[p]=pa;}