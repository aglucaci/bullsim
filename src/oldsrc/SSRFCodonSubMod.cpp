#include "SSRFCodonSubMod.h"#include "basicbulldefs.h"double SSRFCodonSubMod::defFreqA(.25);double SSRFCodonSubMod::defFreqC(.25);double SSRFCodonSubMod::defFreqG(.25);double SSRFCodonSubMod::defrAC(1);double SSRFCodonSubMod::defrAG(2);double SSRFCodonSubMod::defrAT(1);double SSRFCodonSubMod::defrCG(1);double SSRFCodonSubMod::defrCT(2);double SSRFCodonSubMod::defrGT(1);double SSRFCodonSubMod::defA(.05);double SSRFCodonSubMod::defC(.05);double SSRFCodonSubMod::defD(.05);double SSRFCodonSubMod::defE(.05);double SSRFCodonSubMod::defF(.05);double SSRFCodonSubMod::defG(.05);double SSRFCodonSubMod::defH(.05);double SSRFCodonSubMod::defI(.05);double SSRFCodonSubMod::defK(.05);double SSRFCodonSubMod::defL(.05);double SSRFCodonSubMod::defM(.05);double SSRFCodonSubMod::defN(.05);double SSRFCodonSubMod::defP(.05);double SSRFCodonSubMod::defQ(.05);double SSRFCodonSubMod::defR(.05);double SSRFCodonSubMod::defS(.05);double SSRFCodonSubMod::defT(.05);double SSRFCodonSubMod::defV(.05);double SSRFCodonSubMod::defW(.05);double SSRFCodonSubMod::defY(.05);double SSRFCodonSubMod::defStop(.00);double SSRFCodonSubMod::defRate(1);double *nucRateMat[4][4];double *baseFreqMat[4];bool   SSRFCodonSubMod::mutParamsDirty(true);int SSRFCodonSubMod::geneticCode((int) gencode(mito));int CodByaa[21][6];int NCodByAA[21];int CodNum[64];int tfirbase[64];int tsecbase[64];int tthibase[64];SSRFCodonSubMod::SSRFCodonSubMod(int ncods,int naas,bool *codP,bool *aaP,Parameter ** gtrParams,FreqParamGroup *nucleoFreqs,double *ssrfParams,double *vecPreAlloc,int nSitesInWholeProtein,double **mm)	: ModelWEig(ncods,vecPreAlloc){	assert(sizeof(short)==2);//if this fails SSRFCodonSubMod::NumShortsPerCharacter will have to be changed#ifdef ALLOWMULTIHITS	nparams=11+naas;#else	nparams=10+naas;#endif	nPossAAs=naas;	mutMat=mm;	param=new Parameter *[nparams];	param[SSRFCodonSubMod::blenMult]=gtrParams[SSRFCodonSubMod::blenMult];#ifdef ALLOWMULTIHITS	param[SSRFCodonSubMod::pMultHit]=gtrParams[SSRFCodonSubMod::pMultHit];#endif	param[SSRFCodonSubMod::freqA]=gtrParams[SSRFCodonSubMod::freqA];	param[SSRFCodonSubMod::freqC]=gtrParams[SSRFCodonSubMod::freqC];	param[SSRFCodonSubMod::freqG]=gtrParams[SSRFCodonSubMod::freqG];	param[SSRFCodonSubMod::freqT]=gtrParams[SSRFCodonSubMod::freqT];	param[SSRFCodonSubMod::rAC]=gtrParams[SSRFCodonSubMod::rAC];	param[SSRFCodonSubMod::rAG]=gtrParams[SSRFCodonSubMod::rAG];	param[SSRFCodonSubMod::rAT]=gtrParams[SSRFCodonSubMod::rAT];	param[SSRFCodonSubMod::rCG]=gtrParams[SSRFCodonSubMod::rCG];	param[SSRFCodonSubMod::rCT]=gtrParams[SSRFCodonSubMod::rCT];	param[SSRFCodonSubMod::rGT]=gtrParams[SSRFCodonSubMod::rGT];	sharedBrLenInterpreter=gtrParams[SSRFCodonSubMod::rGT+1];	SharedConstruction(codP,aaP,nucleoFreqs,ssrfParams,nSitesInWholeProtein);}	void 	SSRFCodonSubMod::SharedConstruction(bool *codP,bool *aaP,FreqParamGroup *nucleoFreqs,double *ssrfParams,int nSitesInWholeProtein){	overflowMultiplier=1.0;	SSRkContrib=0.0;	nCodonsInProtein=nSitesInWholeProtein;	nfreqParamGroups=2;	baseFreqs=nucleoFreqs;	int i;		codonLocToGlob=new int[nstates];	codLocToAminoAcidLoc=new int[nstates];	aminoAcidLocToGlob=new int[nPossAAs];		int thisCodonName=0;	for(i=0;i<64;i++)		if(codP[i])			{assert(thisCodonName<nstates);			codonGlobToLoc[i]=thisCodonName;			codonLocToGlob[thisCodonName]=i;			thisCodonName++;			}		else			codonGlobToLoc[i]=-1;	int thisAAName=0;	for(i=0;i<21;i++)		if(aaP[i])			{assert(thisAAName<nPossAAs);			aminoAcidLocToGlob[thisAAName]=i;			thisAAName++;			}	for(i=0;i<nstates;i++)		{int translated=CodNum[codonLocToGlob[i]];		bool found=false;		for(int j=0;(!found && j<nPossAAs);j++)			if(translated==aminoAcidLocToGlob[j])				{found=true;				codLocToAminoAcidLoc[i]=j;				}		}	double OneMinusOthers=1.0;	for(int j=0;j<20;j++)		OneMinusOthers-=ssrfParams[j];	if(nPossAAs==1)		param[SSRFCodonSubMod::fAAs]=new FullParameter(1.0,0.0,1.0,par(MIN)|par(MAX)|par(CUR)|par(FIX),defA,"Amino");	else		for(i=0;i<nPossAAs;i++)			if(aminoAcidLocToGlob[i]==20)#ifdef NOSTOPCODONS					throw BadParams("Amino Acid Freqs don't add up to 1");#else					param[SSRFCodonSubMod::fAAs+i]=new FullParameter(OneMinusOthers,0.0,1.0,par(MIN)|par(MAX)|par(CUR),defA,"Stop");#endif			else	param[SSRFCodonSubMod::fAAs+i]=new FullParameter(ssrfParams[aminoAcidLocToGlob[i]],0.0,1.0,par(MIN)|par(MAX)|par(CUR),defA,"Amino");	aaFreqs=new FreqParamGroup(nPossAAs,(param+SSRFCodonSubMod::fAAs));	stateFreqs=NULL;	codFreqs=new double*[nstates];//awkward because in other models the state freqs might not be contiguous in memory	*codFreqs=new double[nstates];	for(int j=1;j<nstates;j++)		codFreqs[j]=(codFreqs[0]+j);	for(int j=0;j<nstates;j++)		for(int k=0;k<nstates;k++)			qMatrix[j][k]=0.0;#ifdef ELIMINATEALLZEROS	maxcodonLocToGlob=new int[nstates];	maxcodLocToAminoAcidLoc=new int[nstates];	maxaminoAcidLocToGlob=new int[nPossAAs];		for(int i = 0 ;i<nstates;i++)		{maxcodonLocToGlob[i]=codonLocToGlob[i];		maxcodLocToAminoAcidLoc[i]=codLocToAminoAcidLoc[i];		}	for(int i = 0 ;i<nPossAAs;i++)		maxaminoAcidLocToGlob[i]=aminoAcidLocToGlob[i];	for(int i=0;i<64;i++)		origCodonGlobToLoc[i]=codonGlobToLoc[i];		maxNStates=nstates;	maxNPossAAs=nPossAAs;	OrigParamArray=new Parameter *[nPossAAs];	for(i=0;i<nPossAAs;i++)		OrigParamArray[i]=param[SSRFCodonSubMod::fAAs+i];	//ResizeModel();//don't do this so the correct size arrays of characters will be allocated in the terminal Like Attr #endif	CalculateQ(); //initializes RateConst parameter and codon freqs}#ifdef ELIMINATEALLZEROSvoid SSRFCodonSubMod::ResizeModel(){	//first step is to move all amino acids of freq 0 to the back of the param list and keep non zeros in the correct order	eigencalc=qmatcalc=false;	int destInd=0,i;	nPossAAs=0;	for(i=0;i<maxNPossAAs;i++)		if(OrigParamArray[i]->val>0.0)			{param[SSRFCodonSubMod::fAAs+destInd]=OrigParamArray[i];			destInd++;			aminoAcidLocToGlob[nPossAAs]=maxaminoAcidLocToGlob[i];			nPossAAs++;			}	for(i=0;i<maxNPossAAs;i++)//not necessary just want to makes param array has all of the parameters		if(OrigParamArray[i]->val<=0.0)			{param[SSRFCodonSubMod::fAAs+destInd]=OrigParamArray[i];			destInd++;			}	assert(destInd==maxNPossAAs);		//Fix the four code to code translation tables	nstates=0;	for(i=0;i<maxNStates;i++)		if(OrigParamArray[maxcodLocToAminoAcidLoc[i]]->val>0.0)//if this codon is still present			{codonLocToGlob[nstates]=maxcodonLocToGlob[i];			for(int j=0;j<maxNPossAAs;j++)				if(OrigParamArray[maxcodLocToAminoAcidLoc[i]]==param[SSRFCodonSubMod::fAAs+j])					codLocToAminoAcidLoc[nstates]=j;			nstates++;			}	//fill in codon Glob to loc with -1's then change all still used codons to the correct number	for(i=0;i<maxNStates;i++)		codonGlobToLoc[maxcodonLocToGlob[i]]=-1;	for(i=0;i<nstates;i++)		codonGlobToLoc[codonLocToGlob[i]]=i;			//alter all of multidimensional arrays  DANGER ONLY WORKS IF THEY ARE ALLOCATED PSDMATRIX STYLE	for(i=1;i<nstates;i++)		{pMatrix[0][i]=(pMatrix[0][i-1]+nstates);		REigenVector[i]=REigenVector[i-1]+nstates;		InvEigenVector[i]=InvEigenVector[i-1]+nstates;		CEigenVector[i]=CEigenVector[i-1]+nstates;		CInvEigenVector[i]=CInvEigenVector[i-1]+nstates;		qMatrix[i]=qMatrix[i-1]+nstates;		}			CalculateCodonFreqs();//unnecessary as long as I'm being sloppy and calling calc codon freqs every time I calc Q}bool SSRFCodonSubMod::NeedToExpandPossibleAA(){	#ifdef NOSTOPCODONS	if(maxNPossAAs<20)		{bool allcodons[64],allaminoacids[21];		for(int i=0;i<64;i++)			allcodons[i]=false;		for(int i=0;i<21;i++)			allaminoacids[i]=false;		for(int i = 0 ;i<nstates;i++)			{allcodons[maxcodonLocToGlob[i]]=true;			allaminoacids[CodNum[maxcodonLocToGlob[i]]]=true;			}		int newMaxNPossAAs=GetNumberOfPossibleAminoAcids(allcodons,allaminoacids);		if(newMaxNPossAAs>maxNPossAAs)			return true;				for(int i = 0 ;i<maxNStates;i++)			allcodons[maxcodonLocToGlob[i]]=false;//set all of the codons possible in the original size model back to false				for(int i=0;i<64;i++)//anything true is between to currently non zero codons and isn't included in the original model size			if(allcodons[i])					return true;		}	return false;#else	assert(0);#endif}#endifvoid SSRFCodonSubMod::CalculateCodonFreqs(){	double *codF;	codF=*codFreqs;	double numerators[6];	double tot=0.0;	for(int thisaa=0;thisaa<nPossAAs;thisaa++)		{double aaf=param[SSRFCodonSubMod::fAAs+thisaa]->val;		int ndegcod=NCodByAA[aminoAcidLocToGlob[thisaa]];		double denominator=0.0;		for(int thiscodon=0;thiscodon<ndegcod;thiscodon++)			{int thisglobcod=CodByaa[aminoAcidLocToGlob[thisaa]][thiscodon];			assert(thisglobcod!=65);			denominator+=numerators[thiscodon]=*baseFreqMat[tfirbase[thisglobcod]]**baseFreqMat[tsecbase[thisglobcod]]**baseFreqMat[tthibase[thisglobcod]];			}		for(int thiscodon=0;thiscodon<ndegcod;thiscodon++)			{int thisglobcod=CodByaa[aminoAcidLocToGlob[thisaa]][thiscodon];			assert(thisglobcod!=65);			tot+=codF[codonGlobToLoc[thisglobcod]]=aaf*numerators[thiscodon]/denominator;			}		}	if(!(abs(tot-1.0)<0.00000001)) 		throw MTHException("Codon Frequencies don't add up to 1"); 	}SSRFCodonSubMod::~SSRFCodonSubMod(){	for(int i=SSRFCodonSubMod::fAAs;i<nparams;i++)//don't delete the shared GTR parameters		delete param[i];	delete [] param;	REigenValues=NULL;//sharing memory, so we don't want to double delete, do we?	EigInvEigMat=NULL;	ImEigenValues=NULL;	REigenVector=NULL;	InvEigenVector=NULL;	CEigenVector=NULL;	CInvEigenVector=NULL;	qMatrix=NULL;	EigExp=NULL;	delete [] codonLocToGlob;	delete [] aminoAcidLocToGlob;	delete [] codLocToAminoAcidLoc;#ifdef ELIMINATEALLZEROS	delete [] maxcodonLocToGlob;	delete [] maxcodLocToAminoAcidLoc;	delete [] maxaminoAcidLocToGlob;	delete [] *OrigParamArray;#endif}double  SSRFCodonSubMod::CalculateBeta()//Beta is a factor that is multiplied to the branchlength to make the eqns in //Molecular Systematics work.  This the constraint that Sum qii * freq(i) = -1 this ensures that the branches are in length//that are expected numbers of changes  //SSRkContrib is the defined k constant, this function maintains the rates//For GTR the rate params are scaled down to maintain their same ratio, but make beta=1.0{	double x,y;	x=0.0;	double *qm;	qm=*qMatrix;	//assumes that calculate code freq; and that the rows sum to zero	double *codF=*codFreqs;	for(int row=0;row<nstates;row++)		{x-=(*codF++)**qm;		qm+=nstates+1;		}	return x;}#define PMUT 0.000015void SSRFCodonSubMod::RecalculateMutMatrix(){	register int i,j,k,l,m,n;	#ifdef ALLOWMULTIHITS	double ssmm[16];	for(i=0;i<4;i++)		ssmm[5*i]=0.0;	for(i=0;i<4;i++)		for(j=0;j<4;j++)			if(i!=j)				ssmm[5*i]+=ssmm[4*i+j]=*nucRateMat[i][j]**baseFreqMat[j];	double temp=0.0;	double *tempp;	for(i=0;i<4;i++)		temp+=ssmm[5*i]**baseFreqMat[i];//	temp=PMUT/temp;	tempp=ssmm;	for(i=0;i<16;i++)		*tempp++*=temp;	//ssmm is now scaled so that the weighted average of p(mutation)==PMUT (mutations are rare so a discrete-time motivated producton of multi -site rates is reasonable	for(i=0;i<4;i++)		{ssmm[5*i]=1.0-ssmm[5*i];		if(ssmm[5*i]<.95)			throw BadParams("After scaling a nucleotide mutation prob is >.05");		}		tempp=mutMat[0];	/* now treating param[SSRFCodonSubMod::pMultHit] as a multiplier to modify the rate of double/ triple hits	its affect is dependent on PMUT (which is a define so it won't change in a run) if param[SSRFCodonSubMod::pMultHit]is	chance of one mut is PMUT, double is simply (PMUT^2)* param[SSRFCodonSubMod::pMultHit] , three is (PMUT^3) * param[SSRFCodonSubMod::pMultHit]^2, 	this is a quasi-probability based method done to mimic AH's implementation (if set to 1.0 you get his version)*/		for(i=0;i<4;i++)	for(j=0;j<4;j++)	for(k=0;k<4;k++)	for(l=0;l<4;l++)	for(m=0;m<4;m++)	for(n=0;n<4;n++)		{*tempp=ssmm[4*i+l]*ssmm[4*j+m]*ssmm[4*k+n];		if(i!=l)			{if(j!=m)				{if(k!=n)					*tempp*=(param[SSRFCodonSubMod::pMultHit]->val)*(param[SSRFCodonSubMod::pMultHit]->val);				else						*tempp*=(param[SSRFCodonSubMod::pMultHit]->val);				}			else				{if(k!=n)					*tempp*=(param[SSRFCodonSubMod::pMultHit]->val);				}			}		else			{if(j!=m)				{if(k!=n)					*tempp*=(param[SSRFCodonSubMod::pMultHit]->val);				}			}		tempp++;		}	//last step to scale mut rates up to reasonable values (weighted mu is 1.0)	tempp=mutMat[0];	temp=0.0;	int row=0;	for(i=0;i<4;i++)	for(j=0;j<4;j++)	for(k=0;k<4;k++)		{mutMat[row][row]=0.0;		for(l=0;l<64;l++)			if(l!=row)				mutMat[row][row]-=mutMat[row][l];		temp-=mutMat[row][row]**baseFreqMat[i]**baseFreqMat[j]**baseFreqMat[k];		row++;		}		for(int i=0;i<64;i++)		for(int j=0;j<64;j++)			mutMat[i][j]/=temp;						#else	double *tempp;	tempp=mutMat[0];	for(i=0;i<4;i++)	for(j=0;j<4;j++)	for(k=0;k<4;k++)	for(l=0;l<4;l++)	for(m=0;m<4;m++)	for(n=0;n<4;n++)		if(i!=l)			if(j!=m || k!=n)				*tempp++=0.0;			else				*tempp++=*nucRateMat[i][l]**baseFreqMat[l];		else			if(j!=m)				if(k!=n)					*tempp++=0.0;				else						*tempp++=*nucRateMat[j][m]**baseFreqMat[m];			else				if(k!=n)					*tempp++=*nucRateMat[k][n]**baseFreqMat[n];				else					*tempp++=0.0;//last step to scale mut rates up to reasonable values (weighted mu is 1.0)	tempp=mutMat[0];	double temp=0.0;	int row=0;	for(i=0;i<4;i++)	for(j=0;j<4;j++)	for(k=0;k<4;k++)		{mutMat[row][row]=0.0;		for(l=0;l<64;l++)			if(l!=row)				mutMat[row][row]-=mutMat[row][l];		temp-=mutMat[row][row]**baseFreqMat[i]**baseFreqMat[j]**baseFreqMat[k];		row++;		}	for(int i=0;i<64;i++)		for(int j=0;j<64;j++)			mutMat[i][j]/=temp;					#endif	mutParamsDirty=false;}	void SSRFCodonSubMod::CalculateQ(void){		sharedBrLenInterpreter->val-=SSRkContrib/nCodonsInProtein;//subtract out contribution of old qmatrix to mean rate of change		/*double rpAC=param[SSRFCodonSubMod::rAC]->val;	double rpAG=param[SSRFCodonSubMod::rAG]->val;	double rpAT=param[SSRFCodonSubMod::rAT]->val;	double rpCG=param[SSRFCodonSubMod::rCG]->val;	double rpCT=param[SSRFCodonSubMod::rCT]->val;	double rpGT=param[SSRFCodonSubMod::rGT]->val;	double fpA=param[SSRFCodonSubMod::freqA]->val;	double fpC=param[SSRFCodonSubMod::freqC]->val;	double fpG=param[SSRFCodonSubMod::freqG]->val;	double fpT=param[SSRFCodonSubMod::freqT]->val;*/	double *qm,tempx;	double *codF;	CalculateCodonFreqs();	codF=*codFreqs;	if(mutParamsDirty)		RecalculateMutMatrix();		int nsq=nstates*nstates;	qm=qMatrix[0];	for( int i=0;i<nsq;i++)		*qm++=0.0;	int currFromFirBase,currFromSecBase,currFromThiBase;	int globTocod,globFromcod,locTocod,locToAA,locFromAA;#ifdef ALLOWMULTIHITS	int currToFirBase,currToSecBase,currToThiBase;	int globTocod,globFromcod,locTocod,locToAA,locFromAA;	for(int row=0;row<nstates;row++)		{qMatrix[row][row]=0.0;		locFromAA=codLocToAminoAcidLoc[row];		if(param[SSRFCodonSubMod::fAAs+locFromAA]->val>0.0)			{globFromcod=codonLocToGlob[row];			currFromFirBase=tfirbase[globFromcod];			currFromSecBase=tsecbase[globFromcod];			currFromThiBase=tthibase[globFromcod];			for(currToFirBase=0;currToFirBase<4;currToFirBase++)				for(currToSecBase=0;currToSecBase<4;currToSecBase++)					for(currToThiBase=0;currToThiBase<4;currToThiBase++)						{globTocod=16*currToFirBase + 4*currToSecBase + currToThiBase;						locTocod=codonGlobToLoc[globTocod];						if(locTocod!=-1 && locTocod!=row)				//if amino acid could have freq >0.0							{locToAA=codLocToAminoAcidLoc[locTocod];							if(locToAA==locFromAA)			//same amino acid								qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod];							else								if(codF[locTocod]<SMALLDOUBLE)									qMatrix[row][locTocod]=0.0;								else									{if(mutMat[globTocod][globFromcod])//might be zero if mult hit param is zero										{tempx=codF[row]*mutMat[globFromcod][globTocod]/(codF[locTocod]*mutMat[globTocod][globFromcod]);										if(fabs(tempx-1.0)<SMALLDOUBLE)											qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod];										else											{qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod]*log(1.0/tempx)/(1.0-tempx);											}										}										}							}						}								}		else	for(int col=0;col<nstates;col++)					qMatrix[row][col]=0.0;		}#else	int currToBase;	for(int row=0;row<nstates;row++)		{qMatrix[row][row]=0.0;		locFromAA=codLocToAminoAcidLoc[row];		if(param[SSRFCodonSubMod::fAAs+locFromAA]->val>0.0)			{globFromcod=codonLocToGlob[row];			currFromFirBase=tfirbase[globFromcod];			currFromSecBase=tsecbase[globFromcod];			currFromThiBase=tthibase[globFromcod];						//try mutating first base						for(currToBase=0;currToBase<4;currToBase++)				if(currToBase!=currFromFirBase)		//only check if it is a mutant					{globTocod=16*currToBase + 4*currFromSecBase + currFromThiBase;					locTocod=codonGlobToLoc[globTocod];					if(locTocod!=-1)				//if amino acid could have freq >0.0						{locToAA=codLocToAminoAcidLoc[locTocod];						if(locToAA==locFromAA)			//same amino acid							{qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod];							}						else							if(codF[locTocod]<SMALLDOUBLE)								qMatrix[row][locTocod]=0.0;							else								{tempx=codF[row]*mutMat[globFromcod][globTocod]/(codF[locTocod]*mutMat[globTocod][globFromcod]);								if(fabs(tempx-1.0)<SMALLDOUBLE)									qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod];								else									{qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod]*log(1.0/tempx)/(1.0-tempx);									}								}						}					}								/*OLDWAY//try mutating second base			for(currToBase=0;currToBase<4;currToBase++)//try mutating first base				if(currToBase!=currFromSecBase)		//only check if it is a mutant					{globTocod=16*currFromFirBase + 4*currToBase + currFromThiBase;					locTocod=codonGlobToLoc[globTocod];					if(locTocod!=-1)				//if amino acid could have freq >0.0						{locToAA=codLocToAminoAcidLoc[locTocod];						if(locToAA==locFromAA)			//same amino acid							{qMatrix[row][row]-=qMatrix[row][locTocod]=*nucRateMat[currFromSecBase][currToBase]**baseFreqMat[currToBase];							}						else							if(codF[locTocod]<SMALLDOUBLE)								qMatrix[row][locTocod]=0.0;							else								{tempx=codF[row]**baseFreqMat[currToBase]/(codF[locTocod]**baseFreqMat[currFromSecBase]);								if(fabs(tempx-1.0)<SMALLDOUBLE)									qMatrix[row][row]-=qMatrix[row][locTocod]=*nucRateMat[currFromSecBase][currToBase]**baseFreqMat[currToBase];								else									{qMatrix[row][row]-=qMatrix[row][locTocod]=*nucRateMat[currFromSecBase][currToBase]**baseFreqMat[currToBase]*log(1.0/tempx)/(1.0-tempx);									}								}						}					}			*/							for(currToBase=0;currToBase<4;currToBase++)//try mutating first base				if(currToBase!=currFromSecBase)		//only check if it is a mutant					{globTocod=16*currFromFirBase + 4*currToBase + currFromThiBase;					locTocod=codonGlobToLoc[globTocod];					if(locTocod!=-1)				//if amino acid could have freq >0.0						{locToAA=codLocToAminoAcidLoc[locTocod];						if(locToAA==locFromAA)			//same amino acid							{qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod];							}						else							if(codF[locTocod]<SMALLDOUBLE)								qMatrix[row][locTocod]=0.0;							else								{tempx=codF[row]*mutMat[globFromcod][globTocod]/(codF[locTocod]*mutMat[globTocod][globFromcod]);								if(fabs(tempx-1.0)<SMALLDOUBLE)									qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod];								else									{qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod]*log(1.0/tempx)/(1.0-tempx);									}								}						}					}											for(currToBase=0;currToBase<4;currToBase++)//try mutating first base				if(currToBase!=currFromThiBase)		//only check if it is a mutant					{globTocod=16*currFromFirBase + 4*currFromSecBase + currToBase;					locTocod=codonGlobToLoc[globTocod];					if(locTocod!=-1)				//if amino acid could have freq >0.0						{locToAA=codLocToAminoAcidLoc[locTocod];						if(locToAA==locFromAA)			//same amino acid							{qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod];							}						else							if(codF[locTocod]<SMALLDOUBLE)								qMatrix[row][locTocod]=0.0;							else								{tempx=codF[row]*mutMat[globFromcod][globTocod]/(codF[locTocod]*mutMat[globTocod][globFromcod]);								if(fabs(tempx-1.0)<SMALLDOUBLE)									qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod];								else									{qMatrix[row][row]-=qMatrix[row][locTocod]=mutMat[globFromcod][globTocod]*log(1.0/tempx)/(1.0-tempx);									}								}						}					}																}		else	for(int col=0;col<nstates;col++)					qMatrix[row][col]=0.0;		}#endif 	SSRkContrib=CalculateBeta(); 	sharedBrLenInterpreter->val+=SSRkContrib/nCodonsInProtein;//add in the contribution of the new qmatrix to mean rate of change	/*ofstream tempout("Bullout",ios::app);	tempout<<nstates<<endl;	for(int i=0;i<nstates;i++)		{for(int j=0;j<nstates;j++)			tempout<<qMatrix[i][j]<<"\t";		tempout<<endl;		}	tempout.close();(*/}void SSRFCodonSubMod::InitializeParameters(){	RateManager::InitializeParameters();	for(int i=0;i<nparams;i++)		{if(param[i]->StartWithCurrent()) ;		else	if(param[i]->StartWithRandom())					throw IncompleteModel("Random Function to initialize parameters isn't available yet");				//param[i]->val=SomeRandomNumberFunction();		else	if(param[i]->StartWithApproximation())					throw IncompleteModel("Initial approximation of parameters isn't available yet");		else	if(param[i]->StartWithDefault())					param[i]->SetToDefault();		else	throw BadSettings("No starting value of a parameter has been defined");		}}void SSRFCodonSubMod::EncodeACharacter(short *dest,short *raw,int datatype,bool keepGap/*=false*/) {	assert((datatype==EncodingType(SubModMitoCodons) || datatype==EncodingType(SubModNucCodons)) && !keepGap);		//assumes that a codon code will take up 4 shorts;	assert(sizeof(short)==2);		short *temp;	temp=dest;		*dest=0;	short smask,fb,sb,tb;	for(int i=0;i<nstates;i++)		{fb=sb=tb=1;		fb<<=tfirbase[codonLocToGlob[i]];		sb<<=tsecbase[codonLocToGlob[i]];		tb<<=tthibase[codonLocToGlob[i]];		if(i%16==0)			{smask=1;			if(i)				*++dest=0;			}		else	smask<<=1;		if((fb&raw[0]) && (sb&raw[1]) && (tb&raw[2])) 			(*dest)|=smask;		}	bool atLeastOne=false;	for(int i=0;(!atLeastOne && i<nstates);i++)		if(temp[i])			atLeastOne=true;	if(!atLeastOne)		temp[0]=0;}void SSRFCodonSubMod::UpdatePmat(double b)	{	ModelWEig::UpdatePMatrix(*pMatrix,param[SSRFCodonSubMod::blenMult]->val*b);}void SSRFCodonSubMod::UpdatePmat(double b,int onlycol)	{	ModelWEig::UpdatePMatrix(*pMatrix,param[SSRFCodonSubMod::blenMult]->val*b,onlycol);}void SSRFCodonSubMod::UpdatePmatWithOutSharedMatrix(double **pmats,double b)	{	ModelWEig::UpdatePmatWithOutSharedMatrix(*pMatrix,param[SSRFCodonSubMod::blenMult]->val*b);}	void SSRFCodonSubMod::UpdatePmatWithOutSharedMatrix(double **pmats,double b,int onlycol){	ModelWEig::UpdatePmatWithOutSharedMatrix(*pMatrix,param[SSRFCodonSubMod::blenMult]->val*b,onlycol);}FreqParamGroup *SSRFCodonSubMod::GetFreqParamGroup(int i) {	assert(i<nfreqParamGroups); 	if(i)	return aaFreqs;	return baseFreqs;}int SSRFCodonSubMod::GetEncodingType() {	if(geneticCode==gencode(mito))		return EncodingType(SubModMitoCodons);	assert(geneticCode==gencode(nuc));	return EncodingType(SubModNucCodons);}int SSRFCodonSubMod::GetNStates()	{	return nstates;}#ifdef CODONHACK		void SSRFCodonSubMod::AlertSharedMemory()		{	if(eigencalc)				{	#ifdef	CONDENSEMATRICES		#ifdef PRESUMMINGCONSTS				if(numberOfLastnonZero<nstates-1)//DAnger do this better					CalculateEigInvEigMultAndPreSum(*REigenVector,InvEigenVector,nstates,EigInvEigMat,preSummed,numberOfLastnonZero);				else		#endif								CalculateAndCondenseEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);	#else		#ifdef PRESUMMINGCONSTS				if(numberOfLastnonZero<nstates-1)//DAnger do this better					{CalculateReorderedEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);					DoPreSummation(EigInvEigMat,*preSummed,numberOfLastnonZero,nstates);					}				else		#endif								CalculateGlobalEigInvEigMult(*REigenVector,InvEigenVector,nstates,EigInvEigMat);	#endif			}	}	double SSRFCodonSubMod::GetMultiplier()		{	return overflowMultiplier;	}	void SSRFCodonSubMod::SetMultiplier(double x)		{	overflowMultiplier=x;	}#endif		void SSRFCodonSubMod::ParameterHasChanged(FreqParamGroup *p)	{eigencalc=qmatcalc=false;//cout<<"In OverLoaded SSRFCodonSubMod::ParameterHasCHanged(FreqParamGroup*)\n";if(baseFreqs==p)	mutParamsDirty=true;}void SSRFCodonSubMod::FreqParamChangesShouldSumToOne(FreqParamGroup *p) {eigencalc=qmatcalc=false;//cout<<"In OverLoaded SSRFCodonSubMod::ParameterHasCHanged(FreqParamGroup*)\n";if(baseFreqs==p)	mutParamsDirty=true;#ifdef ELIMINATEALLZEROSelse	{int i;bool needToResize=false;	assert(p==aaFreqs);	aaFreqs->ForceToSumToOne(MINIMUMAAFREQABOVEZERO);	for(i=0;i<nPossAAs;i++)		if(param[SSRFCodonSubMod::fAAs+i]->val<MINIMUMAAFREQABOVEZERO)			needToResize=true;	for(;i<maxNPossAAs;i++)		if(param[SSRFCodonSubMod::fAAs+i]->val>0.0)			needToResize=true;	if(needToResize)		{cout<<"About To Resize the Model\n";		ResizeModel();		throw NeedToRecodeException();		}	}#endif}void SSRFCodonSubMod::ParameterHasChanged(Parameter *p)	{if(p==gammashape)	CalculateRates();else 	{if(p!=pinv && p!=param[SSRFCodonSubMod::blenMult])			eigencalc=qmatcalc=false;#ifdef ALLOWMULTIHITS	for(int i=SSRFCodonSubMod::pMultHit;((!mutParamsDirty) && i<SSRFCodonSubMod::fAAs);i++)#else	for(int i=SSRFCodonSubMod::freqA;((!mutParamsDirty) && i<SSRFCodonSubMod::fAAs);i++)#endif		if(p==param[i])			mutParamsDirty=true;#ifdef ELIMINATEALLZEROS	//check to see if need to resize and recode	if(p->GetName()=="Amino")		{if(p->val>0.0)			for(int i=0;i<nstates;i++)				if(param[SSRFCodonSubMod::fAAs+i]==p)					return;		ResizeModel();		throw NeedToRecodeException();		}#endif	}}		#ifdef ELIMINATEALLZEROS	int SSRFCodonSubMod::GetMaxNStates() 	{	return maxNStates;	}		int *SSRFCodonSubMod::GetOrigLocToGlob() 	{	return maxcodonLocToGlob;	}		int *SSRFCodonSubMod::GetCurrentGlobToLoc()		{	return codonGlobToLoc;	}	#endif	double **SSRFCodonSubMod::GetStateFreqs()	{	return codFreqs;}int SSRFCodonSubMod::NumShortsPerCharacter()	{	return (1+(int)floor(((double)nstates-.1)/16.0));}//written to allow odd coding of SSRFCodonSubModel which overridesint SSRFCodonSubMod::NumStatesInLastShort()	{	return 1+((nstates-1)%16);}//written to allow odd coding of SSRFCodonSubModel which overrides/*void SSRFCodonSubMod::PrintPAUPLsetCommand(){	}void SSRFCodonSubMod::PrintBullLsettingsCommand(){	}*///char tcodChar[]={'K','N','K','N','T','T','T','T','*','S','*','S','M','I','M','I','Q','H','Q','H','P','P','P','P','R','R','R','R','L','L','L','L','E','D','E','D','A','A','A','A','G','G','G','G','V','V','V','V','*','Y','*','Y','S','S','S','S','W','C','W','C','L','F','L','F'};//char taaChar[]={'A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y','*'};#ifdef CODONHACKvoid CreateSetOfSSRFCodonSubMods(int nSitesInWholeProtein,double *gtrp/* at least 8 doubles long */,double **setofSSRFparams/* full size=nm*21 */,SSRFCodonSubMod **arrayOfMods,double *multipliers,double treesc,int gcode)#elsevoid CreateSetOfSSRFCodonSubMods(int nSitesInWholeProtein,double *gtrp/* at least 8 doubles long */,double **setofSSRFparams/* full size=nm*21 */,Model **arrayOfMods,double *multipliers,double treesc,int gcode)#endif{		/*double **vecPreAlloc,***matPreAlloc;	complex ***compPre;	vecPreAlloc=new double *[4];	matPreAlloc=new double **[3];	compPre=new complex **[2];		vecPreAlloc[0]=new double[64];	vecPreAlloc[1]=new double[262144];	vecPreAlloc[2]=new double[64];	matPreAlloc[0]=psdmatrix(64);	matPreAlloc[1]=psdmatrix(64);	compPre[0]=pscmatrix(64);	compPre[1]=pscmatrix(64);	matPreAlloc[2]=psdmatrix(64);	vecPreAlloc[3]=new double[64];	double ***pMat;	pMat=psdmatrices(64,1);*/	double *vecPreAlloc;#ifdef NOSTOPCODONS	if(gcode==gencode(mito))		vecPreAlloc=new double [216000];//60^3	else		{assert(gcode==gencode(nuc));		vecPreAlloc=new double [226981];//61^3		}		#else	vecPreAlloc=new double [262144];//64^3#endif		Parameter **param;	param=new Parameter *[SSRFCodonSubMod::rGT+2];	param[SSRFCodonSubMod::blenMult]=new PositiveParameter(treesc,par(MIN)|par(CUR),1.0);#ifdef ALLOWMULTIHITS	param[SSRFCodonSubMod::pMultHit]=new PositiveParameter(gtrp[9],par(MIN)|par(CUR),0.0);#endif	param[SSRFCodonSubMod::freqA]=new FullParameter(gtrp[0],SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),SSRFCodonSubMod::defFreqA,"freqA");	param[SSRFCodonSubMod::freqC]=new FullParameter(gtrp[1],SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),SSRFCodonSubMod::defFreqC,"freqC");	param[SSRFCodonSubMod::freqG]=new FullParameter(gtrp[2],SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),SSRFCodonSubMod::defFreqG,"freqG");	param[SSRFCodonSubMod::freqT]=new FullParameter(1.0-gtrp[0]-gtrp[1]-gtrp[2],SMALLDOUBLE,1.0-SMALLDOUBLE,par(MIN)|par(MAX)|par(CUR),1.0-SSRFCodonSubMod::defFreqA-SSRFCodonSubMod::defFreqC-SSRFCodonSubMod::defFreqG,"freqT");	param[SSRFCodonSubMod::rAC]=new PositiveParameter(gtrp[3],par(MIN)|par(CUR),SSRFCodonSubMod::defrAC);	param[SSRFCodonSubMod::rAG]=new PositiveParameter(gtrp[4],par(MIN)|par(CUR),SSRFCodonSubMod::defrAG);	param[SSRFCodonSubMod::rAT]=new PositiveParameter(gtrp[5],par(MIN)|par(CUR),SSRFCodonSubMod::defrAT);	param[SSRFCodonSubMod::rCG]=new PositiveParameter(gtrp[6],par(MIN)|par(CUR),SSRFCodonSubMod::defrCG);	param[SSRFCodonSubMod::rCT]=new PositiveParameter(gtrp[7],par(MIN)|par(CUR),SSRFCodonSubMod::defrCT);	param[SSRFCodonSubMod::rGT]=new PositiveParameter(gtrp[8],par(MIN)|par(CUR),SSRFCodonSubMod::defrGT);	param[SSRFCodonSubMod::rGT+1]=new PositiveParameter(0.0,par(MIN)|par(CUR),1.0);//the branch length interpreter	FreqParamGroup *stateFreqs=new FreqParamGroup(4,(param+SSRFCodonSubMod::freqA));		SetCodeRelatedGlobals(gcode);	SSRFCodonSubMod::geneticCode=gcode;	/*double ***nucRateMat;	nucRateMat=new double **[4];	nucRateMat[0]=new double *[4];	nucRateMat[1]=new double *[4];	nucRateMat[2]=new double *[4];	nucRateMat[3]=new double *[4];*/		nucRateMat[0][0]=nucRateMat[1][1]=nucRateMat[2][2]=nucRateMat[3][3]=NULL;	nucRateMat[0][1]=nucRateMat[1][0]=&(param[SSRFCodonSubMod::rAC]->val);	nucRateMat[0][2]=nucRateMat[2][0]=&(param[SSRFCodonSubMod::rAG]->val);	nucRateMat[0][3]=nucRateMat[3][0]=&(param[SSRFCodonSubMod::rAT]->val);	nucRateMat[1][2]=nucRateMat[2][1]=&(param[SSRFCodonSubMod::rCG]->val);	nucRateMat[1][3]=nucRateMat[3][1]=&(param[SSRFCodonSubMod::rCT]->val);	nucRateMat[2][3]=nucRateMat[3][2]=&(param[SSRFCodonSubMod::rGT]->val);		/*baseFreqMat=new double[4];*/	baseFreqMat[0]=&(param[SSRFCodonSubMod::freqA]->val);	baseFreqMat[1]=&(param[SSRFCodonSubMod::freqC]->val);	baseFreqMat[2]=&(param[SSRFCodonSubMod::freqG]->val);	baseFreqMat[3]=&(param[SSRFCodonSubMod::freqT]->val);	double **mm;	mm=psdmatrix(64);		bool codOfObsAA[64],possAAs[21];		for(int i=0;i<nSitesInWholeProtein;i++)		{		double tot=0.0;		for(int j=0;j<20;j++)			tot+=setofSSRFparams[i][j];		for(int j=0;j<64;j++)			{			if(CodNum[j]<20)				if(setofSSRFparams[i][CodNum[j]]>0.0)						{codOfObsAA[j]=possAAs[CodNum[j]]=true;					}				else	{codOfObsAA[j]=possAAs[CodNum[j]]=false;}			}#ifdef NOSTOPCODONS		int rounds=0;		while(fabs(tot-1.0)>SMALLDOUBLE) 				{if(fabs(tot-1.0)>.00001 || rounds>2) 				throw BadParams("Amino Acid Frequencies don't add up to 1.0");			else				{for(int j=0;j<20;j++)					setofSSRFparams[i][j]/=tot;				tot=0.0;				for(int j=0;j<20;j++)					tot+=setofSSRFparams[i][j];				}			rounds++;			}				possAAs[20]=false;		codOfObsAA[CodByaa[20][0]]=codOfObsAA[CodByaa[20][1]]=codOfObsAA[CodByaa[20][2]]=codOfObsAA[CodByaa[20][3]]=false;#else		if(fabs(1.0-tot)<SMALLDOUBLE)			{possAAs[20]=false;			codOfObsAA[CodByaa[20][0]]=codOfObsAA[CodByaa[20][1]]=codOfObsAA[CodByaa[20][2]]=codOfObsAA[CodByaa[20][3]]=false;			}		else			{possAAs[20]=true;			codOfObsAA[CodByaa[20][0]]=codOfObsAA[CodByaa[20][1]]=codOfObsAA[CodByaa[20][2]]=codOfObsAA[CodByaa[20][3]]=true;			}#endif											int naas=GetNumberOfPossibleAminoAcids(codOfObsAA,possAAs);		int ncods=GetNumberOfPossibleCodons(possAAs);		//cout<<ncods<<endl;		arrayOfMods[i]=new SSRFCodonSubMod(ncods,naas,codOfObsAA,possAAs,param,stateFreqs,setofSSRFparams[i],vecPreAlloc,nSitesInWholeProtein,mm);		if(multipliers)				arrayOfMods[i]->SetMultiplier(*multipliers++);		}}int GetNumberOfPossibleAminoAcids(bool *codOfObsAA,bool *possAAs){	int naas=0;	for(int i=0;i<21;i++)		if(possAAs[i])			naas++;	int prevnaas=-1;	while(prevnaas!=naas)		{prevnaas=naas;		int codn=0;		for(int fb=0;fb<4;fb++)			for(int sb=0;sb<4;sb++)				for(int tb=0;tb<4;tb++)					{#ifdef NOSTOPCODONS					if(!codOfObsAA[codn] && CodNum[codn]!=20)						{bool mfir=false;						for(int mutatedbase=0;(!mfir && mutatedbase<4);mutatedbase++)							if(codOfObsAA[16*mutatedbase+4*sb+tb] )								mfir=true;						bool msec=false;						for(int mutatedbase=0;(!msec && mutatedbase<4);mutatedbase++)							if(codOfObsAA[16*fb+4*mutatedbase+tb] )								msec=true;						bool mthi=false;						for(int mutatedbase=0;(!mthi && mutatedbase<4);mutatedbase++)							if(codOfObsAA[16*fb+4*sb+mutatedbase] )								mthi=true;						if((mfir&&msec) ||(mthi&&msec) ||(mfir&&mthi))							{naas++;							possAAs[CodNum[codn]]=true;							for(int k=0;k<64;k++)								if(CodNum[codn]==CodNum[k])									codOfObsAA[k]=true;							}						}#else						if(!codOfObsAA[codn])						{bool mfir=false;						for(int mutatedbase=0;(!mfir && mutatedbase<4);mutatedbase++)							if(codOfObsAA[16*mutatedbase+4*sb+tb])								mfir=true;						bool msec=false;						for(int mutatedbase=0;(!msec && mutatedbase<4);mutatedbase++)							if(codOfObsAA[16*fb+4*mutatedbase+tb])								msec=true;						bool mthi=false;						for(int mutatedbase=0;(!mthi && mutatedbase<4);mutatedbase++)							if(codOfObsAA[16*fb+4*sb+mutatedbase])								mthi=true;						if((mfir&&msec) ||(mthi&&msec) ||(mfir&&mthi))							{naas++;							possAAs[CodNum[codn]]=true;							for(int k=0;k<64;k++)								if(CodNum[codn]==CodNum[k])									codOfObsAA[k]=true;							}						}#endif					codn++;					}		}	return naas;}int GetNumberOfPossibleCodons(bool *possAAs){	int nc=0;	for(int i=0;i<21;i++)		if(possAAs[i])			nc+=NCodByAA[i];	return nc;}bool IsBetweenNonZeroFreqAminoAcids(int index,double *ssrfParams){return true;}/*bool CheckNotZero(double x){	if(fabs(x)>SMALLDOUBLE)		return true;	return false;}*/#ifdef CODONHACKvoid SSRFCodonSubMod::AddAminoAcidFreqs(ofstream &dest){	//for printing out amino acid freqs in log file	double outpaaf[20];	for(int i=0;i<20;i++)		outpaaf[i]=0.0;	for(int i=0;i<nPossAAs;i++)		if(aminoAcidLocToGlob[i]<20)			outpaaf[aminoAcidLocToGlob[i]]=param[SSRFCodonSubMod::fAAs+i]->val;	for(int i=0;i<20;i++)		{dest<<outpaaf[i]<<" ";		}}#endifvoid SetCodeRelatedGlobals(int codeToUse){	if(codeToUse==gencode(mito))		{int MitocodByaa[21][6]={			{36,37,38,39,65,65},			{57,59,65,65,65,65},			{33,35,65,65,65,65},			{32,34,65,65,65,65},			{61,63,65,65,65,65},			{40,41,42,43,65,65},			{17,19,65,65,65,65},			{13,15,65,65,65,65},			{0 ,2 ,65,65,65,65},			{28,29,30,31,60,62},			{12,14,65,65,65,65},			{1 ,3 ,65,65,65,65},			{20,21,22,23,65,65},			{16,18,65,65,65,65},			{24,25,26,27,65,65},			{9 ,11,52,53,54,55},			{4 ,5 ,6 ,7 ,65,65},			{44,45,46,47,65,65},			{56,58,65,65,65,65},			{49,51,65,65,65,65},			{8 ,10,48,50,65,65}			};		int i,j;		for(i=0;i<21;i++)			for(j=0;j<6;j++)				CodByaa[i][j]=MitocodByaa[i][j];						int MitoNCodByAA[]={4,2,2,2,2,4,2,2,2,6,2,2,4,2,4,6,4,4,2,2,4};		for(i=0;i<21;i++)			NCodByAA[i]=MitoNCodByAA[i];		int MitoCodNum[]={8,11,8,11,16,16,16,16,20,15,20,15,10,7,10,7,13,6,13,6,12,12,12,12,14,14,14,14,9,9,9,9,3,2,3,2,0,0,0,0,5,5,5,5,17,17,17,17,20,19,20,19,15,15,15,15,18,1,18,1,9,4,9,4};		int mitofirbase[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3};		int mitosecbase[]={0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3};		int mitothibase[]={0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3};		for(i=0;i<64;i++)			{CodNum[i]=MitoCodNum[i];			tfirbase[i]=mitofirbase[i];			tsecbase[i]=mitosecbase[i];			tthibase[i]=mitothibase[i];			}				}	else		{assert(gencode(nuc)==codeToUse);		int NuccodByaa[21][6]={		{36,37,38,39,65,65},		{57,59,65,65,65,65},		{33,35,65,65,65,65},		{32,34,65,65,65,65},		{61,63,65,65,65,65},		{40,41,42,43,65,65},		{17,19,65,65,65,65},		{12,13,15,65,65,65},		{0,2,65,65,65,65},		{28,29,30,31,60,62},		{14,65,65,65,65,65},		{1,3,65,65,65,65},		{20,21,22,23,65,65},		{16,18,65,65,65,65},		{8,10,24,25,26,27},		{9,11,52,53,54,55},		{4,5,6,7,65,65},		{44,45,46,47,65,65},		{58,65,65,65,65,65},		{49,51,65,65,65,65},		{48,50,56,65,65,65}		};		int i,j;		for(i=0;i<21;i++)			for(j=0;j<6;j++)				CodByaa[i][j]= NuccodByaa[i][j];						int NucNCodByAA[]={4,2,2,2,2,4,2,3,2,6,1,2,4,2,6,6,4,4,1,2,3};		for(i=0;i<21;i++)			NCodByAA[i]= NucNCodByAA[i];		int NucCodNum[]={8,11,8,11,16,16,16,16,14,15,14,15,7,7,10,7,13,6,13,6,12,12,12,12,14,14,14,14,9,9,9,9,3,2,3,2,0,0,0,0,5,5,5,5,17,17,17,17,20,19,20,19,15,15,15,15,20,1,18,1,9,4,9,4};		int Nucfirbase[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3};		int Nucsecbase[]={0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3};		int Nucthibase[]={0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3};		for(i=0;i<64;i++)			{CodNum[i]= NucCodNum[i];			tfirbase[i]= Nucfirbase[i];			tsecbase[i]= Nucsecbase[i];			tthibase[i]= Nucthibase[i];			}				}	}