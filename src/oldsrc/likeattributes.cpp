#include "likeattributes.h"#include "AdvancedBullDefs.h"int LikeAttr::currNChar(1);int LikeAttr::currNStates(4);int LikeAttr::currShortPerChar(1);int LikeAttr::currNRateCats(1);int LikeAttr::currNStatesInLastShort(1);bool LikeAttr::currModelDirty(true);double LikeAttr::Multiplier(1.53);#ifdef CHARBYCHARint LikeAttr::currCharIndex(0);#endifLikeAttr::LikeAttr()//Constructor for internal node's attributes{	model=NULL;	Pmat=NULL;	blen=NULL;	blenMod=NULL;}LikeAttr::LikeAttr(Model *m)//Constructor for internal node's attributes{	model=m;	Pmat=m->GetPmat();	blen=NULL;	blenMod=NULL;}LikeAttr *LikeAttr::Copy(){	LikeAttr *tempLA;	if(model)		tempLA=new LikeAttr(model);	else		tempLA=new LikeAttr();	if(blen)		tempLA->blen=new BoundedParameter(blen->val,0.0,0.0,blen->GetSetting(),DEFAULTSTARTINGBRLEN);	//TEMPORARY COPY Leaves blen mod uncopied  MEMORY LEAK old blen still allocated I don't know why anymore!!!}Model* LikeAttr::GetModel()	{return model;}/*bool LikeAttr::SharePmatMemory()	{ 	return memoryMode&SHAREPMAT;}*/void LikeAttr::UpdatePmat(double x)	{	//assert(SharePmatMemory());	model->UpdatePmat(x);	//else model->UpdatePmat(x,**Pmat);}double ***LikeAttr::getPmat()	{return Pmat;}void 	LikeAttr::SetBLen(double d){	if(blen) blen->SetCurrent(d);	else	blen=new BoundedParameter(d,0.0,0.0,par(CUR)|par(MIN),DEFAULTSTARTINGBRLEN);}	void 	LikeAttr::MultBLen(double d){	assert(blen);	blen->val*=d;}	LikeAttr::~LikeAttr(){	//assert(SharePmatMemory());	delete blen;	delete blenMod;}InternalNodeLikeAttr::InternalNodeLikeAttr(int n,Model *m)	: LikeAttr(m){	#ifdef CHARBYCHAR	sizeofcondlikeArray=(m->GetNStates())*(m->GetNRateCats());	condlike=new double[sizeofcondlikeArray];#else	sizeofcondlikeArray=(m->GetNStates())*n*(m->GetNRateCats());	condlike=new double[sizeofcondlikeArray];#endif}InternalNodeLikeAttr::InternalNodeLikeAttr(int n,Model *m,double *prealloc)	: LikeAttr(m){	#ifdef CODONHACK	#ifdef SHAREDMEMFORINTCHARS		sizeofcondlikeArray=64;		condlike=prealloc;	#else		throw	MTHException("Entered unwritten code InternalNodeLikeAttr constructor" );	#endif#else	throw	MTHException("Entered unwritten code InternalNodeLikeAttr constructor2" );#endif}void InternalNodeLikeAttr::Reset(){		double *cl;	cl=condlike;	for(long i=0;i<sizeofcondlikeArray;i++)		*cl++=1.0;}InternalNodeLikeAttr::~InternalNodeLikeAttr(){	delete []condlike;}#ifdef CHARBYCHAR	//the next four functions assume that you can't allocate a full array for each node to store the conditional likelihoods (because of memory constraints)		void InternalNodeLikeAttr::SetArgToCondLikeOfThisSubTree(double *cl)	{			if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));		double *thispmel,*thisratecl,*thisstatecl;				thisratecl=condlike;		thispmel=**(model->GetPmat());#ifndef CODONHACK		for(int nr=0;nr<currNRateCats;nr++)			{#endif						for(int ns=0;ns<currNStates;ns++)				{*cl=0.0;				thisstatecl=thisratecl;				for(int dns=0;dns<currNStates;dns++)					*cl+=(*thisstatecl++)*(*thispmel++);				cl++;				}#ifndef CODONHACK			thisratecl+=currNStates;			}#endif				}		void TerminalNodeLikeAttr::SetArgToCondLikeOfThisSubTreeWithOutSharedMatrix(double *cl)	{			#ifndef CODONHACK			assert(0);		#endif		#ifdef BYARRAYOFOBSSTATES			#ifdef CONDLIKEVERSION				assert(0);			#else				double **thispmrow;				short *thiscl,*thisShortCl;				double tempcl;				short smask;				thispmrow=*model->GetPmat();				//only works under codon hack mode				if(nObsStates==1)					{if(blenMod)		model->UpdatePmatWithOutSharedMatrix(blen->val*blenMod->val/(1.0-model->GetPInv()),*OStates);						else			model->UpdatePmatWithOutSharedMatrix(blen->val/(1.0-model->GetPInv()),*OStates);						for(int ns=0;ns<currNStates;ns++)						(*cl++)=Multiplier*(*(*(thispmrow++)+*OStates));					}				else 					if(nObsStates)						{if(blenMod)		model->UpdatePmatWithOutSharedMatrix(blen->val*blenMod->val/(1.0-model->GetPInv()));						else			model->UpdatePmatWithOutSharedMatrix(blen->val/(1.0-model->GetPInv()));										for(int ns=0;ns<currNStates;ns++)							{tempcl=0.0;							for(int nos=0;nos<nObsStates;nos++)								tempcl+=Multiplier*(*(*thispmrow+OStates[nos]));							thispmrow++;							*cl++=tempcl;		//Only difference between MultArg and SetArg							}						}				else					for(int ns=0;ns<currNStates;ns++)						*cl++=Multiplier;			#endif		#else			assert(0);		#endif	}		void TerminalNodeLikeAttr::SetArgToCondLikeOfThisSubTreeWithZeroBranchLength(double *cl)	{			#ifndef CODONHACK			assert(0);		#endif		#ifdef BYARRAYOFOBSSTATES			#ifdef CONDLIKEVERSION				assert(0);			#else				//only works under codon hack mode				if(nObsStates==1)					{double *tempcl;					tempcl=cl;					for(int ns=0;ns<currNStates;ns++)						*tempcl++=0.0;					cl[*OStates]=Multiplier;					}				else 					if(nObsStates)						{for(int ns=0;ns<currNStates;ns++)							{double *tempcl;							tempcl=cl;							for(int ns=0;ns<currNStates;ns++)								*tempcl++=0.0;							for(int nos=0;nos<nObsStates;nos++)								cl[OStates[nos]]=Multiplier;							}						}				else					for(int ns=0;ns<currNStates;ns++)						*cl++=Multiplier;			#endif		#else			assert(0);		#endif	}	void TerminalNodeLikeAttr::SetArgToCondLikeOfThisSubTree(double *cl)	{					/*double **tempd;		ofstream dbout("Tempout");		tempd=*(model->GetPmat());		for(int i=0;i<currNStates;i++)			{for(int j=0;j<currNStates;j++)				dbout<<tempd[i][j]<<"\t";			dbout<<endl;			}		dbout.close();*/				#ifdef BYARRAYOFOBSSTATES			#ifdef CONDLIKEVERSION						if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));			else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));						double *thispmel,*thisratecl,*thisstatecl;			thispmel=**(model->GetPmat());			if(nObsStates)				for(int ns=0;ns<currNStates;ns++)					{*cl=0.0;					thisstatecl=OStatesCL;					for(int dns=0;dns<currNStates;dns++)						*cl+=(*thisstatecl++)*(*thispmel++);					cl++;					}			else				for(int ns=0;ns<currNStates;ns++)					*cl++=Multiplier;			#else			double **thispmrow;			short *thiscl,*thisShortCl;			double tempcl;			short smask;			thispmrow=*model->GetPmat();			//only works under codon hack mode			if(nObsStates==1)				{if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()),*OStates);					else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()),*OStates);					for(int ns=0;ns<currNStates;ns++)					(*cl++)=Multiplier*(*(*(thispmrow++)+*OStates));				}			else 				if(nObsStates)					{if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));					else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));								for(int ns=0;ns<currNStates;ns++)						{tempcl=0.0;						for(int nos=0;nos<nObsStates;nos++)							tempcl+=Multiplier*(*(*thispmrow+OStates[nos]));						thispmrow++;						*cl++=tempcl;		//Only difference between MultArg and SetArg						}					}			else				for(int ns=0;ns<currNStates;ns++)					*cl++=Multiplier;			#endif		#else		if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));					double **thispmrow;		short *thiscl,*thisShortCl;		double tempcl;		short smask;		thispmrow=*model->GetPmat();		thiscl=CharsInShorts+currCharIndex*currShortPerChar;		if(currShortPerChar==1)			{for(int nr=0;nr<currNRateCats;nr++)				{for(int ns=0;ns<currNStates;ns++)					{thisShortCl=thiscl;					tempcl=0.0;					smask=1;					for(int dns=0;dns<currNStates;dns++)						{if(*thisShortCl&smask)							tempcl+=Multiplier*(*(*thispmrow+dns));						smask<<=1;						}					thispmrow++;					*cl++=tempcl;		//Only difference between MultArg and SetArg					}				}			}		else			{for(int nr=0;nr<currNRateCats;nr++)				{for(int ns=0;ns<currNStates;ns++)					{int shorit;					thisShortCl=thiscl;					tempcl=0.0;					for(shorit=0;shorit<currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{if(*thisShortCl&smask)								tempcl+=Multiplier*(*(*thispmrow+dns+shorit*BITSPERSHORT));							smask<<=1;							}						thisShortCl++;						}					smask=1;					for(int pshorit=0;pshorit<currNStatesInLastShort;pshorit++)						{if(*thisShortCl&smask)							tempcl+=Multiplier*(*(*thispmrow+pshorit+shorit*BITSPERSHORT));						smask<<=1;						}					thispmrow++;					*cl++=tempcl;		//Only difference between MultArg and SetArg					}				}			}		#endif	}	/*void TerminalNodeLikeAttr::SetArgToCondLikeOfThisSubTree(double *cl,bool tr)	{	cout<<"Using temporary Backwards SetArgToCondLikeOfThisSubTree"<<endl;		if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));							double **stfr=model->GetStateFreqs();			double *thispm;			short *thiscl,*thisShortCl;			double tempcl;			short smask;			thispm=**model->GetPmat();			thispm+=*OStates*currNStates;			//only works under codon hack mode			if(nObsStates==1)				for(int ns=0;ns<currNStates;ns++)					{if(tr)						(*cl++)=Multiplier**thispm++**stfr[*OStates];					else						(*cl++)=Multiplier**thispm++;					}			else {assert(0);/*				if(nObsStates)				for(int ns=0;ns<currNStates;ns++)					{tempcl=0.0;					for(int nos=0;nos<nObsStates;nos++)						tempcl+=Multiplier*(*(*thispmrow+OStates[nos]));					thispmrow++;					*cl++=tempcl;		//Only difference between MultArg and SetArg					}				else				for(int ns=0;ns<currNStates;ns++)					*cl++=Multiplier;				}	}	void TerminalNodeLikeAttr::MultArgByCondLikeOfThisSubTree(double *cl,bool tr)	{	cout<<"Using temporary Backwards SetArgToCondLikeOfThisSubTree"<<endl;		if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));							double **stfr=model->GetStateFreqs();			double *thispm;			short *thiscl,*thisShortCl;			double tempcl;			short smask;			thispm=**model->GetPmat();			thispm+=*OStates*currNStates;			//only works under codon hack mode			if(nObsStates==1)				for(int ns=0;ns<currNStates;ns++)					{if(tr)						(*cl++)*=Multiplier**thispm++**stfr[*OStates];					else						(*cl++)*=Multiplier**thispm++;					}			else {assert(0);/*				if(nObsStates)				for(int ns=0;ns<currNStates;ns++)					{tempcl=0.0;					for(int nos=0;nos<nObsStates;nos++)						tempcl+=Multiplier*(*(*thispmrow+OStates[nos]));					thispmrow++;					*cl++=tempcl;		//Only difference between MultArg and SetArg					}				else				for(int ns=0;ns<currNStates;ns++)					*cl++=Multiplier;  				}	}	void InternalNodeLikeAttr::SetArgToCondLikeOfThisSubTree(double *cl,bool tr)	{	cout<<"Using temporary Backwards SetArgToCondLikeOfThisSubTree"<<endl;		if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));							dbout.close();		double **thispm;		double *thisratecl=condlike;		double tempcl;		short smask;		thispm=*model->GetPmat();		for(int j=0;j<currNStates;j++)			cl[j]=0.0;		for(int i=0;i<currNStates;i++)			for(int j=0;j<currNStates;j++)				cl[j]+=thispm[i][j]*thisratecl[i];		}	void InternalNodeLikeAttr::MultArgByCondLikeOfThisSubTree(double *cl,bool tr)	{	cout<<"Using temporary Backwards SetArgToCondLikeOfThisSubTree"<<endl;		if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));							double **thispm;		double *thisratecl=condlike;		double tempcl;		short smask;		thispm=*model->GetPmat();		for(int j=0;j<currNStates;j++)			{double temp=0.0;			for(int i=0;i<currNStates;i++)				temp+=thispm[i][j]*thisratecl[i];			cl[j]*=temp;			}	}*/	void InternalNodeLikeAttr::MultArgByCondLikeOfThisSubTree(double *cl)	{			if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));		double ***pm,*thispmel,*thisratecl,*thisstatecl;		int toNextChar=currNStates*currNRateCats;		double tempcl;						thisratecl=condlike;		thispmel=**model->GetPmat();#ifndef CODONHACK		for(int nr=0;nr<currNRateCats;nr++)			{#endif						for(int ns=0;ns<currNStates;ns++)				{tempcl=0.0;				thisstatecl=thisratecl;				for(int dns=0;dns<currNStates;dns++)					tempcl+=(*thisstatecl++)*(*thispmel++);				(*cl++)*=tempcl;							//Only difference between MultArg and SetArg				}#ifndef CODONHACK			thisratecl+=currNStates;			}#endif	}	void TerminalNodeLikeAttr::MultArgByCondLikeOfThisSubTree(double *cl)	{			#ifdef BYARRAYOFOBSSTATES			#ifdef CONDLIKEVERSION				if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));				else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));							double ***pm,*thispmel,*thisratecl,*thisstatecl;				int toNextChar=currNStates*currNRateCats;				double tempcl;				thispmel=**model->GetPmat();				if(nObsStates)					for(int ns=0;ns<currNStates;ns++)						{tempcl=0.0;						thisstatecl=OStatesCL;						for(int dns=0;dns<currNStates;dns++)							tempcl+=(*thisstatecl++)*(*thispmel++);						(*cl++)*=tempcl;							//Only difference between MultArg and SetArg						}				else					for(int ns=0;ns<currNStates;ns++)							(*cl++)*=Multiplier;			#else							double **thispmrow;				short *thiscl,*thisShortCl;				double tempcl;				short smask;				thispmrow=*model->GetPmat();							//only works under CODONHACK mode				if(nObsStates==1)					{if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()),*OStates);					else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()),*OStates);					for(int ns=0;ns<currNStates;ns++)						(*cl++)*=Multiplier*(*(*(thispmrow++)+*OStates));					}				else if(nObsStates)					{if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));					else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));					for(int ns=0;ns<currNStates;ns++)						{tempcl=0.0;						for(int nos=0;nos<nObsStates;nos++)							tempcl+=Multiplier*(*(*thispmrow+OStates[nos]));						thispmrow++;						(*cl++)*=tempcl;		//Only difference between MultArg and SetArg						}					}				else					for(int ns=0;ns<currNStates;ns++)						(*cl++)*=Multiplier;			#endif				#else				double **thispmrow;		short *thiscl,*thisShortCl;		double tempcl;		short smask;		thispmrow=*model->GetPmat();		thiscl=CharsInShorts+currCharIndex*currShortPerChar;		if(currShortPerChar==1)			{for(int nr=0;nr<currNRateCats;nr++)				{for(int ns=0;ns<currNStates;ns++)					{thisShortCl=thiscl;					tempcl=0.0;					smask=1;					for(int dns=0;dns<currNStates;dns++)						{if(*thisShortCl&smask)							tempcl+=Multiplier*(*(*thispmrow+dns));						smask<<=1;						}					thispmrow++;					(*cl++)*=tempcl;		//Only difference between MultArg and SetArg					}				}			}		else			{for(int nr=0;nr<currNRateCats;nr++)				{for(int ns=0;ns<currNStates;ns++)					{int shorit;					thisShortCl=thiscl;					tempcl=0.0;					for(shorit=0;shorit<currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{if(*thisShortCl&smask)								tempcl+=Multiplier*(*(*thispmrow+dns+shorit*BITSPERSHORT));							smask<<=1;							}						thisShortCl++;						}					smask=1;					for(int pshorit=0;pshorit<currNStatesInLastShort;pshorit++)						{if(*thisShortCl&smask)							tempcl+=Multiplier*(*(*thispmrow+pshorit+shorit*BITSPERSHORT));						smask<<=1;						}					thispmrow++;					(*cl++)*=tempcl;		//Only difference between MultArg and SetArg					}				}			}		#endif	}		void InternalNodeLikeAttr::SetThisCondLikeBasedOnAncArg(double *ancCL)//non-root version	{			if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));		double *pm,*thispmel,*cl,*thisstatecl;				pm=**(model->GetPmat());		cl=condlike;				for(int nr=0;nr<currNRateCats;nr++)			{for(int ns=0;ns<currNStates;ns++)				{thispmel=pm+ns;				thisstatecl=ancCL;				*cl=0.0;				for(int dns=0;dns<currNStates;dns++)					{*cl+=(*thisstatecl++)*(*thispmel);					thispmel+=currNStates;					}				cl++;				}			pm+=currNStates*currNStates;			ancCL+=currNStates;			}	}		void InternalNodeLikeAttr::SetThisCondLikeToLikeBelowBasedOnArg(double **stateFreq)//root version	{	double *cl;		cl=condlike;		for(int nr=0;nr<currNRateCats;nr++)				for(int ns=0;ns<currNStates;ns++)				*cl++=*stateFreq[ns];	}#else	//can allocate a whole array version of these four functions:	void InternalNodeLikeAttr::SetArgToCondLikeOfThisSubTree(double *cl)	{			if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));		double ***pm,*thispmel,*thischarcl,*thisratecl,*thisstatecl;		int toNextChar=currNStates*currNRateCats;		double tempcl;				pm=model->GetPmat();		thischarcl=condlike;		for(int nc=0;nc<currNChar;nc++)			{thisratecl=thischarcl;			thispmel=**pm;			for(int nr=0;nr<currNRateCats;nr++)				{for(int ns=0;ns<currNStates;ns++)					{tempcl=0.0;					thisstatecl=thisratecl;					for(int dns=0;dns<currNStates;dns++)						tempcl+=(*thisstatecl++)*(*thispmel++);					*cl++=tempcl;		//Only difference between MultArg and SetArg					}				thisratecl+=currNStates;				}			thischarcl+=toNextChar;			}	}	void TerminalNodeLikeAttr::SetArgToCondLikeOfThisSubTree(double *cl)	{			if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));				double ***pm,**thispmrow;		short *thiscl,*thisShortCl;		int toNextChar=currNStates*currNRateCats;		double tempcl;		short smask;		pm=model->GetPmat();		thiscl=CharsInShorts;		if(currShortPerChar==1)			{for(int nc=0;nc<currNChar;nc++)				{thispmrow=*pm;				for(int nr=0;nr<currNRateCats;nr++)					{for(int ns=0;ns<currNStates;ns++)						{thisShortCl=thiscl;						tempcl=0.0;						smask=1;						for(int dns=0;dns<currNStates;dns++)							{if(*thisShortCl&smask)								tempcl+=(*(*thispmrow+dns));							smask<<=1;							}						thispmrow++;						*cl++=tempcl;		//Only difference between MultArg and SetArg						}					//thispmrow++;					}				thiscl++;				}			}		else			{for(int nc=0;nc<currNChar;nc++)				{thispmrow=*pm;				for(int nr=0;nr<currNRateCats;nr++)					{for(int ns=0;ns<currNStates;ns++)						{int shorit;						thisShortCl=thiscl;						tempcl=0.0;						for(shorit=0;shorit<currShortPerChar-1;shorit++)							{smask=1;							for(int dns=0;dns<BITSPERSHORT;dns++)								{if(*thisShortCl&smask)									tempcl+=(*(*thispmrow+dns+shorit*BITSPERSHORT));								smask<<=1;								}							thisShortCl++;							}						smask=1;						for(int pshorit=0;pshorit<currNStatesInLastShort;pshorit++)							{if(*thisShortCl&smask)								tempcl+=(*(*thispmrow+pshorit+shorit*BITSPERSHORT));							smask<<=1;							}						thispmrow++;						*cl++=tempcl;		//Only difference between MultArg and SetArg						}					//thispmrow++;					}				thiscl+=currShortPerChar;				}			}	}	void InternalNodeLikeAttr::MultArgByCondLikeOfThisSubTree(double *cl)	{	if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));		double ***pm,*thispmel,*thischarcl,*thisratecl,*thisstatecl;		int toNextChar=currNStates*currNRateCats;		double tempcl;				pm=model->GetPmat();		thischarcl=condlike;		for(int nc=0;nc<currNChar;nc++)			{thisratecl=thischarcl;			thispmel=**pm;			for(int nr=0;nr<currNRateCats;nr++)				{for(int ns=0;ns<currNStates;ns++)					{tempcl=0.0;					thisstatecl=thisratecl;					for(int dns=0;dns<currNStates;dns++)						tempcl+=(*thisstatecl++)*(*thispmel++);					(*cl++)*=tempcl;							//Only difference between MultArg and SetArg					}				thisratecl+=currNStates;				}			thischarcl+=toNextChar;			}	}	void TerminalNodeLikeAttr::MultArgByCondLikeOfThisSubTree(double *cl)	{	if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));		double ***pm,**thispmrow;		short *thiscl,*thisShortCl;		int toNextChar=currNStates*currNRateCats;		double tempcl;		short smask;		pm=model->GetPmat();		thiscl=CharsInShorts;		if(currShortPerChar==1)			{for(int nc=0;nc<currNChar;nc++)				{thispmrow=*pm;				for(int nr=0;nr<currNRateCats;nr++)					{for(int ns=0;ns<currNStates;ns++)						{thisShortCl=thiscl;						tempcl=0.0;						smask=1;						for(int dns=0;dns<currNStates;dns++)							{if(*thisShortCl&smask)								tempcl+=(*(*thispmrow+dns));							smask<<=1;							}						thispmrow++;						(*cl++)*=tempcl;		//Only difference between MultArg and SetArg						}					//thispmrow++;					}				thiscl++;				}			}		else			{for(int nc=0;nc<currNChar;nc++)				{thispmrow=*pm;				for(int nr=0;nr<currNRateCats;nr++)					{for(int ns=0;ns<currNStates;ns++)						{int shorit;						thisShortCl=thiscl;						tempcl=0.0;						for(shorit=0;shorit<currShortPerChar-1;shorit++)							{smask=1;							for(int dns=0;dns<BITSPERSHORT;dns++)								{if(*thisShortCl&smask)									tempcl+=(*(*thispmrow+dns+shorit*BITSPERSHORT));								smask<<=1;								}							thisShortCl++;							}						smask=1;						for(int pshorit=0;pshorit<currNStatesInLastShort;pshorit++)							{if(*thisShortCl&smask)								tempcl+=(*(*thispmrow+pshorit+shorit*BITSPERSHORT));							smask<<=1;							}						thispmrow++;						(*cl++)*=tempcl;		//Only difference between MultArg and SetArg						}					//thispmrow++;					}				thiscl+=currShortPerChar;				}			}	}	void InternalNodeLikeAttr::SetThisCondLikeBasedOnAncArg(double *ancCL)//non root version	{	if(blenMod)		model->UpdatePmat(blen->val*blenMod->val/(1.0-model->GetPInv()));		else			model->UpdatePmat(blen->val/(1.0-model->GetPInv()));		double *firstpm,*pm,*thispmel,*cl,*thisstatecl,*thisratecl;				cl=condlike;		thisratecl=ancCL;		firstpm=**(model->GetPmat());		for(int nc=0;nc<currNChar;nc++)			{pm=firstpm;			for(int nr=0;nr<currNRateCats;nr++)				{for(int ns=0;ns<currNStates;ns++)					{thispmel=pm+ns;					*cl=0.0;					thisstatecl=thisratecl;					for(int dns=0;dns<currNStates;dns++)						{*cl+=(*thisstatecl++)*(*thispmel);						thispmel+=currNStates;						}					cl++;					}				pm+=currNStates*currNStates;				thisratecl+=currNStates;				}			}	}		void InternalNodeLikeAttr::SetThisCondLikeToLikeBelowBasedOnArg(double **stateFreq)//root's version	{	double *cl;		cl=condlike;		for(int nc=0;nc<currNChar;nc++)			for(int nr=0;nr<currNRateCats;nr++)					for(int ns=0;ns<currNStates;ns++)					*cl++=*stateFreq[ns];	}#endifvoid TerminalNodeLikeAttr::FillDoubleArrayWithCondLikeOfChars(double *cl){	short *thisShortCl;	short smask;	thisShortCl=CharsInShorts;		if(currShortPerChar==1)		for(int nc=0;nc<currNChar;nc++)			{for(int nr=0;nr<currNRateCats;nr++)				{smask=1;				for(int ns=0;ns<currNStates;ns++)					{if(*thisShortCl&smask)							*cl++=1.0;					else	*cl++=0.0;					smask<<=1;					}				}			thisShortCl++;			}	else		for(int nc=0;nc<currNChar;nc++)			{for(int nr=0;nr<currNRateCats;nr++)				for(int ns=0;ns<currNStates;ns++)					{int shorit;					for(shorit=0;shorit<currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{if(*thisShortCl&smask)									*cl++=1.0;							else	*cl++=0.0;							smask<<=1;							}						thisShortCl++;						}					smask=1;					for(int pshorit=0;pshorit<currNStatesInLastShort;pshorit++)						{if(*thisShortCl&smask)								*cl++=1.0;						else	*cl++=0.0;						smask<<=1;						}					}			thisShortCl++;			}}TerminalNodeLikeAttr::TerminalNodeLikeAttr(short *c,Model *m)	: LikeAttr(m){	CharsInShorts=c;	OStates=NULL;	OStatesCL=NULL;#ifdef BYARRAYOFOBSSTATES	#ifdef CONDLIKEVERSION			//this implementation only works if there is one char per partition		assert(0);// shouldn't get here in CODONHACK MODE ,if so need to worry about the shrinking of the SSRFCodonSubMod		nObsStates=0;		int nstates=m->GetNStates();		int ShortPerChar=m->NumShortsPerCharacter();		int NStatesInLastShort=m->NumStatesInLastShort();		short smask;		bool allstates=true;		for(int shorit=0;shorit<ShortPerChar-1;shorit++)			{smask=1;			for(int dns=0;dns<BITSPERSHORT;dns++)					{if(CharsInShorts[shorit]&smask)						nObsStates++;					else	allstates=false;					smask<<=1;					}			}		smask=1;		for(int pshorit=0;pshorit<NStatesInLastShort;pshorit++)			{if(CharsInShorts[ShortPerChar-1]&smask)						nObsStates++;			else		allstates=false;			smask<<=1;			}				if(allstates)			{assert(nObsStates==nstates);			nObsStates=0;			}		else			{assert(nObsStates>0);			OStatesCL=new double[nstates];			for(int shorit=0;shorit<ShortPerChar-1;shorit++)				{smask=1;				for(int dns=0;dns<BITSPERSHORT;dns++)						{if(CharsInShorts[shorit]&smask)							OStatesCL[shorit*BITSPERSHORT+dns]=Multiplier;						else OStatesCL[shorit*BITSPERSHORT+dns]=0.0;						smask<<=1;						}				}			smask=1;			for(int pshorit=0;pshorit<NStatesInLastShort;pshorit++)				{if(CharsInShorts[ShortPerChar-1]&smask)					OStatesCL[(ShortPerChar-1)*BITSPERSHORT+pshorit]=Multiplier;				else	OStatesCL[(ShortPerChar-1)*BITSPERSHORT+pshorit]=0.0;				smask<<=1;				}			}	#else		//this implementation only works if there is one char per partition		nObsStates=0;		int nstates=m->GetNStates();		int ShortPerChar=m->NumShortsPerCharacter();		int NStatesInLastShort=m->NumStatesInLastShort();		short smask;		bool allstates=true;		for(int shorit=0;shorit<ShortPerChar-1;shorit++)			{smask=1;			for(int dns=0;dns<BITSPERSHORT;dns++)					{if(CharsInShorts[shorit]&smask)						nObsStates++;					else	allstates=false;					smask<<=1;					}			}		smask=1;		for(int pshorit=0;pshorit<NStatesInLastShort;pshorit++)			{if(CharsInShorts[ShortPerChar-1]&smask)						nObsStates++;			else		allstates=false;			smask<<=1;			}				if(allstates)			{assert(nObsStates==nstates);			nObsStates=0;			}		else			{if(nObsStates<1)				throw MTHException("Taxon without any state");			int currst=0;			OStates=new int[nObsStates];			for(int shorit=0;shorit<ShortPerChar-1;shorit++)				{smask=1;				for(int dns=0;dns<BITSPERSHORT;dns++)						{if(CharsInShorts[shorit]&smask)							{OStates[currst]=shorit*BITSPERSHORT+dns;							currst++;							}						smask<<=1;						}				}			smask=1;			for(int pshorit=0;pshorit<NStatesInLastShort;pshorit++)				{if(CharsInShorts[ShortPerChar-1]&smask)					{OStates[currst]=(ShortPerChar-1)*BITSPERSHORT+pshorit;					currst++;					}				smask<<=1;				}			assert(currst==nObsStates);			}	#endif	#else	assert(0);// shouldn't get here in CODONHACK MODE ,if so need to worry about the shrinking of the SSRFCodonSubMod		#endif}void TerminalNodeLikeAttr::RecodeDueToModelSizeChange(){	int maxNStates=((SSRFCodonSubMod *) model)->GetMaxNStates();	int maxShortPerChar=(int) ceil((((double) maxNStates)-.1)/16.0);	int maxNStatesInLastShort=1+((maxNStates-1)%16);	int nstates=model->GetNStates();	int ShortPerChar=model->NumShortsPerCharacter();	int NStatesInLastShort=model->NumStatesInLastShort();		int *OrigLocToGlob=((SSRFCodonSubMod *) model)->GetOrigLocToGlob();	int *CurrentGlobToLoc=((SSRFCodonSubMod *) model)->GetCurrentGlobToLoc();	int * tempOLTG;	short *tempCIS;	//CharsInShorts is coded as the original (non culled sub model) coding	short smask;	bool allstates=true;	tempCIS=CharsInShorts;	tempOLTG=OrigLocToGlob;	nObsStates=0;	for(int shorit=0;shorit<maxShortPerChar-1;shorit++)		{smask=1;		for(int dns=0;dns<BITSPERSHORT;dns++)			{if(CurrentGlobToLoc[*tempOLTG++]>=0)//-1 is the code for a codon that is not in this model (its amino acid is freq0)				{if((*tempCIS)&smask)					nObsStates++;				else	allstates=false;				}			smask<<=1;			}		tempCIS++;		}	smask=1;	for(int pshorit=0;pshorit<maxNStatesInLastShort;pshorit++)		{if(CurrentGlobToLoc[*tempOLTG++]>=0)//-1 is the code for a codon that is not in this model (its amino acid is freq0)			{if((*tempCIS)&smask)				nObsStates++;			else	allstates=false;			}		smask<<=1;		}		if(allstates)		{assert(nObsStates==nstates);		nObsStates=0;		}	else		{if(nObsStates<1)			throw TaxonWithoutStateException("Taxon without any state");		int currst=0;		tempCIS=CharsInShorts;		tempOLTG=OrigLocToGlob;		int *tempOStates=&(OStates[0]);		for(int shorit=0;shorit<maxShortPerChar-1;shorit++)			{smask=1;			for(int dns=0;dns<BITSPERSHORT;dns++)				{if(CurrentGlobToLoc[*tempOLTG]>=0)//-1 is the code for a codon that is not in this model (its amino acid is freq0)					{if((*tempCIS)&smask)						*tempOStates++=CurrentGlobToLoc[*tempOLTG];					}				tempOLTG++;				smask<<=1;				}			tempCIS++;			}		smask=1;		for(int pshorit=0;pshorit<maxNStatesInLastShort;pshorit++)			{if(CurrentGlobToLoc[*tempOLTG]>=0)//-1 is the code for a codon that is not in this model (its amino acid is freq0)				{if((*tempCIS)&smask)					*tempOStates++=CurrentGlobToLoc[*tempOLTG];				}			tempOLTG++;			smask<<=1;			}		}}TreeLikeAttr::TreeLikeAttr(int n,Model *m,int *isC,short *nR,short *cc)//	: LikeAttr(m){	model=m;	nChar=n;	isConstant=isC;	nTimesThisPatternOccurs=nR;	ownsBrLens=false;	constChars=cc;	needsToBeRescored=true;	if(m)		{Pmat=m->GetPmat();		freq=m->GetStateFreqs();		nStates=m->GetNStates();		nRateCat=m->GetNRateCats();		likeBelow=new double[nChar*nStates*nRateCat];		likeAbove=new double[nChar*nStates*nRateCat];		int et=m->GetEncodingType();		nColPerChar=NumColumnsPerCharacter(m->GetEncodingType());		if(et==EncodingType(SubModMitoCodons) || et==EncodingType(SubModNucCodons))			{nspc=model->NumShortsPerCharacter();			nsilc=model->NumStatesInLastShort();			}		else			{nspc=NumShortsPerCharacter(et);			nsilc=NumStatesInLastShort(et);			}		prevl=new double[nChar];#ifdef	DZRATES		thisl=new double[nRateCat*nChar];#else		thisl=new double[nChar];#endif		}	else	{Pmat=NULL;//should be used only when temporarily instantiating TreeLikeAttr to read branch lengths in from a file			freq=NULL;			nStates=0;			nRateCat=0;			likeBelow=NULL;			likeAbove=NULL;			prevl=NULL;			thisl=NULL;			}}#ifdef DZRATESdouble TreeLikeAttr::GetOneBranchLike(vector<IntSet *> *rateSets,PositiveParameter *Inpblen,PositiveParameter *InpblenMod){		double *la,*lb,*isConst;	la=likeAbove;	lb=likeBelow;	currentLikelihood=0.0;	if(InpblenMod)		model->UpdatePmat(Inpblen->val*InpblenMod->val/(1.0-model->GetPInv()));	else			model->UpdatePmat(Inpblen->val/(1.0-model->GetPInv()));		double ***pm,*desLike,*ancLike,loglike,*tempLike;	double *thisDesRateState,pinv,rateLike,stateRateLike;	short *nReps;	int toNextChar=nStates*nRateCat;	double tempcl;	double *thisLike;	tempLike=thisLike=new double [LikeAttr::currNChar*LikeAttr::currNRateCats];		pm=model->GetPmat();	desLike=likeAbove;	ancLike=likeBelow;	pinv=model->GetPInv();	assert(pinv<SMALLDOUBLE);				assert(pinv==0.0);	assert(LikeAttr::currNRateCats!=1);	for(int nc=0;nc<LikeAttr::currNChar;nc++)		{		for(int nr=0;nr<LikeAttr::currNRateCats;nr++)			{rateLike=0.0;			for(int ans=0;ans<LikeAttr::currNStates;ans++)				{stateRateLike=0.0;				for(int dns=0;dns<LikeAttr::currNStates;dns++)					stateRateLike+=desLike[(nr+nc*LikeAttr::currNRateCats)*LikeAttr::currNStates+dns]*pm[nr][ans][dns];				rateLike+=stateRateLike*ancLike[(nr+nc*LikeAttr::currNRateCats)*LikeAttr::currNStates+ans];				}			(*tempLike++)=rateLike;			}		}				for(vector<IntSet *>::iterator rsIt=rateSets->begin();rsIt!=rateSets->end();rsIt++)		{double  x=0.0;		for(int nr=0;nr<LikeAttr::currNRateCats;nr++)			{double y=1.0/((double) LikeAttr::currNRateCats);			for(IntSet::iterator charIt=(*rsIt)->begin();charIt!=(*rsIt)->end();charIt++)				{double z=thisLike[((*charIt)*LikeAttr::currNRateCats)+nr];				y*=z;				}			x+=y;			}		currentLikelihood-=log(x);		}	delete []thisLike;	return currentLikelihood;}		#elsedouble TreeLikeAttr::GetOneBranchLike(PositiveParameter *Inpblen,PositiveParameter *InpblenMod){		//SHOULDN't this be at the SetOfTreeLikeAttr Level	double *la,*lb,*isConst;	la=likeAbove;	lb=likeBelow;	currentLikelihood=0.0;	if(InpblenMod)		model->UpdatePmat(Inpblen->val*InpblenMod->val/(1.0-model->GetPInv()));	else			model->UpdatePmat(Inpblen->val/(1.0-model->GetPInv()));		double ***pm,*thispmel,*thisAncRateState,*thisDesRate,thisSiteLike,thisRateLike,thisAncStateLike;	double *thisDesRateState,pinv;	short *nReps;	int toNextChar=nStates*nRateCat;	double tempcl;		pm=model->GetPmat();	nReps=nTimesThisPatternOccurs;	thisDesRate=likeAbove;	thisAncRateState=likeBelow;	pinv=model->GetPInv();	if(pinv<SMALLDOUBLE)		{for(int nc=0;nc<nChar;nc++)			{thisSiteLike=0.0;			thispmel=**pm;			for(int nr=0;nr<nRateCat;nr++)				{thisRateLike=0.0;				for(int ns=0;ns<nStates;ns++)					{thisAncStateLike=0.0;					thisDesRateState=thisDesRate;					for(int dns=0;dns<nStates;dns++)						thisAncStateLike+=(*thisDesRateState++)*(*thispmel++);					thisRateLike+=(*thisAncRateState++)*thisAncStateLike;					}				thisDesRate=thisDesRateState;				thisSiteLike+=thisRateLike;				}			currentLikelihood-=(*nReps++)*log(thisSiteLike/nRateCat);			}		}	else		{int *isConst;		isConst=isConstant;		short *constPat;		double oneMinusPinv=1.0-pinv;		constPat=constChars;		for(int nc=0;nc<nChar;nc++)			{thisSiteLike=0.0;			thispmel=**pm;			for(int nr=0;nr<nRateCat;nr++)				{thisRateLike=0.0;				for(int ns=0;ns<nStates;ns++)					{thisAncStateLike=0.0;					thisDesRateState=thisDesRate;					for(int dns=0;dns<nStates;dns++)						thisAncStateLike+=(*thisDesRateState++)*(*thispmel++);					thisRateLike+=(*thisAncRateState++)*thisAncStateLike;					}				thisDesRate=thisDesRateState;				thisSiteLike+=thisRateLike;				}			thisSiteLike/=nRateCat;			thisSiteLike*=oneMinusPinv;			if(*isConst++) 									{int ns;short smask;				ns=-1;				for(int shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)					{smask=1;					for(int dns=0;dns<BITSPERSHORT;dns++)						{ns++;						if(*(constPat)&smask)							thisSiteLike+=*freq[ns]*pinv;						smask<<=1;						}					constPat++;					}				smask=1;				for(int shorit=0;shorit<LikeAttr::currNStatesInLastShort;shorit++)					{ns++;					if(*(constPat)&smask)						thisSiteLike+=*freq[ns]*pinv;					smask<<=1;					}				constPat++;				}			currentLikelihood-=(*nReps++)*log(thisSiteLike);			}		}	return currentLikelihood;}		#endifTreeLikeAttr::~TreeLikeAttr(){	delete [] likeBelow;	delete [] likeAbove;	delete [] thisl;	delete [] prevl;	for(int i=0;i<bLenModifiers.size();i++)		if(ownsBLenModifier[i])			delete bLenModifiers[i];	//data partition is responsible for deleting isConstant ,constChars, and nTimesThisPatternOccurs}Model* TreeLikeAttr::GetModel()	{return model;}void TreeLikeAttr::UpdatePmat(double x)	{	//assert(SharePmatMemory());	model->UpdatePmat(x);	//else model->UpdatePmat(x,**Pmat);}double ***TreeLikeAttr::getPmat()	{return Pmat;}SetOfLikeAttr::SetOfLikeAttr(int i){	assert(i>0);	nparts=i;	likeAttribs=new LikeAttr**[nparts];	nmods=new int[nparts];	for(int j=0;j<nparts;j++)		{likeAttribs[j]=NULL;		nmods[j]=0;		}	nmodparts=0;}SetOfLikeAttr::~SetOfLikeAttr(){	assert(nmods && likeAttribs);	for(int i=0;i<nparts;i++)		{		assert(likeAttribs[i]);		for(int j=0;j<nmods[i];j++)			{assert(likeAttribs[i][j]);			delete likeAttribs[i][j];			}		delete [] likeAttribs[i];		}	delete	[]likeAttribs;	delete [] nmods;	}void SetOfLikeAttr::SetNumModsInPart(int partnum,int modnum){	nmodparts+=(modnum-nmods[partnum]);	for(int i=0;i<nmods[partnum];i++)		delete likeAttribs[partnum][i];	delete [] likeAttribs[partnum];	nmods[partnum]=modnum;	likeAttribs[partnum]=new LikeAttr*[modnum];	for(int i=0;i<modnum;i++)		*(likeAttribs[partnum]+i)=NULL;}void SetOfLikeAttr::AddLikeAtt(int p,int m,LikeAttr *la){	assert(p<nparts);	assert(m<nmods[p]);	delete likeAttribs[p][m];	likeAttribs[p][m]=la;}SetOfLikeAttr *SetOfLikeAttr::Copy(){	SetOfLikeAttr *tempSOLA;	tempSOLA=new SetOfLikeAttr(nparts);	for(int i=0;i<nparts;i++)		{nmodparts+=nmods[i];		tempSOLA->nmods[i]=nmods[i];		tempSOLA->likeAttribs[i]=new LikeAttr*[nmods[i]];		for(int j=0;j<nmods[i];j++)			tempSOLA->likeAttribs[i][j]=likeAttribs[i][j]->Copy();		}}	SetOfTreeLikeAttr::SetOfTreeLikeAttr(int i)//	: SetOfLikeAttr(i){	assert(i>0);	nparts=i;	likeAttribs=new TreeLikeAttr**[nparts];	nmods=new int[nparts];	for(int j=0;j<nparts;j++)		{likeAttribs[j]=NULL;		nmods[j]=0;		}	nmodparts=0;	nChar=new int[i];	nStates=new int[i];	nRateCats=new int[i];	prevLArr=new double*[i];	thisLArr=new double*[i];	for(int i=0;i<nparts;i++)		{prevLArr[i]=NULL;		thisLArr[i]=NULL;		}	prevL=new double[i];	thisL=new double[i];#ifdef CODONHACK	thisLMult=new double[i];#endif	for(int j=0;j<i;j++)		thisLMult[j]=thisL[j]=prevL[j]=0.0;	packingType=new int[i];	packingIndex=new int[i];	modelMixingParam=new FreqParamGroup *[i];#ifdef DZRATES	rateSets=NULL;#endif}	void SetOfTreeLikeAttr::FinishedAddingModels(int partnum,int pi){	assert(likeAttribs[partnum][pi]);	Model *temp;	temp=likeAttribs[partnum][pi]->GetModel();	packingIndex[partnum]=pi;	packingType[partnum]=temp->GetEncodingType();	nChar[partnum]=likeAttribs[partnum][pi]->GetNChar();	nStates[partnum]=likeAttribs[partnum][pi]->GetNStates();	nRateCats[partnum]=likeAttribs[partnum][pi]->GetNRateCats();	prevLArr[partnum]=new double(nChar[partnum]);	thisLArr[partnum]=new double(nChar[partnum]);	}void SetOfTreeLikeAttr::InitializeModelMixingParams(){		for(int i=0;i<nparts;i++)		if(nmods[i]>1)			{assert(modelMixingParam && modelMixingParam[i]);			modelMixingParam[i]->Initialize();			}}void SetOfTreeLikeAttr::InitializeLikeAttrStatics(int partnum,int modn){	LikeAttr::currNChar=GetNChar(partnum,modn);	LikeAttr::currNStates=GetNStates(partnum,modn);	LikeAttr::currShortPerChar=GetNShortsPerChar(partnum,modn);	LikeAttr::currNRateCats=GetNRateCats(partnum,modn);	LikeAttr::currNStatesInLastShort=GetNStatesInLastShort(partnum,modn);	LikeAttr::currModelDirty=true;//TEMPORARY}			double SetOfTreeLikeAttr::GetLikelihoodFromCondLike(SetOfLikeAttr* rootSet,int partnum,bool onlyScoreDirty){	//assumes initialization of likeAttr statics and conditional likelihood of rootset	prevL[partnum]=thisL[partnum];	if(nmods[partnum]==1)		{if(!onlyScoreDirty || likeAttribs[partnum][0]->needsToBeRescored)			thisL[partnum]=GetLikelihoodFromCondLike(rootSet->GetLikeAtt(partnum,0),GetLikeAtt(partnum,0));		else	thisL[partnum]=likeAttribs[partnum][0]->currentLikelihood;		return thisL[partnum];		}	assert(LikeAttr::Multiplier==1.0);//this function needs to change if overflow multipliers are allowed to change by char or model#ifdef DZRATES	throw	MTHException("Entered unwritten code GetLikelihoodFromCondLike" );#endif	double *thisCharArr;//swap this partitions like array	thisCharArr=prevLArr[partnum];	prevLArr[partnum]=thisLArr[partnum];	thisLArr[partnum]=thisCharArr;	#ifdef CHARBYCHAR	throw	MTHException("Entered unwritten code GetLikelihoodFromCondLike2" );#else	for(int modn=0;modn<nmods[partnum];modn++)		if(onlyScoreDirty || likeAttribs[partnum][modn]->needsToBeRescored)			GetLikelihoodFromCondLike(rootSet->GetLikeAtt(partnum,modn),GetLikeAtt(partnum,modn));#endif//Assumes that if	for(int modn=0;modn<nmods[partnum];modn++)		{double pthism;		int nmodchperc;		double *thisModArr;		pthism=(modelMixingParam[partnum]->GetParameter(modn))->val;		nmodchperc=NumColumnsPerCharacter(packingType[partnum])/NumColumnsPerCharacter(likeAttribs[partnum][modn]->GetModel()->GetEncodingType());		assert(nmodchperc>=1);		thisModArr=likeAttribs[partnum][modn]->GetThisLikeArray(false);		thisCharArr=thisLArr[partnum];		if(modn==0)			{if(nmodchperc)				for(int nc=0;nc<LikeAttr::currNChar;nc++)					*thisCharArr++=pthism*(*thisModArr++);			else				for(int nc=0;nc<LikeAttr::currNChar;nc++)					{double temp;					temp=1.0;					for(int nmcpc=0;nmcpc<nmodchperc;nmcpc++)						temp*=(*thisModArr++);					*thisCharArr++=pthism*temp;					}			}		else			{if(nmodchperc)				for(int nc=0;nc<LikeAttr::currNChar;nc++)					(*thisCharArr++)+=pthism*(*thisModArr++);			else				for(int nc=0;nc<LikeAttr::currNChar;nc++)					{double temp;					temp=1.0;					for(int nmcpc=0;nmcpc<nmodchperc;nmcpc++)						temp*=(*thisModArr++);					(*thisCharArr++)+=pthism*temp;					}			}		}		thisCharArr=thisLArr[partnum];	thisL[partnum]=0.0;		short *nReps=likeAttribs[partnum][packingIndex[partnum]]->GetNReps();	for(int nc=0;nc<LikeAttr::currNChar;nc++)		thisL[partnum]-=(*nReps++)*log(*thisCharArr++);	return thisL[partnum];}	#ifdef CHARBYCHARdouble SetOfTreeLikeAttr::GetLikelihoodFromCondLike(LikeAttr * rootLA,TreeLikeAttr * treeLA){		// TEMPORARY CODONHACK this function needs to change if overflow multipliers are allowed to change by char or model	double loglike=0.0,ratelike;	static double **sfreq,pinv,*charlike,oneMinusPinv;	double *rootcl;	static short *nReps;	if(LikeAttr::currCharIndex==0)		{charlike=treeLA->GetThisLikeArray(true);		treeLA->currentLikelihood=0.0;		nReps=treeLA->GetNReps();		sfreq=treeLA->GetStateFreqs();		pinv=(treeLA->GetModel())->GetPInv();		oneMinusPinv=1.0-pinv;		}	rootcl=rootLA->GetCondLikeArray();	/*TEMPORARY HALPERN	*charlike=0.0;	for(int ns=0;ns<LikeAttr::currNStates;ns++)		{*charlike+=(*rootcl++);		}	return -1.0*log(*charlike);*/			loglike=0.0;		if(pinv==0.0)		{if(LikeAttr::currNRateCats==1)			//no gamma rates or pinv			{(*charlike)=0.0;			for(int ns=0;ns<LikeAttr::currNStates;ns++)				(*charlike)+=*sfreq[ns]*(*rootcl++);			loglike-=(*nReps++)*log(*charlike++);			}		else	//Gamma Rates, but no pinvar			{(*charlike)=0.0;			for(int nr=0;nr<LikeAttr::currNRateCats;nr++)				{ratelike=0.0;				for(int ns=0;ns<LikeAttr::currNStates;ns++)					ratelike+=*sfreq[ns]*(*rootcl++);				(*charlike)+=ratelike;				}			(*charlike)/=LikeAttr::currNRateCats;			loglike-=(*nReps++)*log(*charlike++);			}		}	else		{		static int *couldBeConstant;		static short *constPat; 		if(LikeAttr::currCharIndex==0)			{couldBeConstant=treeLA->GetIsConstant();			constPat=treeLA->GetConstPats();			}		int cbc;		if(LikeAttr::currNRateCats==1)			//pinv but no gamma rates 			{(*charlike)=0.0;			for(int ns=0;ns<LikeAttr::currNStates;ns++)				(*charlike)+=*sfreq[ns]*(*rootcl++);			(*charlike)*=oneMinusPinv;			cbc=*couldBeConstant++;			if(cbc) 				{int ns;				ns=-1;				short smask;				for(int shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)					{smask=1;					for(int dns=0;dns<BITSPERSHORT;dns++)						{ns++;						if(*(constPat)&smask)							(*charlike)+=*sfreq[ns]*pinv;						smask<<=1;						}					constPat++;					}				smask=1;				for(int shorit=0;shorit<LikeAttr::currNStatesInLastShort;shorit++)					{ns++;					if(*(constPat)&smask)						(*charlike)+=*sfreq[ns]*pinv;					smask<<=1;					}				constPat++;				}			loglike-=(*nReps++)*log(*charlike++);			}		else	//Gamma Rates and pinvar			{(*charlike)=0.0;			for(int nr=0;nr<LikeAttr::currNRateCats;nr++)				{ratelike=0.0;				for(int ns=0;ns<LikeAttr::currNStates;ns++)					ratelike+=*sfreq[ns]*(*rootcl++);				(*charlike)+=ratelike;				}			(*charlike)/=LikeAttr::currNRateCats;			(*charlike)*=oneMinusPinv;			cbc=*couldBeConstant++;			if(cbc) 									{int ns;				ns=-1;				short smask;				for(int shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)					{smask=1;					for(int dns=0;dns<BITSPERSHORT;dns++)						{ns++;						if(*(constPat)&smask)							(*charlike)+=*sfreq[ns]*pinv;						smask<<=1;						}					constPat++;					}				smask=1;				for(int shorit=0;shorit<LikeAttr::currNStatesInLastShort;shorit++)					{ns++;					if(*(constPat)&smask)						(*charlike)+=*sfreq[ns]*pinv;					smask<<=1;					}				constPat++;				}			loglike-=(*nReps++)*log(*charlike++);			}		}	treeLA->currentLikelihood+=loglike;	if(LikeAttr::currCharIndex==LikeAttr::currNChar-1)		treeLA->needsToBeRescored=false; 			return loglike;				}#else#ifdef DZRATESdouble SetOfTreeLikeAttr::GetLikelihoodFromCondLike(LikeAttr * rootLA,TreeLikeAttr * treeLA){	throw	MTHException("Entered unwritten code GetLikelihoodFromCondLike3" );//this function needs to change if overflow multipliers are allowed to change by char or model	double *rootcl,**sfreq,loglike=0.0,*charlike,ratelike,pinv,oneMinusPinv;	int *couldBeConstant;	short *nReps;		rootcl=rootLA->GetCondLikeArray();	sfreq=treeLA->GetStateFreqs();		charlike=treeLA->GetThisLikeArray(true);		pinv=(treeLA->GetModel())->GetPInv();	oneMinusPinv=1.0-pinv;		loglike=0.0;	assert(pinv==0.0);	assert(LikeAttr::currNRateCats!=1);	for(int nc=0;nc<LikeAttr::currNChar;nc++)		{(*charlike)=0.0;		for(int nr=0;nr<LikeAttr::currNRateCats;nr++)			{ratelike=0.0;			for(int ns=0;ns<LikeAttr::currNStates;ns++)				ratelike+=*sfreq[ns]*(*rootcl++);			(*charlike++)=ratelike;			}		}				charlike=treeLA->GetThisLikeArray(true);		for(vector<IntSet *>::iterator rsIt=rateSets->begin();rsIt!=rateSets->end();rsIt++)		{double x=0.0;int charnum;		for(int nr=0;nr<LikeAttr::currNRateCats;nr++)			{double y=1/((double) LikeAttr::currNRateCats);			for(IntSet::iterator charIt=(*rsIt)->begin();charIt!=(*rsIt)->end();charIt++)				{charnum=*charIt;				y*=charlike[((*charIt)*LikeAttr::currNRateCats)+nr];				}							x+=y;			}		loglike-=log(x);		}/*	else		{		couldBeConstant=treeLA->GetIsConstant();		short *constPat=treeLA->GetConstPats();		int cbc;		if(LikeAttr::currNRateCats==1)			//pinv but no gamma rates 			for(int nc=0;nc<LikeAttr::currNChar;nc++)				{(*charlike)=0.0;				for(int ns=0;ns<LikeAttr::currNStates;ns++)					(*charlike)+=*sfreq[ns]*(*rootcl++);				(*charlike)*=oneMinusPinv;				cbc=*couldBeConstant++;				if(cbc) 					{int ns;					ns=-1;					short smask;					for(int shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{ns++;							if(*(constPat)&smask)								(*charlike)+=*sfreq[ns]*pinv;							smask<<=1;							}						constPat++;						}					smask=1;					for(int shorit=0;shorit<LikeAttr::currNStatesInLastShort;shorit++)						{ns++;						if(*(constPat)&smask)							(*charlike)+=*sfreq[ns]*pinv;						smask<<=1;						}					constPat++;					}				loglike-=(*nReps++)*log(*charlike++);				}		else	//Gamma Rates and pinvar			for(int nc=0;nc<LikeAttr::currNChar;nc++)				{(*charlike)=0.0;				for(int nr=0;nr<LikeAttr::currNRateCats;nr++)					{ratelike=0.0;					for(int ns=0;ns<LikeAttr::currNStates;ns++)						ratelike+=*sfreq[ns]*(*rootcl++);					(*charlike)+=ratelike;					}				(*charlike)/=LikeAttr::currNRateCats;				(*charlike)*=oneMinusPinv;				cbc=*couldBeConstant++;				if(cbc) 										{int ns;					ns=-1;					short smask;					for(int shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{ns++;							if(*(constPat)&smask)								(*charlike)+=*sfreq[ns]*pinv;							smask<<=1;							}						constPat++;						}					smask=1;					for(int shorit=0;shorit<LikeAttr::currNStatesInLastShort;shorit++)						{ns++;						if(*(constPat)&smask)							(*charlike)+=*sfreq[ns]*pinv;						smask<<=1;						}					constPat++;					}				loglike-=(*nReps++)*log(*charlike++);				}		}	*/	treeLA->needsToBeRescored=false; 				treeLA->currentLikelihood=loglike;	loglike-=ntax*log(LikeAttr::Multiplier)		;	return loglike;				}#elsedouble SetOfTreeLikeAttr::GetLikelihoodFromCondLike(LikeAttr * rootLA,TreeLikeAttr * treeLA){	throw	MTHException("Entered unwritten code GetLikelihoodFromCondLike4" );//this function needs to change if overflow multipliers are allowed to change by char or model	double *rootcl,**sfreq,loglike=0.0,*charlike,ratelike,pinv,oneMinusPinv;	int *couldBeConstant;	short *nReps;		rootcl=rootLA->GetCondLikeArray();		sfreq=treeLA->GetStateFreqs();	charlike=treeLA->GetThisLikeArray(true);	pinv=(treeLA->GetModel())->GetPInv();	oneMinusPinv=1.0-pinv;	nReps=treeLA->GetNReps();	loglike=0.0;	if(pinv==0.0)		{if(LikeAttr::currNRateCats==1)			//no gamma rates or pinv			for(int nc=0;nc<LikeAttr::currNChar;nc++)				{(*charlike)=0.0;				for(int ns=0;ns<LikeAttr::currNStates;ns++)					(*charlike)+=*sfreq[ns]*(*rootcl++);				loglike-=(*nReps++)*log(*charlike++);				}		else	//Gamma Rates, but no pinvar			for(int nc=0;nc<LikeAttr::currNChar;nc++)				{(*charlike)=0.0;				for(int nr=0;nr<LikeAttr::currNRateCats;nr++)					{ratelike=0.0;					for(int ns=0;ns<LikeAttr::currNStates;ns++)						ratelike+=*sfreq[ns]*(*rootcl++);					(*charlike)+=ratelike;					}				(*charlike)/=LikeAttr::currNRateCats;				loglike-=(*nReps++)*log(*charlike++);				}		}	else		{		couldBeConstant=treeLA->GetIsConstant();		short *constPat=treeLA->GetConstPats();		int cbc;		if(LikeAttr::currNRateCats==1)			//pinv but no gamma rates 			for(int nc=0;nc<LikeAttr::currNChar;nc++)				{(*charlike)=0.0;				for(int ns=0;ns<LikeAttr::currNStates;ns++)					(*charlike)+=*sfreq[ns]*(*rootcl++);				(*charlike)*=oneMinusPinv;				cbc=*couldBeConstant++;				if(cbc) /*	THE NON POINTER ARITHMATIC VERSION OF GETTING THE STATES THAT COULD BE INVARIANT					{int shorit,ns;					ns=-1;					short smask;					for(shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{ns++;							if(*(constPat+cbc*LikeAttr::currShortPerChar+shorit*BITSPERSHORT)&smask)								(*charlike)+=*sfreq[ns]*pinv;							smask<<=1;							}						}					smask=1;					for(int pshorit=0;pshorit<LikeAttr::currNStatesInLastShort;pshorit++)						{ns++;						if(*(constPat+(cbc+shorit)*LikeAttr::currShortPerChar)&smask)							(*charlike)+=*sfreq[ns]*pinv;						smask<<=1;						}					}*/					{int ns;					ns=-1;					short smask;					for(int shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{ns++;							if(*(constPat)&smask)								(*charlike)+=*sfreq[ns]*pinv;							smask<<=1;							}						constPat++;						}					smask=1;					for(int shorit=0;shorit<LikeAttr::currNStatesInLastShort;shorit++)						{ns++;						if(*(constPat)&smask)							(*charlike)+=*sfreq[ns]*pinv;						smask<<=1;						}					constPat++;					}				loglike-=(*nReps++)*log(*charlike++);				}		else	//Gamma Rates and pinvar			for(int nc=0;nc<LikeAttr::currNChar;nc++)				{(*charlike)=0.0;				for(int nr=0;nr<LikeAttr::currNRateCats;nr++)					{ratelike=0.0;					for(int ns=0;ns<LikeAttr::currNStates;ns++)						ratelike+=*sfreq[ns]*(*rootcl++);					(*charlike)+=ratelike;					}				(*charlike)/=LikeAttr::currNRateCats;				(*charlike)*=oneMinusPinv;				cbc=*couldBeConstant++;				if(cbc) 										{int ns;					ns=-1;					short smask;					for(int shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{ns++;							if(*(constPat)&smask)								(*charlike)+=*sfreq[ns]*pinv;							smask<<=1;							}						constPat++;						}					smask=1;					for(int shorit=0;shorit<LikeAttr::currNStatesInLastShort;shorit++)						{ns++;						if(*(constPat)&smask)							(*charlike)+=*sfreq[ns]*pinv;						smask<<=1;						}					constPat++;					}/*				Non pointer math version of dealing with pinv					{int shorit,ns;					ns=-1;					short smask;					for(shorit=0;shorit<LikeAttr::currShortPerChar-1;shorit++)						{smask=1;						for(int dns=0;dns<BITSPERSHORT;dns++)							{ns++;							if(*(constPat+cbc*LikeAttr::currShortPerChar+shorit*BITSPERSHORT)&smask)								(*charlike)+=*sfreq[ns]*pinv;							smask<<=1;							}						}					smask=1;					for(int pshorit=0;pshorit<LikeAttr::currNStatesInLastShort;pshorit++)						{ns++;						if(*(constPat+(cbc+shorit)*LikeAttr::currShortPerChar)&smask)							(*charlike)+=*sfreq[ns]*pinv;						smask<<=1;						}					}*/				loglike-=(*nReps++)*log(*charlike++);				}		}	treeLA->needsToBeRescored=false; 				treeLA->currentLikelihood=loglike;	return loglike;				}#endif#endifSetOfTreeLikeAttr::~SetOfTreeLikeAttr(){	for(int i=0;i<nparts;i++)		{delete [] prevLArr[i];		delete [] thisLArr[i];		}	delete [] prevLArr;	delete [] thisLArr;	delete [] prevL;	delete [] thisLArr;	delete [] modelMixingParam;//partitions responsible for deleting the acutal parameters	delete [] nChar;	delete [] nStates;	delete [] nRateCats;	delete [] packingIndex;	delete [] packingType;	assert(nmods && likeAttribs);	for(int i=0;i<nparts;i++)		{		assert(likeAttribs[i]);		for(int j=0;j<nmods[i];j++)			{assert(likeAttribs[i][j]);			delete likeAttribs[i][j];			}		delete [] likeAttribs[i];		}	delete	[]likeAttribs;	delete nmods;}void SetOfTreeLikeAttr::SetNumModsInPart(int partnum,int modnum){	nmodparts+=(modnum-nmods[partnum]);	for(int i=0;i<nmods[partnum];i++)		delete likeAttribs[partnum][i];	delete [] likeAttribs[partnum];	nmods[partnum]=modnum;	likeAttribs[partnum]=new TreeLikeAttr*[modnum];	for(int i=0;i<modnum;i++)		*(likeAttribs[partnum]+i)=NULL;}void SetOfTreeLikeAttr::AddLikeAtt(int p,int m,TreeLikeAttr *la){	assert(p<nparts);	assert(m<nmods[p]);	delete likeAttribs[p][m];	likeAttribs[p][m]=la;}void SetOfTreeLikeAttr::PrintModel(ostream &usrstream){	for(int np=0;np<nparts;np++)		for(int nm=0;nm<nmods[np];nm++)			likeAttribs[np][nm]->GetModel()->PrintPAUPLsetCommand();}