#ifndef _MODEL#define _MODEL#include "basicfuncs.h"#include "matrices.h"#include "encodedchars.h"#include "charencoding.h"#include "complex.h"#include <map>#include "nxsstring.h"#include "linalg.h"#include "MTHException.h"#include "parameter.h"#include "tools.h"#include "CondenseMatrices.h"#include "AdvancedBullDefs.h"#ifdef ELIMINATEALLZEROSclass NeedToRecodeException : public MTHException{};#endifclass BadParams :public MTHException {public: BadParams(const char *p) : MTHException(p) {}};class LinAlgProb :public MTHException {public: LinAlgProb(const char *p) : MTHException(p) {}};class IncompleteModel :public MTHException {public: IncompleteModel(const char *p) : MTHException(p) {}};class BadSettings :public MTHException {public: BadSettings(const char *p) : MTHException(p) {}};class RateManager	{	const static int maxcat=20;	static double defPinv,defGammaShape;		protected:		bool rateHet;	double *rates;	int ngamcat;	Parameter *pinv,*gammashape;	void CalculateRates();		public :	RateManager();//default no rate het	RateManager(int,double); //gamma rates with shape	RateManager(double);//pinv	RateManager(double,int,double); //pinv + gamma shape not specified	~RateManager();	static void set_default(double p,double g)	{		defPinv=p;		defGammaShape=g;		}	virtual void InitializeParameters();	inline int GetNRateCats()	{return ngamcat;}	inline double GetPInv()	{		if(pinv)			return pinv->val;		return 0.0;		}	virtual int	GetNParams()	{int i=0;						if(pinv)	i++;						if(ngamcat>1)	i++;						return i;						}		virtual Parameter *GetParameter(int i)	{assert(i==0 ||i==1);											assert(pinv || gammashape);											if(i==0) return (pinv ? pinv : gammashape);											assert(pinv);//if i=1 there must be both pinv and gammashape											return gammashape;											}};class Model	: public RateManager {	protected :	//std::map<int,double> parameters;	Parameter **param;	double ***pMatrix;//pointer to the matrices, there will ngammacategories of matrices, essentially a vector, but not using STL to allow pointer math	bool pmatcalc;	FreqParamGroup *stateFreqs;		public :		int nstates;	int nparams,nfreeparams, chperst,nfreqParamGroups;		virtual int NumStatesInLastShort()	{throw	MTHException("Entered unwritten code NumStatesInLastShort" );}//written to allow odd coding of SSRFCodonSubModel which overrides	virtual int NumShortsPerCharacter()	{throw	MTHException("Entered unwritten code NumShortsPerCharacter" );}//written to allow odd coding of SSRFCodonSubModel which overrides	virtual void EncodeACharacter(short *dest,short *inp,int datatype,bool keepGap=false) {throw	MTHException("Entered unwritten code Model::EncodeACharacter" );}//written to allow odd coding of SSRFCodonSubModel which overrides#ifdef CODONHACK	virtual void AlertSharedMemory()	{throw	MTHException("Entered unwritten code AlertSharedMemory" );}//written to allow odd coding of SSRFCodonSubModel which overrides	virtual double GetMultiplier()	{throw	MTHException("Entered unwritten code GetMultiplier" );return 1.0;}	virtual void SetMultiplier(double x)	{throw	MTHException("Entered unwritten code SetMultiplier" );}#endif	virtual void PrintPAUPLsetCommand()	{cout<<"lset pinv=";										if(pinv)	cout<<pinv->val;										else	cout<<"0.0";										cout<<" rates=";										if(ngamcat>1)	cout<<"gamma shape="<<gammashape->val<<" ";										else 			cout <<"equal ";										}	virtual void PrintBullLsettingsCommand()	{if(pinv)														{cout<<" , "<<pinv->val;													if(ngamcat>1)															cout<<" , "<<ngamcat<<" , "<<gammashape->val;													cout<<")"<<endl;													}												else 	{if(ngamcat>1)																cout<<" , "<<ngamcat<<" , "<<gammashape->val;														cout<<")"<<endl;														}																						}			 	double ***GetPmat()	{return pMatrix;}	int GetNParams()	{return (nparams+RateManager::GetNParams());}	virtual void UpdatePMatrix(double **pm,double b)=0;	virtual void UpdatePMatrix(double **pm,double b,int onlycol)	{UpdatePMatrix(pm,b);}	virtual void UpdatePmat(double b)	{if(ngamcat>1) 											for(int i=0;i<ngamcat;i++)												UpdatePMatrix(pMatrix[i],*(rates+i)*b);										else UpdatePMatrix(*pMatrix,b);										}	virtual void UpdatePmat(double b,int onlycol)	{if(ngamcat>1) 											for(int i=0;i<ngamcat;i++)												UpdatePMatrix(pMatrix[i],*(rates+i)*b,onlycol);										else UpdatePMatrix(*pMatrix,b,onlycol);										}	virtual void UpdatePmatWithOutSharedMatrix(double b)											{if(ngamcat>1) 											for(int i=0;i<ngamcat;i++)												UpdatePmatWithOutSharedMatrix(pMatrix[i],*(rates+i)*b);										else UpdatePmatWithOutSharedMatrix(*pMatrix,b);										}	virtual void UpdatePmatWithOutSharedMatrix(double b,int onlycol)											{if(ngamcat>1) 											for(int i=0;i<ngamcat;i++)												UpdatePmatWithOutSharedMatrix(pMatrix[i],*(rates+i)*b,onlycol);										else UpdatePmatWithOutSharedMatrix(*pMatrix,b,onlycol);										}	virtual void UpdatePmatWithOutSharedMatrix(double **pmats,double b)	{assert(0);}		virtual void UpdatePmatWithOutSharedMatrix(double **pmats,double b,int onlycol)	{assert(0);}		Model(int n);	Model(int n,double ***pMat);//for memory sharing (only SSRF now)	Model(int n,double pi);//some invariant sites	Model(int n,int ncats, double gamsh);//gamma rates	Model(int n,double pi, int ncats,double gamsh);//gamma +pinvariant	virtual FreqParamGroup *GetFreqParamGroup(int i) {assert(nfreqParamGroups==1 && i==0); return stateFreqs;}//should be overwritten if the model has multiple freqgroups	Parameter *GetParameter(int i) {if(i<nparams) return param[i];											return RateManager::GetParameter(i-nparams);}//should be overwritten if the model has multiple freqgroups	virtual double **GetStateFreqs() {assert(stateFreqs);									return stateFreqs->GetStateFreqs();}	inline	int GetNFreqGroups()	{return nfreqParamGroups;}	virtual int GetEncodingType()=0;	virtual int GetNStates()=0;	virtual void InitializeParameters()=0;/*	inline int GetNRateCats()	{return ngamcat;}	inline double GetPInv()	{		if(pinv)			return pinv->val;		return 0.0;		}*/	virtual void ParameterHasChanged(Parameter *p)	{if(p==gammashape)	CalculateRates();}	virtual void ParameterHasChanged(FreqParamGroup *p)	{throw MTHException("Model::ParameterHasChanged(FreqParamGroup *p) has been called");p++;}	virtual void FreqParamChangesShouldSumToOne(FreqParamGroup *p) {throw MTHException("Model::FreqParamChangesShouldSumToOne(FreqParamGroup *p) has been called");p++;}	~Model();};//Eigen values stuff pinched from John's Mr. Bayesclass ModelWEig : public Model {	protected :	complex **CEigenVector,**CInvEigenVector;	double *REigenValues;	double *ImEigenValues;	double **REigenVector;	double **InvEigenVector;	double **qMatrix;	double *EigInvEigMat;//n x n x n matrix of multiplications to cut down on recalcs	double *EigExp;//n sized vector of exp(Eigenvalues *blen ) to cut down on reallocation of memory everytime blen changes	bool eigencalc,qmatcalc,IsComplex;#ifdef PRESUMMINGCONSTS	int numberOfLastnonZero;	double *preSummed;#endif	public :	ModelWEig(int n);	ModelWEig(int n,double *EIEMPreAlloc);//memory saving by sharing EIEM	ModelWEig(int n,double **vecPreAlloc,double ***matPreAlloc,complex ***complexPreAlloc,double ***pMat);//for shared memory		ModelWEig(int n,double pi);//some invariant sites	ModelWEig(int n,int ncats, double gamsh);//gamma rates	ModelWEig(int n,double pi, int ncats,double gamsh);//gamma +pinvariant	~ModelWEig();		virtual void UpdatePMatrix(double **,double);	virtual void UpdatePMatrix(double **pmats,double blen,int onlycolumn);	virtual void UpdatePmatWithOutSharedMatrix(double **pmats,double b);	virtual void UpdatePmatWithOutSharedMatrix(double **pmats,double blen,int onlycolumn);		virtual void CalculateQ()=0;	virtual void InitializeParameters()=0;	void SharedConstruction(int n);	void ParameterHasChanged(Parameter *p)	{											if(p==gammashape)	CalculateRates();											else if(p!=pinv)	eigencalc=qmatcalc=false;											}	void ParameterHasChanged(FreqParamGroup *p)	{eigencalc=qmatcalc=false;}	};/*class ModelWEigDummy : public ModelWEig	{	public :	ModelWEigDummy(int n)	:  ModelWEig(n)	{}	void CalculateQ() {int i=0;}	void InitializeParameters(){int i=0;}	int GetEncodingType()	{return 1;}	int GetNStates()	{return 1;}};*/#endif