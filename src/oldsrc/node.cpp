#include "node.h"Node::Node(){	ldes=rdes=next=anc=0L;	characters=0L;	blen=NULL;	likeInfo=NULL;	setOfLikeInfo=NULL;	parsInfo=NULL;	setOfParsInfo=NULL;#ifdef CODONHACK	lwa=belowlwa=NULL;#endif	}Node *Node::CopyToShare()//copies pointer, doesn't make a cophy	{ Node *tempno=new Node();		tempno->ldes=ldes;		tempno->rdes=rdes;		tempno->next=next;		tempno->anc=anc;		tempno->setOfLikeInfo=setOfLikeInfo;		tempno->setOfParsInfo=setOfParsInfo;		tempno->likeInfo=likeInfo;		tempno->parsInfo=parsInfo;		tempno->blen=blen;		tempno->characters=characters;		tempno->name=name;		return tempno;	}Node *Node::Copy()//copies pointers to other nodes, but makes new objects for other fields	{ 	Node *tempno=new Node();		tempno->ldes=ldes;		tempno->rdes=rdes;		tempno->next=next;		tempno->anc=anc;		bool done;		cout<<"Using very temporary memory leak prone Node::Copy()"<<endl;		/*if(setOfLikeInfo)			{tempno->setOfLikeInfo=setOfLikeInfo->Copy();			done=false;			if(likeInfo)				for(int i=0;(!done &&i<setOfLikeInfo->GetNParts());i++)					for(int j=0;(!done && j<setOfLikeInfo->GetNModels(i));j++)						if(likeInfo==setOfLikeInfo->GetLikeAtt(i,j))							{tempno->likeInfo=tempno->setOfLikeInfo->GetLikeAtt(i,j);							done=true;							}			}		if(setOfParsInfo)			{tempno->setOfParsInfo=setOfParsInfo->Copy();			done=false;			if(parsInfo)				for(int i=0;(!done &&i<setOfParsInfo->GetNParts());i++)					if(parsInfo==setOfParsInfo->GetParsAtt(i))						{tempno->parsInfo=tempno->setOfParsInfo->GetParsAtt(i);						done=true;						}			}*/		if(blen)			{//check if blen should be a part of some likeattr or ParsAttr			tempno->blen=new double;			*(tempno->blen)=*blen;			}		/*if(characters)			{tempno->characters=characters->Copy();			}*/		tempno->name=name;		return tempno;	}Node *Node::GetAnc(){	return anc;	}	int Node::GetNchar(){	if(characters) return characters->GetNchar();	return 0;	}void Node::WriteTermTax(vector<Node *> *termvec){	Node *tempnode=GetRoot();	tempnode->WriteIfTerm(termvec);	}	void Node::WriteIfTerm(vector<Node *> *termvec){	if(ldes) ldes->WriteIfTerm(termvec);	else termvec->push_back(this);	if(next)next->WriteIfTerm(termvec);	}Node *Node::GetRoot(){	Node *tempnode=this;	while(tempnode->anc) tempnode=tempnode->anc;	return tempnode;	}	Node::~Node(){	//Node isn't responsible for deleting blen, the LikeAttribute will do that even if the node allocates the memory (it will be put into an LikeAttr by the Tree)	delete ldes;	delete next;	delete characters;	delete setOfLikeInfo;	delete setOfParsInfo;	}int Node::GetNtax(){	return GetRoot()->GetNtax(0);	}	int Node::GetNtax(int x){	if(ldes) x=ldes->GetNtax(x);	else x++;	if(next) x=next->GetNtax(x);	return x;	}	Node *Node::MakeDes(){	if(!ldes){		ldes=new Node;		rdes=ldes;		}	else{		rdes->next=new Node;		rdes=rdes->next;		}	rdes->anc=this;	return rdes;	}void Node::SetBranchLengthFromFile(double y){	blen=new double;	*blen=y;	}void Node::SetName(nxsstring n){	name=n;	}	nxsstring Node::GetName(){	return name;	}	void Node::SetChars(EncodedChars *ec){	characters=ec;	}	void Node::SetAllIllegalBranches(double len){	assert(len>=0.0);	if(ldes)	ldes->SetAllIllegalBranches(len);	if(next)	next->SetAllIllegalBranches(len);	if(anc)		{if(!blen)	SetBranchLengthFromFile(len);		if(*blen<0.0) *blen=len;		}}bool Node::NoIllegalBranchLengths(){	if(anc)		{if(!blen)			return false;		if(*blen<0.0)			return false;		}	if(ldes)			if(!ldes->NoIllegalBranchLengths())			return false;	if(next)			if(!next->NoIllegalBranchLengths())			return false;	return true;}	/*Old versionNode **Node::FillRecursiveNodeList(Node **rnl){	if(ldes)	rnl=ldes->FillRecursiveNodeList(rnl);	if(next)	rnl=next->FillRecursiveNodeList(rnl);	*rnl++=this;	*rnl=NULL;	return rnl;}Node **Node::FillRecursiveInternalNodeList(Node **rnl){		if(ldes)	rnl=ldes->FillRecursiveInternalNodeList(rnl);	if(next)	rnl=next->FillRecursiveInternalNodeList(rnl);	if(ldes)	{*rnl++=this;				*rnl=NULL;				}	return rnl;}*/Node **Node::FillRecursiveNodeList(Node **rnl){	if(ldes)	{rnl=ldes->FillRecursiveNodeList(rnl);				Node *tempno=ldes->next;				while(tempno)					{rnl=tempno->FillRecursiveNodeList(rnl);					tempno=tempno->next;					}				}	*rnl++=this;	*rnl=NULL;	return rnl;}Node **Node::FillRecursiveInternalNodeList(Node **rnl){		if(ldes)	{rnl=ldes->FillRecursiveInternalNodeList(rnl);				Node *tempno=ldes->next;				while(tempno)					{rnl=tempno->FillRecursiveInternalNodeList(rnl);					tempno=tempno->next;					}				}	if(ldes)	{*rnl++=this;				*rnl=NULL;				}	return rnl;}void Node::ReplaceSetOfLikeInfoButKeepBranchLen(SetOfLikeAttr *LI){	//should be called only for getting user input brlens, if modifying beware of deletion of LikeAttr which can cause double deletion of blen (if blen is shared between models)	assert(setOfLikeInfo->GetNParts() == 1 && setOfLikeInfo->GetNModels(0)==1);	for(int p=0;p<LI->GetNParts();p++)		for(int m=0;m<LI->GetNModels(p);m++)			LI->GetLikeAtt(p,m)->SetBLenPtr(setOfLikeInfo->GetLikeAtt(0,0)->GetBLenParameterPtr());	setOfLikeInfo->GetLikeAtt(0,0)->DetachBLenPtr();//so we don't destroy the branchlengths	delete setOfLikeInfo; 	setOfLikeInfo=LI;}	void Node::CreateSetOfLikeAttrWithInputBrLensRecurs(){	if(anc) 		assert(blen);	assert(!setOfLikeInfo);//this should only be called to read branch lengths in from a file	setOfLikeInfo= new SetOfLikeAttr(1);	setOfLikeInfo->SetNumModsInPart(0,1);	LikeAttr *templa;	templa=new LikeAttr();	if(blen)		{templa->SetBLen(*blen);		delete blen;		blen=NULL;		}	else	templa->SetBLen(0.0);	setOfLikeInfo->AddLikeAtt(0,0,templa);	likeInfo=templa;	if(ldes)	ldes->CreateSetOfLikeAttrWithInputBrLensRecurs();	if(next) 	next->CreateSetOfLikeAttrWithInputBrLensRecurs();}bool Node::IsGood(void){		if(ldes)	{if(!ldes->IsGood())						return false;				if(!rdes)						return false;				if(rdes==ldes)						return false;				}	if(anc && !next )		if(this!=anc->rdes)			return false;	if(next)	if(!next->IsGood())						return false;	if(rdes&&!ldes)			return false;	return true;}	void Node::Print(ostream &usrstream,bool withBrLen,int level/*=0*/,bool tabbing/*=false*/){	if(tabbing)		{/*if(!anc )	{usrstream<<"(";//add opening parentheses for the whole tree					level++;					}*/		if(ldes)	{					usrstream<<"\n";					for(int i=0;i<level;i++)	usrstream<<"\t";					usrstream<<"(";					level++;					ldes->Print(usrstream,withBrLen,level,true);					assert(ldes!=rdes);					if(withBrLen && anc && likeInfo)						usrstream<<":"<<likeInfo->GetBLenParameterPtr()->val;					level--;					}		else		{nxsstring tempn=name;					BlanksToUnderscores(tempn);					usrstream<<"\n";					for(int i=0;i<level;i++)	usrstream<<"\t";					usrstream<<tempn;					if(withBrLen && likeInfo)						usrstream<<":"<<likeInfo->GetBLenParameterPtr()->val;					}		if(next)	{usrstream<<",";					next->Print(usrstream,withBrLen,level,true);						}		else		{level--;					if(anc)						{usrstream<<"\n";						for(int i=0;i<level;i++)	usrstream<<"\t";						usrstream<<")";						}					}		}	else		{//if(!anc)	usrstream<<"(";//add opening parentheses for the whole tree		if(ldes)	{usrstream<<"(";					ldes->Print(usrstream,withBrLen);					assert(ldes!=rdes);					if(withBrLen && anc && likeInfo)						usrstream<<":"<<likeInfo->GetBLenParameterPtr()->val;					}		else		{nxsstring tempn=name;					BlanksToUnderscores(tempn);					usrstream<<tempn;					if(withBrLen && likeInfo)						usrstream<<":"<<likeInfo->GetBLenParameterPtr()->val;					}		if(next)	{usrstream<<",";					next->Print(usrstream,withBrLen);						}		else		{if(anc)	usrstream<<")";					}		}}int Node::NameSelfAndInternalDescendants(int n){	if(!ldes) return n;	Node *tempno=ldes;	while(tempno)		{n=tempno->NameSelfAndInternalDescendants(n);		tempno=tempno->next;		}	name="";	name+=n;	return n+1;}int Node::GetNumDes(int n,bool termOnly){	Node *tempno=ldes;	while(tempno)		{n=tempno->GetNumDes(n,termOnly);		tempno=tempno->next;		}	if(!ldes || !termOnly)		n++;	return n;}void Node::AddLinesToBeDisplayed(int windowWidth,int midrow,int fircol,int firrow,vector<horizLine> *hlines,vector<vertLine> *vlines)// fircol is the left most column this node can write to and firrow is the highest line it should write to{		//lenght of the vertical line should be such that it hits the ldes and rdes clades in the "middle" 	Node *tempno; 	if(ldes)	 	{assert(ldes->next);//if there is an ldes, there must be at least one other daughter	 	int totalHeightOfClade=0,lheight,rheight;	 	tempno=ldes;	 	while(tempno)	 		{	 		rheight=2*tempno->GetNumDes(0,true);	 		totalHeightOfClade+=rheight;	 		if(tempno==ldes)	lheight=rheight;	 		tempno=tempno->next;			}		assert(totalHeightOfClade);		assert(lheight>1 && rheight>1);		int topOfVert=firrow-1+lheight/2;		int botOfVert=firrow+totalHeightOfClade-1-rheight/2;		int rightH;		if(anc)			{rightH= (int) floor((windowWidth-SPACES_FOR_TAXNAME-fircol)/(1+MaxNumInternalNodesToTip()));			hlines->push_back(horizLine(midrow,fircol+1,fircol+rightH,this));			}		else			//root horizontal line is lenght 1 in middle of clade;			{midrow=(int) floor(((double) (topOfVert+botOfVert))/2.0) - 1;			rightH=1;			hlines->push_back(horizLine(midrow,0,fircol+rightH,this));			}		vlines->push_back(vertLine(topOfVert,botOfVert,fircol+rightH));		tempno=ldes;		int tempH=firrow;		while(tempno)			{int heightOfT=tempno->GetNumDes(0,true);			tempno->AddLinesToBeDisplayed(windowWidth,tempH+heightOfT-1,rightH+fircol,tempH,hlines,vlines);			tempH+=2*heightOfT;			tempno=tempno->next;			}		}	else		hlines->push_back(horizLine(midrow,fircol+1,windowWidth-SPACES_FOR_TAXNAME,this));}int Node::MaxNumInternalNodesToTip(){	if(ldes)		{int t,m=ldes->MaxNumInternalNodesToTip();		Node *tempno=ldes->next;		while(tempno)			{t=tempno->MaxNumInternalNodesToTip();			if(t>m)	m=t;			tempno=tempno->next;			}		return m+1;		}	return 0;}bool Node::MustBeAChangeOnBranchUppass(int charNum){//assumes that uppass are already set and ParsAttr is updated for this partition	assert(parsInfo);	if(anc)			{short *desUp,*ancUp;		desUp=parsInfo->GetUpPass(charNum);		ancUp=(anc->GetParsAtt())->GetUpPass(charNum);		for(int i=0;i<ParsAttr::currShortPerChar;i++)			if(*(desUp+i)&(*(ancUp+i)))				return false;		return true;		}	return false;}int Node::GetDepthTimesNSib(){	if(ldes)		{int maxsofar=ldes->GetDepthTimesNSib();		int nsibsAtThisLevel=0;		Node *tempno;		tempno=ldes->next;		while(tempno)			{nsibsAtThisLevel++;			int thisdes=tempno->GetDepthTimesNSib();			maxsofar= (maxsofar>thisdes ? maxsofar : thisdes );			tempno=tempno->next;			}		return (maxsofar+nsibsAtThisLevel);		}	return 0;}	void Node::DirectToNewAnc(Node* newAnc){//new ancestor must be one of the former descendants		if(anc)		{if(newAnc==ldes)			{if(ldes->next)				ldes=ldes->next;			else				throw MTHException("Node of degree 1 in DirectToNewAnc()");			}		else			{Node *tempno=ldes;			bool done=false;			while(tempno && !done)				{if(tempno->next==newAnc)					{done=true;					tempno->next=newAnc->next;					if(newAnc==rdes)						rdes=tempno;					}				tempno=tempno->next;				}			if(!done)				throw MTHException("New ancestor isn't previous descendant in DirectToNewAnc()");			}		rdes->next=anc;		rdes=anc;		anc->DirectToNewAnc(this);		next=NULL;		anc->SwapBranchLengths(this);		anc=newAnc;		}	else		{if(ldes->next==rdes)			{//only two descendants at the root (disconnect this node )			Node *replacement;			if(newAnc==ldes)				{replacement=rdes;				ldes->AddBranchLengths(rdes);//consolidate all of the branchlength to anc side				}			else				if(newAnc==rdes)					{replacement=ldes;					rdes->AddBranchLengths(ldes);//consolidate all of the branchlength to anc side					}				else					throw MTHException("New ancestor isn't previous descendant in DirectToNewAnc()");			if(newAnc->ldes==this)				throw MTHException("During rerooting, prev anc shouldn't become a node's ldes");			if(newAnc->rdes==this)				newAnc->rdes=replacement;			else				throw MTHException("During rerooting, prev anc should  become a node's rdes");			Node *tempno=newAnc->ldes;			bool done=false;			while(tempno&& !done)				{if(tempno->next==this)					{done=true;					tempno->next=replacement;					}				tempno=tempno->next;				}			newAnc->anc=replacement;			replacement->next=NULL;			replacement->anc=newAnc;			}		else			{//more than two descendants at the root (this node stays in the tree)			if(newAnc==ldes)				{if(ldes->next)					ldes=ldes->next;				else					throw MTHException("Node of degree 1 in DirectToNewAnc()");				}			else				{Node *tempno=ldes;				bool done=false;				while(tempno && !done)					{if(tempno->next==newAnc)						{done=true;						tempno->next=newAnc->next;						if(newAnc==rdes)							rdes=tempno;						}					tempno=tempno->next;					}				if(!done)					throw MTHException("New ancestor isn't previous descendant in DirectToNewAnc()");				}			rdes->next=NULL;			next=NULL;			anc=newAnc;			}				}	}void Node::SwapBranchLengths(Node *sourc){	if(blen)		if(sourc->blen)			*blen=*(sourc->blen);		else *blen=0.0;}void Node::AddBranchLengths(Node *sourc){	if(blen)		if(sourc->blen)			*blen+=*(sourc->blen);}int Node::GetNumBranchesAbove(){	if(ldes)		{Node *tempno=ldes;		int nb=0;		while(tempno)			{nb+=1+tempno->GetNumBranchesAbove();			tempno=tempno->next;			}		return nb;		}	return 0;}int Node::GetHeightAbove(int height){	height++;	if(ldes)		{Node *tempno=ldes;		int tempH=0,HighestNum=0;		while(tempno)			{tempH=tempno->GetHeightAbove(height);			if(tempH>HighestNum)				HighestNum=tempH;			tempno=tempno->next;			}		return HighestNum;		}	return height;}#ifdef CODONHACK/*void Node::SetSubCladeBrLenOptField(int setting){	brLenOptSetting=setting;	Node *tempno=ldes;	while(tempno)		{tempno->SetSubCladeBrLenOptField(setting);		tempno=tempno->next;		}		}int Node::FillNumBranchesAbove(){	if(!ldes || brLenOptSetting&BLOSPSEUDTERM)		numBranchesAbove=0;	else		{Node *tempno=ldes;		numBranchesAbove=0;		while(tempno)			{numBranchesAbove+=1+tempno->FillNumBranchesAbove();			tempno=tempno->next;			}		}	return numBranchesAbove;}int Node::FillNumTermBranchesAbove(){	if(!ldes || brLenOptSetting&BLOSPSEUDTERM)		{numTermBranchesAbove=0;		return 1;		}	else		{Node *tempno=ldes;		numTermBranchesAbove=0;		while(tempno)			{numTermBranchesAbove+=tempno->FillNumTermBranchesAbove();			tempno=tempno->next;			}		}	return numTermBranchesAbove;}void Node::FillNumArraysNeededToOptBranches(int x){	if(ldes && !(brLenOptSetting&BLOSPSEUDTERM))		{//int nsib=-1;		Node *ftempno;		//ftempno=ldes;		//while(ftempno)		//	{nsib++;		//	ftempno=ftempno->next;		//	}		ftempno=ldes;		while(ftempno)			{//FillNumArraysNeededToOptBranches(x+nsib);			ftempno->FillNumArraysNeededToOptBranches(x);			ftempno=ftempno->next;			}		numTempArraysNeeded=x+numBranchesAbove-numTermBranchesAbove;		}	else		numTempArraysNeeded=x;			}Node *Node::GetRootOfNextSubCladeToOptimize(int maxN,int &bestNyet,Node* bestroot){		if(ldes && !(brLenOptSetting&BLOSPSEUDTERM))		{if(numTempArraysNeeded<=maxN)			{if(bestNyet<numBranchesAbove)				{bestNyet=numBranchesAbove;				return this;				}			}		else			{Node *tempno=ldes;			while(tempno)				{bestroot=tempno->GetRootOfNextSubCladeToOptimize(maxN,bestNyet,bestroot);				tempno=tempno->next;				}			}		}	return bestroot;}*/#endifvoid Node::CalculateCondLikeAboveBottomAndStore(double *destCL,int placeInCondLike,LikeWorkArray **workArrays,int numArrays,bool appendToFile/*=true*/){	int i;	if(ldes)		{		double *tempcl=likeInfo->GetCondLikeArray();		ldes->CalculateCondLikeAboveBottomAndStore(tempcl,placeInCondLike,workArrays,numArrays,appendToFile);		for(i=0;i<LikeAttr::currNStates;i++)			destCL[i]=tempcl[i];		Node *tempno=ldes->next;		while(tempno)			{tempno->CalculateCondLikeAboveBottomAndStore(tempcl,placeInCondLike,workArrays,numArrays,appendToFile);			for(i=0;i<LikeAttr::currNStates;i++)				destCL[i]*=tempcl[i];			tempno=tempno->next;			}		for(i=0;i<LikeAttr::currNStates;i++)			tempcl[i]=destCL[i];		if(anc)			{likeInfo->SetArgToCondLikeOfThisSubTree(destCL);			//if(anc->ldes!=this)				//{				if(appendToFile)					{assert(lwa && lwa->owner==this);					}				else					GetCondLikeAboveBottom(workArrays,numArrays,false);				double *tempcl=lwa->condLikes+placeInCondLike;				for(i=0;i<LikeAttr::currNStates;i++) 					*tempcl++=*destCL++;				return;				/*ofstream diskversion; nxsstring fname="zCondLike";  fname+=name;				if(appendToFile) diskversion.open(fname.c_str(),ios::app);				else			diskversion.open(fname.c_str());				diskversion<<setprecision(15);				if(!(diskversion.good())) {cout<<"Problem opening file for "<<name<<endl;  assert(0); }				for(i=0;i<LikeAttr::currNStates;i++) diskversion<<destCL[i]<<"\t";				diskversion<<"\n"; diskversion.close();*/								//}			}		else //root doesn't need to call SetArgToCondLikeOfThisSubTree			{if(appendToFile)				{assert(lwa && lwa->owner==this);				}			else				GetCondLikeAboveBottom(workArrays,numArrays,false);			double *tempcl=lwa->condLikes+placeInCondLike;			for(i=0;i<LikeAttr::currNStates;i++) 				*tempcl++=*destCL++;			return;							/* ofstream diskversion; nxsstring fname="zCondLike"; fname+=name;			if(appendToFile) diskversion.open(fname.c_str(),ios::app);			else			diskversion.open(fname.c_str());			diskversion<<setprecision(15);			if(!(diskversion.good())) {cout<<"Problem opening file for "<<name<<endl;  assert(0); }			for(i=0;i<LikeAttr::currNStates;i++) diskversion<<destCL[i]<<"\t";			diskversion<<"\n"; diskversion.close();*/			}		}	else		{likeInfo->SetArgToCondLikeOfThisSubTree(destCL);		assert(anc);		//if(anc->ldes!=this)		//	{			if(appendToFile)				{assert(lwa && lwa->owner==this);				}			else				GetCondLikeAboveBottom(workArrays,numArrays,false);			double *tempcl=lwa->condLikes+placeInCondLike;			for(i=0;i<LikeAttr::currNStates;i++) 				*tempcl++=*destCL++;			return;							/*ofstream diskversion; nxsstring fname="zCondLike"; fname+=name;			if(appendToFile) diskversion.open(fname.c_str(),ios::app);			else			diskversion.open(fname.c_str());			diskversion<<setprecision(15);			if(!(diskversion.good())) {cout<<"Problem opening file for "<<name<<endl;  assert(0); }			for(i=0;i<LikeAttr::currNStates;i++) diskversion<<destCL[i]<<"\t";			diskversion<<"\n"; diskversion.close();*/		//	}				}		/*		while(*temprnl)		{Node *tempno;double *cl;		tempno=(*temprnl)->ldes;		cl=(*temprnl)->likeInfo->GetCondLikeArray();		tempno->likeInfo->SetArgToCondLikeOfThisSubTree(cl);		tempno=tempno->next;				while(tempno)			{tempno->likeInfo->MultArgByCondLikeOfThisSubTree(cl);			tempno=tempno->next;			}		bool under=true;		for(int ns=0;ns<LikeAttr::currNStates;ns++)			{if(*cl>OVERFLOWCHECK)				throw MTHException("OverFlow");			if(*cl>UNDERFLOWCHECK)				under=false;			*cl++;			}		if(under)			throw MTHException("UnderFlow");		temprnl++;		}	*/}int Node::UpdateBranchesInRecursiveOrder(double *optBranchLengths, int nBranchesToUpdate)	{	//recursive, left first sweep down	if(ldes)		{Node *tempno=ldes;		int totalNBranUpdated=0;		int nBranUpdated=0;		while(tempno)			{nBranUpdated=tempno->UpdateBranchesInRecursiveOrder(optBranchLengths,nBranchesToUpdate);			totalNBranUpdated+=nBranUpdated;			nBranchesToUpdate-=nBranUpdated;			optBranchLengths+=nBranUpdated;			if(nBranchesToUpdate<1)				return totalNBranUpdated;			tempno=tempno->next;			}		if(nBranchesToUpdate>0)			{			#ifdef CODONHACK				setOfLikeInfo->GetLikeAtt(0,0)->SetBLen(*optBranchLengths);			#else				assert(blen);				*blen=*optBranchLengths;			#endif			return totalNBranUpdated+1;			}		}	else		{		#ifdef CODONHACK			setOfLikeInfo->GetLikeAtt(0,0)->SetBLen(*optBranchLengths);		#else			assert(blen);			*blen=*optBranchLengths;		#endif		return 1;		}}#ifdef CODONHACKint Node::currPrioritySetting(2);int Node::NumBranchesOptimized(0);double Node::TreesCurrentLikelihood(1.0);int Node::branchLengthOptLogNum(0);LikeWorkArray *GetFreeWorkArray(LikeWorkArray **storage,int sizeofStorage){	int i;//1 is the ultimate priority, 0 is no priority, otherwise return the lowest above one	for(i=0;i<sizeofStorage;i++)		if(!(storage[i]->owner))			return storage[i];	/*TEMPORARY Commenting out the deassignment of low priority arrays, now you must have enough memory	int lowestAboveOne,lowestAboveOneIndex=-1;	for(i=0;i<sizeofStorage;i++)		{if(!(storage[i]->priority))				{storage[i]->owner=NULL;			return storage[i];			}		if(storage[i]->priority>1)			{if(lowestAboveOneIndex>-1)				{if(storage[i]->priority<lowestAboveOne)					{lowestAboveOne=storage[i]->priority;					lowestAboveOneIndex=i;					}				}			else				{lowestAboveOne=storage[i]->priority;				lowestAboveOneIndex=i;				}			}		}	if(lowestAboveOneIndex>-1)		return storage[lowestAboveOneIndex];		*/	throw NoFreeWorkArrayException();}void MakeFirstArrayProduct(double *p,double *f,double *s,int lenOfArray){	for(int i=0;i<lenOfArray;i++)		*p++=*f++**s++;}void SetFirstArrayEqualToSec(double *f,double *s,int lenOfArray){	for(int i=0;i<lenOfArray;i++)		*f++=*s++;}LikeWorkArray * Node::GetCondLikeAboveBottom(LikeWorkArray **workArrays,int numArrays,bool mustBeFilled/*=true*/){	if(lwa)		if(lwa->owner==this && lwa->description==LikeWorkArray::AboveBott)//make sure that it hasn't been reassigned			return lwa;	if(mustBeFilled)		throw MTHException("Problem: requesting informative likeworkarray, but it hasn't been stored");	lwa=GetFreeWorkArray(workArrays,numArrays);	lwa->description=LikeWorkArray::AboveBott;	lwa->owner=this;	lwa->priority=1;	return lwa;			}	/* Old verion that reads from fileLikeWorkArray * Node::GetCondLikeAboveBottom(LikeWorkArray **workArrays,int numArrays,int lenOfArray,bool mustBeFilled){	if(lwa)		if(lwa->owner==this && lwa->description==LikeWorkArray::AboveBott)//make sure that it hasn't been reassigned			return lwa;	lwa=GetFreeWorkArray(workArrays,numArrays);	lwa->description=LikeWorkArray::AboveBott;	lwa->owner=this;	lwa->priority=currPrioritySetting;	currPrioritySetting++;	if(currPrioritySetting>30000)		throw MTHException("currPrioritySetting Overflow");	if(mustBeFilled)		{ifstream diskversion;		nxsstring fname="zCondLike";		fname+=name;		diskversion.open(fname.c_str());		double *cl=lwa->condLikes;		for(int i=0;i<LikeAttr::currNStates;i++)			{diskversion>>*cl;			cl++;			}		if(!(diskversion.good()))			{diskversion.close();			throw MTHException("Problem reading diskversion of condlike");			}		diskversion.close();		}	return lwa;			}	*/void Node::FreeCondLikeAboveBottom(){	if(lwa)		{if(lwa->owner==this && lwa->description==LikeWorkArray::AboveBott)//make sure that it hasn't been reassigned			lwa->owner=NULL;		lwa=NULL;		}}void Node::ResetLWAs(){	Node* tempno=ldes;	while(tempno)		{tempno->ResetLWAs();		tempno=tempno->next;		}	belowlwa=lwa=NULL;}void Node::OptimizeDescendantsBranches(LikeWorkArray **workArrays,int *nStatesInThisSite,Model **modArrays,LikeWorkArray *below,int totSizeOfArrays, double maxPasses,double delta,int &NumBranchesToSkip,int numArrays,int numSitesInProtein){	belowlwa=below;	bool branchOptimized=false;	if(ldes)		{LikeWorkArray *belowBottomforDescendants=GetFreeWorkArray(workArrays,numArrays);		belowBottomforDescendants->owner=this;		LikeWorkArray *belowTopforDescendants=GetFreeWorkArray(workArrays,numArrays);		belowTopforDescendants->owner=this;		belowTopforDescendants->priority=belowBottomforDescendants->priority=1;		Node *tempno=ldes->next;		Node *nextNode=ldes;		LikeWorkArray *sisterLWA;		//optimize left descendant sub tree		bool needToOptThisSubTree=false;		if(tempno)			{if(NumBranchesToSkip<=0)				  needToOptThisSubTree=true;			else				{int binthisSub=1+nextNode->GetNumBranchesAbove();				if(binthisSub>=NumBranchesToSkip)					needToOptThisSubTree=true;				else					NumBranchesToSkip-=binthisSub;				}			if(needToOptThisSubTree)				{sisterLWA=tempno->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);				MakeFirstArrayProduct(belowBottomforDescendants->condLikes,below->condLikes,sisterLWA->condLikes,totSizeOfArrays);				tempno=tempno->next;				while(tempno)					{sisterLWA=tempno->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);					MakeFirstArrayProduct(belowBottomforDescendants->condLikes,belowBottomforDescendants->condLikes,sisterLWA->condLikes,totSizeOfArrays);					tempno=tempno->next;					}				if(nextNode->ldes)					{belowTopforDescendants->owner=nextNode;					MakeBelowTopFromBelowBottom(*(nextNode->blen),belowTopforDescendants->condLikes,belowBottomforDescendants->condLikes,nStatesInThisSite,modArrays,numSitesInProtein);					nextNode->OptimizeDescendantsBranches(workArrays,nStatesInThisSite,modArrays,belowTopforDescendants,totSizeOfArrays,maxPasses,delta,NumBranchesToSkip,numArrays,numSitesInProtein);					}				else				nextNode->OptimizeDescendantsBranches(workArrays,nStatesInThisSite,modArrays,NULL,totSizeOfArrays,maxPasses,delta,NumBranchesToSkip,numArrays,numSitesInProtein);				}			nextNode=nextNode->next;			}		else			assert(0);//only one descendant				//optimize all other descendant subtrees		while(nextNode)			{needToOptThisSubTree=false;			if(NumBranchesToSkip<=0)				  needToOptThisSubTree=true;			else				{int binthisSub=1+nextNode->GetNumBranchesAbove();				if(binthisSub>=NumBranchesToSkip)					needToOptThisSubTree=true;				else					NumBranchesToSkip-=binthisSub;				}			if(needToOptThisSubTree)				{tempno=ldes;				sisterLWA=tempno->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);				MakeFirstArrayProduct(belowBottomforDescendants->condLikes,below->condLikes,sisterLWA->condLikes,totSizeOfArrays);				tempno=tempno->next;				while(tempno)					{if(tempno!=nextNode)						{sisterLWA=tempno->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);						MakeFirstArrayProduct(belowBottomforDescendants->condLikes,belowBottomforDescendants->condLikes,sisterLWA->condLikes,totSizeOfArrays);						}					tempno=tempno->next;					}				if(nextNode->ldes)					{belowTopforDescendants->owner=nextNode;					MakeBelowTopFromBelowBottom(*(nextNode->blen),belowTopforDescendants->condLikes,belowBottomforDescendants->condLikes,nStatesInThisSite,modArrays,numSitesInProtein);					nextNode->OptimizeDescendantsBranches(workArrays,nStatesInThisSite,modArrays,belowTopforDescendants,totSizeOfArrays,maxPasses,delta,NumBranchesToSkip,numArrays,numSitesInProtein);					}				else					nextNode->OptimizeDescendantsBranches(workArrays,nStatesInThisSite,modArrays,NULL,totSizeOfArrays,maxPasses,delta,NumBranchesToSkip,numArrays,numSitesInProtein);				}			nextNode=nextNode->next;			}		belowTopforDescendants->owner=NULL;		//all of the descendants are optimized, optimize this branch		if(anc)			{if(NumBranchesToSkip<=0)				{if(anc->anc || anc->ldes==this || anc->ldes!=anc->rdes)					{belowBottomforDescendants->owner=NULL;					//fill in the AboveTop LWA with the product of the descendant above bottom condlikes					LikeWorkArray *aboveTop=belowBottomforDescendants;					aboveTop->owner=this;					aboveTop->description=LikeWorkArray::AboveTop;					sisterLWA=ldes->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);					SetFirstArrayEqualToSec(aboveTop->condLikes,sisterLWA->condLikes,totSizeOfArrays);					tempno=ldes->next;					while(tempno)						{sisterLWA=tempno->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);						MakeFirstArrayProduct(aboveTop->condLikes,aboveTop->condLikes,sisterLWA->condLikes,totSizeOfArrays);						tempno=tempno->next;						}					LikeWorkArray *belowBottom=GetFreeWorkArray(workArrays,numArrays);					belowBottom->owner=this;					belowBottom->description=LikeWorkArray::BelowBott;					SetFirstArrayEqualToSec(belowBottom->condLikes,anc->belowlwa->condLikes,totSizeOfArrays);					tempno=anc->ldes;					while(tempno)						{if(tempno!=this)							{sisterLWA=tempno->GetCondLikeAboveBottom(workArrays,numArrays);							MakeFirstArrayProduct(belowBottom->condLikes,belowBottom->condLikes,sisterLWA->condLikes,totSizeOfArrays);							}						tempno=tempno->next;						}					GetCondLikeAboveBottom(workArrays,numArrays,false);//make sure there is something in lwa					cout<<name<<"\t";					TreesCurrentLikelihood=BranchLengthLinearBrent(blen,belowBottom->condLikes,aboveTop->condLikes,lwa->condLikes,NULL,nStatesInThisSite,modArrays,maxPasses,delta,numSitesInProtein);					cout<<TreesCurrentLikelihood<<"\n";					WriteBrLenLike(belowBottom->condLikes,lwa->condLikes,nStatesInThisSite,modArrays,numSitesInProtein,++NumBranchesOptimized);					belowBottom->owner=NULL;					aboveTop->owner=NULL;					branchOptimized=true;						}				}			else NumBranchesToSkip--;			}		else			{//for the root only set lwa to above top conditional likelihood so the likelihood of the whole tree can			//be calculated in Tree::RecursiveBranchLengthSmoothingPass			belowBottomforDescendants->owner=NULL;			//fill in the LWA with the product of the descendant above bottom condlikes			GetCondLikeAboveBottom(workArrays,numArrays,false);//make sure there is something in lwa			lwa->owner=this;			lwa->description=LikeWorkArray::AboveTop;			sisterLWA=ldes->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);			SetFirstArrayEqualToSec(lwa->condLikes,sisterLWA->condLikes,totSizeOfArrays);			tempno=ldes->next;			while(tempno)				{sisterLWA=tempno->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);				MakeFirstArrayProduct(lwa->condLikes,lwa->condLikes,sisterLWA->condLikes,totSizeOfArrays);				tempno=tempno->next;				}			}						tempno=ldes;		while(tempno)			{tempno->FreeCondLikeAboveBottom();			tempno=tempno->next;			}		}	else		{if(anc)			if( NumBranchesToSkip<=0)				{if(anc->anc || anc->ldes==this || anc->ldes!=anc->rdes)					{branchOptimized=true;					if(NumBranchesOptimized==5)						{bool stophere=true;						}					LikeWorkArray *sisterLWA,*belowBottom=GetFreeWorkArray(workArrays,numArrays);					belowBottom->owner=this;					belowBottom->description=LikeWorkArray::BelowBott;					SetFirstArrayEqualToSec(belowBottom->condLikes,anc->belowlwa->condLikes,totSizeOfArrays);					Node *tempno=anc->ldes;					while(tempno)						{if(tempno!=this)							{sisterLWA=tempno->GetCondLikeAboveBottom(workArrays,numArrays,totSizeOfArrays);							MakeFirstArrayProduct(belowBottom->condLikes,belowBottom->condLikes,sisterLWA->condLikes,totSizeOfArrays);							}						tempno=tempno->next;						}					GetCondLikeAboveBottom(workArrays,numArrays,false);//make sure there is something in lwa					cout<<"About to optimize branch of "<<name<<"\t";					TreesCurrentLikelihood=BranchLengthLinearBrent(blen,belowBottom->condLikes,NULL,lwa->condLikes,this,nStatesInThisSite,modArrays,maxPasses,delta,numSitesInProtein);					WriteBrLenLike(belowBottom->condLikes,lwa->condLikes,nStatesInThisSite,modArrays,numSitesInProtein,++NumBranchesOptimized);					cout<<TreesCurrentLikelihood<<"\n";					belowBottom->owner=NULL;					}				}			else				NumBranchesToSkip--;		}			if(branchOptimized)		{/*ofstream diskversion;		nxsstring fname="zCondLike";		fname+=name;		diskversion.open(fname.c_str());		assert(lwa);		assert(lwa->owner==this);		double *cl;		cl=lwa->condLikes;		for(int i=0;i<numSitesInProtein;i++)			{for(int j=0;j<nStatesInThisSite[i];j++)				diskversion<<*cl++<<"\t";			diskversion<<"\n";			}		diskversion.close();*/		ofstream nbodisk;		nxsstring fname="NumBranchesOptimized";		fname+=branchLengthOptLogNum;		nbodisk.open(fname.c_str());		assert(nbodisk.good());		nbodisk<<NumBranchesOptimized<<endl;		nbodisk.close();		ofstream obldisk;		nxsstring sname="OptimizedBranchLengths";		sname+=branchLengthOptLogNum;		obldisk.open(sname.c_str(),ios::app);		obldisk<<setprecision(12);		assert(obldisk.good());		obldisk<<*blen<<endl;		obldisk.close();		}	}#define MINNONZEROBRANCH 1.0e-10#define MAXBRANCH 100000.0struct AtBestBrLen 	{public : double point,score;	AtBestBrLen(double x, double y)	{point=x;score=y;}	};	double BranchLengthLinearBrent(double *branchLength,double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,double maxPasses,double delta,int numSitesInProtein){	#ifndef NEWTON	double a,b,c,ascore,bscore,cscore;	a=*branchLength;	ascore=Node::TreesCurrentLikelihood;	double debugScore=ScoreBranchLength(a,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);	if(fabs(debugScore-ascore)>0.0001)		{bool stophere=true;		assert(0);		}	if(a<MINNONZEROBRANCH)		{		double step=MINNONZEROBRANCH;		ascore=ScoreBranchLength(a,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);		while(fabs(Node::TreesCurrentLikelihood-ascore)<delta)			{step*=2.0;			a+=step;			ascore=ScoreBranchLength(a,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);			}		if(ascore>Node::TreesCurrentLikelihood)			{ScoreBranchLength(*branchLength,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);//to get work updated;			return Node::TreesCurrentLikelihood;			}					//otherwise do Linear Brent on the new branch length		}		try {GetBranchLengthBracket(1,&a,&b,&c,&ascore,&bscore,&cscore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);		}	catch (AtBestBrLen opt)		{*branchLength=opt.point;		ScoreBranchLength(*branchLength,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);//to get work updated;		return opt.score;		}		double temp;	if(a>b)	{temp=ascore;ascore=bscore;bscore=temp;temp=a;a=b;b=temp;}	if(a>c)	{temp=ascore;ascore=cscore;cscore=temp;temp=a;a=c;c=temp;}	if(b>c)	{temp=bscore;bscore=cscore;cscore=temp;temp=b;b=c;c=temp;}	if(!(bscore<ascore && bscore<cscore))//requirement of  brent's method		{		bool stophere=true;		assert(0);		}	double x=b,w=b,v=b,xscore=bscore,wscore=bscore,vscore=bscore,xm,u,uscore;		int iter=0;	double tolOne,tolTwo,e=0.0,d;	bool firstrep=true;	/*if(powellRound==0)		maxPasses=5;*/	do	{xm=(a+c)/2.0;		tolTwo=2.0*(tolOne=FTOL*fabs(x)+ZEPS);		if(fabs(x-xm)<=(tolTwo-((c-a)/2.0)) && !firstrep)			{*branchLength=x;			ScoreBranchLength(*branchLength,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);//to get work updated;			return xscore;			}		if(fabs(e)>FTOL)//make parabolic fit			{double r,p,q,etemp;			r=(x-w)*(xscore-vscore);			q=(x-v)*(xscore-wscore);			p=(x-v)*q-(x-w)*r;			q=2.0*(q-r);			if(q>0.0)	p=-p;			else		q=-q;			etemp=e;			e=d;			if(fabs(p)>=fabs(q*etemp*0.5) || p<= q*(a-x) || p>=q*(c-x))					d=CGOLDEN*(e=(x>xm ? a-x : c-x));			else	{d=p/q;					 u=x+d;					 if(u-a <tolTwo || c-u <tolTwo)					 	d = ((xm-x)<0.0 ? -tolOne : tolOne);					 }			}		else			d=CGOLDEN*(e=(x>=xm ?a-x : c-x));		u=(fabs(d) >=tolOne ? x+d : x + (d<0.0 ? -tolOne :tolOne));		uscore=ScoreBranchLength(u,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);		firstrep=false;		if(uscore<=xscore)			{if(u>=x)	a=x;			else		c=x;			v=w;w=x;x=u;			vscore=wscore;wscore=xscore;xscore=uscore;			}		else			{if(u<x)	a=u;			else		c=u;			if(uscore<=wscore || w==x)				{v=w;w=u;				vscore=wscore;wscore=uscore;				}			else				if(uscore<=vscore || v==x || v==w)					{v=u;					vscore=uscore;					}			}		iter++;		}	while(iter<maxPasses && (wscore-xscore)>delta);	*branchLength=x;	ScoreBranchLength(*branchLength,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);//to get work updated;	return xscore;#else	assert(0);#endif}	double ScoreBranchLength(double bLen,double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein){	//TEMPORARY assumes that uncorrected likelihoods are being used	if(currNode)		{assert(currNode->IsTerm() && !above);//should only be used for terminals as a faster way of computing like		TerminalNodeLikeAttr *thisLA;		double *bottom;		int *nSITStemp;		nSITStemp=nStatesInThisSite;		bottom=work;		currNode->GetLikeAtt(0,0)->SetBLen(bLen);//TEMPORARY assumes that all partitions share the same branch length, which should be true in CodonHack Mode		for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)			{thisLA=(TerminalNodeLikeAttr *)currNode->GetLikeAtt(partitionIt,0);			LikeAttr::currNStates=*nSITStemp;			LikeAttr::Multiplier=(*modArrays++)->GetMultiplier();			thisLA->SetArgToCondLikeOfThisSubTreeWithOutSharedMatrix(bottom);			bottom+=*nSITStemp++;			}		double logLike=0.0;		for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)			{double thisStLike=0.0;			for(int st=0;st<*nStatesInThisSite;st++)				{thisStLike+=(*work++)*(*below++);				}			logLike+=log(thisStLike);			nStatesInThisSite++;			}		return -logLike;		}	else		{double *thisPelement,*bottom, *thisDesc;		int *nSITStemp;		nSITStemp=nStatesInThisSite;		bottom=work;		for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)			{(*modArrays)->UpdatePmatWithOutSharedMatrix(bLen);			thisPelement=**((*modArrays++)->GetPmat());			for(int ancSt=0;ancSt<*nSITStemp;ancSt++)				{*bottom=0.0;				thisDesc=above;				for(int descSt=0;descSt<*nSITStemp;descSt++)					{*bottom+=*thisDesc++**thisPelement++;					}				*bottom++;				}			above+=*nSITStemp++;			}		double logLike=0.0;		for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)			{double thisStLike=0.0;			for(int st=0;st<*nStatesInThisSite;st++)				{thisStLike+=(*work++)*(*below++);				}			logLike+=log(thisStLike);			nStatesInThisSite++;			}		return -logLike;		}}void MakeBelowTopFromBelowBottom(double bLen,double *top,double *bottom,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein){	//TEMPORARY assumes that uncorrected likelihoods are being used	double *thisPelement,*toptemp;	int *nSITStemp;	nSITStemp=nStatesInThisSite;	for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)		{(*modArrays)->UpdatePmatWithOutSharedMatrix(bLen);		thisPelement=**((*modArrays++)->GetPmat());		toptemp=top;		int ancSt=0;		for(int descSt=0;descSt<*nSITStemp;descSt++)			*toptemp++=*bottom**thisPelement++;					bottom++;		ancSt++;		for(;ancSt<*nSITStemp;ancSt++)			{toptemp=top;			for(int descSt=0;descSt<*nSITStemp;descSt++)				*toptemp+++=*bottom**thisPelement++;							bottom++;			}		top+=*nSITStemp++;		}}double ScoreZeroBranchLength(double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein){if(currNode)		{assert(currNode->IsTerm());//should only be used for terminals as a faster way of computing like		TerminalNodeLikeAttr *thisLA;		double *bottom;		int *nSITStemp;		nSITStemp=nStatesInThisSite;		bottom=work;		currNode->GetLikeAtt(0,0)->SetBLen(0.0);//TEMPORARY assumes that all partitions share the same branch length, which should be true in CodonHack Mode		for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)			{thisLA=(TerminalNodeLikeAttr *)currNode->GetLikeAtt(partitionIt,0);			LikeAttr::currNStates=*nSITStemp;			LikeAttr::Multiplier=(*modArrays++)->GetMultiplier();			thisLA->SetArgToCondLikeOfThisSubTreeWithOutSharedMatrix(bottom);			bottom+=*nSITStemp++;			}		double logLike=0.0;		for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)			{double thisStLike=0.0;			for(int st=0;st<*nStatesInThisSite;st++)				{thisStLike+=(*work++)*(*below++);				}			logLike+=log(thisStLike);			nStatesInThisSite++;			}		return -logLike;		}	else		{double logLike=0.0;		for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)			{double thisStLike=0.0;			for(int st=0;st<*nStatesInThisSite;st++)				{*work++=*above;				thisStLike+=(*above++)*(*below++);				}			if(thisStLike>0.0)				logLike+=log(thisStLike);			else 	return MAXDOUBLE;			nStatesInThisSite++;			}		return -logLike;		}}void GetBranchLengthBracket(int numPtsToTrust,double *a,double *b, double *c, double *ascore, double *bscore,double *cscore,double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein){	static int level;	if(numPtsToTrust==1)		{//first try to find the upper bound		level=0;		if(*a>MAXBRANCH-1)			{*b=*a/2.0;			*bscore=ScoreBranchLength(*b,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);			while(fabs(*bscore-*ascore)<SMALLDOUBLE && *b>MINNONZEROBRANCH)				{*b/=2.0;				*bscore=ScoreBranchLength(*b,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);				}			if(fabs(*bscore-*ascore)<SMALLDOUBLE)				assert(0);			GetBranchLengthBracket(2,a,b,c,ascore,bscore,cscore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);			}		else			{if(*a*2.0>MAXBRANCH)				{*b=MAXBRANCH;				*bscore=ScoreBranchLength(*b,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);				if(fabs(*bscore-*ascore)<SMALLDOUBLE)					{GetBranchLengthBracket(1,b,a,c,bscore,ascore,cscore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);					return;					}				}			else				{*b=2.0**a;				*bscore=ScoreBranchLength(*b,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);				if(fabs(*bscore-*ascore)<SMALLDOUBLE)					{while(fabs(*bscore-*ascore)<SMALLDOUBLE && *b<(MAXBRANCH/2.0))						{*b*=2.0;						*bscore=ScoreBranchLength(*b,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);						}					if(fabs(*bscore-*ascore)<SMALLDOUBLE)						{*b=MAXBRANCH;						*bscore=ScoreBranchLength(*b,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);						if(fabs(*bscore-*ascore)<SMALLDOUBLE)							{GetBranchLengthBracket(1,b,a,c,bscore,ascore,cscore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);							return;							}						}					}				}			GetBranchLengthBracket(2,a,b,c,ascore,bscore,cscore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);			}		}	else//two points can be trusted		{level++;		if(*ascore<*bscore)			{double temp=*ascore;			*ascore=*bscore; *bscore=temp;			temp=*a; *a=*b; *b=temp;			}		if(*b<*a)			{*c=*b*pow(.75,level);			if(*c<MINNONZEROBRANCH)				{*c=0.0;				*cscore=ScoreZeroBranchLength(below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);				if(*cscore<=*bscore)					GetMiddleBranchLength(c,b,a,cscore,bscore,ascore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);				return;				}			*cscore=ScoreBranchLength(*c,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);			if(*cscore<*bscore || fabs(*cscore-*bscore)<SMALLDOUBLE)				GetBranchLengthBracket(2,c,b,a,cscore,bscore,ascore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);			}		else			{*c=*b*2.0;			if(*c>MAXBRANCH)				{*c=MAXBRANCH;				*cscore=ScoreBranchLength(*c,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);				if(*cscore<*bscore)					GetMiddleBranchLength(c,b,a,cscore,bscore,ascore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);				return;				}			*cscore=ScoreBranchLength(*c,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);			if(	*cscore<*bscore || fabs(*cscore-*bscore)<SMALLDOUBLE)				GetBranchLengthBracket(2,c,b,a,cscore,bscore,ascore,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);			}		}	return;}void GetMiddleBranchLength(double *a,double *b, double *c, double *ascore, double *bscore,double *cscore,double *below,double *above,double *work,Node *currNode,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein){	//  puts c in between a and b and returns if c is the lowest point, throws AtbestBRLenwhen the bracket is too small to continue optimization	if(*ascore>*bscore)		{double temp=*ascore;		*ascore=*bscore; *bscore=temp;		temp=*a; *a=*b; *b=temp;		}	if(PointsAreFarEnoughApart(*a,*b))		{*c=*b+0.5*(*a-*b);		*cscore=ScoreBranchLength(*c,below,above,work,currNode,nStatesInThisSite,modArrays,numSitesInProtein);		if(*cscore+SMALLDOUBLE>*ascore)			GetMiddleBranchLength(a,c,b, ascore, cscore,bscore, below, above, work,currNode, nStatesInThisSite, modArrays,numSitesInProtein);		return;		}	throw AtBestBrLen(*a,*ascore);}void WriteBrLenLike(double *below,double *above,int *nStatesInThisSite,Model **modArrays,int numSitesInProtein,int nOfBranch){	ofstream outpf;	nxsstring fname="BranchLengthsLikelihoods";	fname+=Node::branchLengthOptLogNum;	outpf.open(fname.c_str(),ios::app);	outpf<<"Branch "<<nOfBranch;	outpf<<setprecision(12);	for(int partitionIt=0;partitionIt<numSitesInProtein;partitionIt++)		{double thisStLike=0.0;		for(int st=0;st<*nStatesInThisSite;st++)			thisStLike+=(*above++)*(*below++);		outpf<<" "<<-log(thisStLike);		nStatesInThisSite++;		}	outpf<<endl;	outpf.close();	}#endif